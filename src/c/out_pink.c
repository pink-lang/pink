// Generated by Pink

#define __USE_MINGW_ANSI_STDIO 1
#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif
#ifndef _CRT_NONSTDC_NO_DEPRECATE
#define _CRT_NONSTDC_NO_DEPRECATE
#endif

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wvarargs"
#endif

#include <stdbool.h>
#include <stdint.h>
#include <stddef.h>
#include <stdarg.h>

typedef unsigned char uchar;
typedef signed char schar;
typedef unsigned short ushort;
typedef unsigned int uint;
typedef unsigned long ulong;
typedef long long llong;
typedef unsigned long long ullong;

#ifdef _MSC_VER
#define alignof(x) __alignof(x)
#else
#define alignof(x) __alignof__(x)
#endif

#define va_start_ptr(args, arg) (va_start(*(args), *(arg)))
#define va_copy_ptr(dest, src) (va_copy(*(dest), *(src)))
#define va_end_ptr(args) (va_end(*(args)))

struct Any;
static void va_arg_ptr(va_list *args, struct Any any);


// Foreign preamble
typedef struct tm tm_t;
typedef struct _finddata64i32_t FindData;

// Foreign header files
#include <limits.h>
#include <stdint.h>
#include <ctype.h>
#include <errno.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <io.h>

// Forward declarations
typedef struct TypeInfo TypeInfo;
typedef struct old_std_Arena old_std_Arena;
typedef struct src_pink_SrcPos src_pink_SrcPos;
typedef struct src_pink_Note src_pink_Note;
typedef struct src_pink_Notes src_pink_Notes;
typedef struct src_pink_StmtList src_pink_StmtList;
typedef struct old_std_Map old_std_Map;
typedef struct src_pink_Token src_pink_Token;
typedef struct src_pink_CompoundField src_pink_CompoundField;
typedef struct src_pink_SwitchCasePattern src_pink_SwitchCasePattern;
typedef struct src_pink_SwitchCase src_pink_SwitchCase;
typedef struct src_pink_EnumItem src_pink_EnumItem;
typedef struct src_pink_AggregateItem src_pink_AggregateItem;
typedef struct src_pink_FuncParam src_pink_FuncParam;
typedef struct src_pink_NoteArg src_pink_NoteArg;
typedef union old_std_Val old_std_Val;
typedef struct src_pink_Sym src_pink_Sym;
typedef struct src_pink_Operand src_pink_Operand;
typedef struct src_pink_Label src_pink_Label;
typedef struct src_pink_StmtCtx src_pink_StmtCtx;
typedef struct src_pink_TypeMetrics src_pink_TypeMetrics;
typedef struct src_pink_TypeAggregate src_pink_TypeAggregate;
typedef struct src_pink_TypeFunc src_pink_TypeFunc;
typedef struct src_pink_Type src_pink_Type;
typedef struct TypeFieldInfo TypeFieldInfo;
typedef struct Any Any;
typedef struct src_pink_StmtIf src_pink_StmtIf;
typedef struct src_pink_StmtWhile src_pink_StmtWhile;
typedef struct src_pink_StmtFor src_pink_StmtFor;
typedef struct src_pink_StmtSwitch src_pink_StmtSwitch;
typedef struct src_pink_StmtAssign src_pink_StmtAssign;
typedef struct src_pink_StmtInit src_pink_StmtInit;
typedef struct src_pink_Stmt src_pink_Stmt;
typedef struct src_pink_TypespecFunc src_pink_TypespecFunc;
typedef struct src_pink_Typespec src_pink_Typespec;
typedef struct src_pink_ExprParen src_pink_ExprParen;
typedef struct src_pink_ExprIntLit src_pink_ExprIntLit;
typedef struct src_pink_ExprFloatLit src_pink_ExprFloatLit;
typedef struct src_pink_ExprStrLit src_pink_ExprStrLit;
typedef struct src_pink_ExprOffsetofField src_pink_ExprOffsetofField;
typedef struct src_pink_ExprCompound src_pink_ExprCompound;
typedef struct src_pink_ExprCast src_pink_ExprCast;
typedef struct src_pink_ExprModify src_pink_ExprModify;
typedef struct src_pink_ExprUnary src_pink_ExprUnary;
typedef struct src_pink_ExprBinary src_pink_ExprBinary;
typedef struct src_pink_ExprTernary src_pink_ExprTernary;
typedef struct src_pink_ExprCall src_pink_ExprCall;
typedef struct src_pink_ExprIndex src_pink_ExprIndex;
typedef struct src_pink_ExprField src_pink_ExprField;
typedef struct src_pink_Expr src_pink_Expr;
typedef struct src_pink_Decls src_pink_Decls;
typedef struct src_pink_DeclEnum src_pink_DeclEnum;
typedef struct src_pink_DeclFunc src_pink_DeclFunc;
typedef struct src_pink_DeclTypedef src_pink_DeclTypedef;
typedef struct src_pink_DeclVar src_pink_DeclVar;
typedef struct src_pink_DeclImport src_pink_DeclImport;
typedef struct src_pink_Decl src_pink_Decl;
typedef struct src_pink_Aggregate src_pink_Aggregate;
typedef struct src_pink_ImportItem src_pink_ImportItem;
typedef struct src_pink_ElseIf src_pink_ElseIf;
typedef struct src_pink_Package src_pink_Package;
typedef struct src_pink_TypeField src_pink_TypeField;
typedef struct old_std_os_DirListIter old_std_os_DirListIter;
typedef struct src_pink_CachedArrayType src_pink_CachedArrayType;
typedef struct src_pink_CachedFuncType src_pink_CachedFuncType;
typedef struct old_std_BufHdr old_std_BufHdr;
typedef struct old_std_Intern old_std_Intern;
typedef struct old_std_os_FlagDefPtr old_std_os_FlagDefPtr;
typedef struct old_std_os_FlagDef old_std_os_FlagDef;

// Sorted declarations
int main(int argc, char const ((*(*argv))));

extern char const ((*current_os));

extern char const ((*current_arch));

typedef ullong typeid;

typedef int TypeKind;

#define TYPE_NONE ((TypeKind)(0))

#define TYPE_VOID ((TypeKind)((TYPE_NONE) + (1)))

#define TYPE_BOOL ((TypeKind)((TYPE_VOID) + (1)))

#define TYPE_CHAR ((TypeKind)((TYPE_BOOL) + (1)))

#define TYPE_UCHAR ((TypeKind)((TYPE_CHAR) + (1)))

#define TYPE_SCHAR ((TypeKind)((TYPE_UCHAR) + (1)))

#define TYPE_SHORT ((TypeKind)((TYPE_SCHAR) + (1)))

#define TYPE_USHORT ((TypeKind)((TYPE_SHORT) + (1)))

#define TYPE_INT ((TypeKind)((TYPE_USHORT) + (1)))

#define TYPE_UINT ((TypeKind)((TYPE_INT) + (1)))

#define TYPE_LONG ((TypeKind)((TYPE_UINT) + (1)))

#define TYPE_ULONG ((TypeKind)((TYPE_LONG) + (1)))

#define TYPE_LLONG ((TypeKind)((TYPE_ULONG) + (1)))

#define TYPE_ULLONG ((TypeKind)((TYPE_LLONG) + (1)))

#define TYPE_FLOAT ((TypeKind)((TYPE_ULLONG) + (1)))

#define TYPE_DOUBLE ((TypeKind)((TYPE_FLOAT) + (1)))

#define TYPE_CONST ((TypeKind)((TYPE_DOUBLE) + (1)))

#define TYPE_PTR ((TypeKind)((TYPE_CONST) + (1)))

#define TYPE_ARRAY ((TypeKind)((TYPE_PTR) + (1)))

#define TYPE_STRUCT ((TypeKind)((TYPE_ARRAY) + (1)))

#define TYPE_UNION ((TypeKind)((TYPE_STRUCT) + (1)))

#define TYPE_FUNC ((TypeKind)((TYPE_UNION) + (1)))

struct TypeInfo {
    TypeKind kind;
    int size;
    int align;
    char const ((*name));
    int count;
    typeid base;
    TypeFieldInfo (*fields);
    int num_fields;
};

TypeKind typeid_kind(typeid type);

int typeid_index(typeid type);

size_t typeid_size(typeid type);

TypeInfo const ((*get_typeinfo(typeid type)));

#define UCHAR_MIN ((uchar)(0))

#define USHORT_MIN ((short)(0))

#define UINT_MIN ((uint)(0))

#define ULLONG_MIN ((ullong)(0))

#define UINT8_MIN (UCHAR_MIN)

#define UINT16_MIN (USHORT_MIN)

#define UINT32_MIN (UINT_MIN)

#define UINT64_MIN (ULLONG_MIN)

#define ULONG_MIN ((ulong)(INT32_MIN))

#define USIZE_MIN (UINT64_MIN)

#define UINTPTR_MIN (UINT64_MIN)

struct old_std_Arena {
    char (*ptr);
    char (*end);
    char (*(*blocks));
};

extern old_std_Arena src_pink_ast_arena;

void (*src_pink_ast_alloc(size_t size));

void (*src_pink_ast_dup(void const ((*src)), size_t size));

struct src_pink_SrcPos {
    char const ((*name));
    int line;
};

struct src_pink_Note {
    src_pink_SrcPos pos;
    char const ((*name));
    src_pink_NoteArg (*args);
    size_t num_args;
};

src_pink_Note src_pink_new_note(src_pink_SrcPos pos, char const ((*name)), src_pink_NoteArg (*args), size_t num_args);

struct src_pink_Notes {
    src_pink_Note (*notes);
    size_t num_notes;
};

src_pink_Notes src_pink_new_notes(src_pink_Note (*notes), size_t num_notes);

struct src_pink_StmtList {
    src_pink_SrcPos pos;
    src_pink_Stmt (*(*stmts));
    size_t num_stmts;
};

src_pink_StmtList src_pink_new_stmt_list(src_pink_SrcPos pos, src_pink_Stmt (*(*stmts)), size_t num_stmts);

typedef int src_pink_TypespecKind;

src_pink_Typespec (*src_pink_new_typespec(src_pink_TypespecKind kind, src_pink_SrcPos pos));

src_pink_Typespec (*src_pink_new_typespec_name(src_pink_SrcPos pos, char const ((*name))));

src_pink_Typespec (*src_pink_new_typespec_ptr(src_pink_SrcPos pos, src_pink_Typespec (*base)));

src_pink_Typespec (*src_pink_new_typespec_const(src_pink_SrcPos pos, src_pink_Typespec (*base)));

src_pink_Typespec (*src_pink_new_typespec_array(src_pink_SrcPos pos, src_pink_Typespec (*elem), src_pink_Expr (*size)));

src_pink_Typespec (*src_pink_new_typespec_func(src_pink_SrcPos pos, src_pink_Typespec (*(*args)), size_t num_args, src_pink_Typespec (*ret), bool has_varargs));

src_pink_Decls (*src_pink_new_decls(src_pink_Decl (*(*decls)), size_t num_decls));

typedef int src_pink_DeclKind;

src_pink_Decl (*src_pink_new_decl(src_pink_DeclKind kind, src_pink_SrcPos pos, char const ((*name))));

src_pink_Note (*src_pink_get_decl_note(src_pink_Decl (*decl), char const ((*name))));

bool src_pink_is_decl_foreign(src_pink_Decl (*decl));

src_pink_Decl (*src_pink_new_decl_enum(src_pink_SrcPos pos, char const ((*name)), src_pink_Typespec (*type), src_pink_EnumItem (*items), size_t num_items));

typedef int src_pink_AggregateKind;

src_pink_Aggregate (*src_pink_new_aggregate(src_pink_SrcPos pos, src_pink_AggregateKind kind, src_pink_AggregateItem (*items), size_t num_items));

src_pink_Decl (*src_pink_new_decl_aggregate(src_pink_SrcPos pos, src_pink_DeclKind kind, char const ((*name)), src_pink_Aggregate (*aggregate)));

src_pink_Decl (*src_pink_new_decl_var(src_pink_SrcPos pos, char const ((*name)), src_pink_Typespec (*type), src_pink_Expr (*expr)));

src_pink_Decl (*src_pink_new_decl_func(src_pink_SrcPos pos, char const ((*name)), src_pink_FuncParam (*params), size_t num_params, src_pink_Typespec (*ret_type), bool has_varargs, src_pink_StmtList block));

src_pink_Decl (*src_pink_new_decl_const(src_pink_SrcPos pos, char const ((*name)), src_pink_Typespec (*type), src_pink_Expr (*expr)));

src_pink_Decl (*src_pink_new_decl_typedef(src_pink_SrcPos pos, char const ((*name)), src_pink_Typespec (*type)));

src_pink_Decl (*src_pink_new_decl_note(src_pink_SrcPos pos, src_pink_Note note));

src_pink_Decl (*src_pink_new_decl_import(src_pink_SrcPos pos, char const ((*rename_name)), bool is_relative, char const ((*(*names))), size_t num_names, bool import_all, src_pink_ImportItem (*items), size_t num_items));

typedef int src_pink_ExprKind;

src_pink_Expr (*src_pink_new_expr(src_pink_ExprKind kind, src_pink_SrcPos pos));

src_pink_Expr (*src_pink_new_expr_paren(src_pink_SrcPos pos, src_pink_Expr (*expr)));

src_pink_Expr (*src_pink_new_expr_sizeof_expr(src_pink_SrcPos pos, src_pink_Expr (*expr)));

src_pink_Expr (*src_pink_new_expr_sizeof_type(src_pink_SrcPos pos, src_pink_Typespec (*type)));

src_pink_Expr (*src_pink_new_expr_typeof_expr(src_pink_SrcPos pos, src_pink_Expr (*expr)));

src_pink_Expr (*src_pink_new_expr_typeof_type(src_pink_SrcPos pos, src_pink_Typespec (*type)));

src_pink_Expr (*src_pink_new_expr_alignof_expr(src_pink_SrcPos pos, src_pink_Expr (*expr)));

src_pink_Expr (*src_pink_new_expr_alignof_type(src_pink_SrcPos pos, src_pink_Typespec (*type)));

src_pink_Expr (*src_pink_new_expr_offsetof(src_pink_SrcPos pos, src_pink_Typespec (*type), char const ((*name))));

typedef int src_pink_TokenKind;

src_pink_Expr (*src_pink_new_expr_modify(src_pink_SrcPos pos, src_pink_TokenKind op, bool post, src_pink_Expr (*expr)));

typedef int src_pink_TokenMod;

typedef int src_pink_TokenSuffix;

src_pink_Expr (*src_pink_new_expr_int(src_pink_SrcPos pos, ullong val, src_pink_TokenMod mod, src_pink_TokenSuffix suffix));

src_pink_Expr (*src_pink_new_expr_float(src_pink_SrcPos pos, char const ((*start)), char const ((*end)), double val, src_pink_TokenSuffix suffix));

src_pink_Expr (*src_pink_new_expr_str(src_pink_SrcPos pos, char const ((*val)), src_pink_TokenMod mod));

src_pink_Expr (*src_pink_new_expr_name(src_pink_SrcPos pos, char const ((*name))));

src_pink_Expr (*src_pink_new_expr_compound(src_pink_SrcPos pos, src_pink_Typespec (*type), src_pink_CompoundField (*fields), size_t num_fields));

src_pink_Expr (*src_pink_new_expr_cast(src_pink_SrcPos pos, src_pink_Typespec (*type), src_pink_Expr (*expr)));

src_pink_Expr (*src_pink_new_expr_call(src_pink_SrcPos pos, src_pink_Expr (*expr), src_pink_Expr (*(*args)), size_t num_args));

src_pink_Expr (*src_pink_new_expr_index(src_pink_SrcPos pos, src_pink_Expr (*expr), src_pink_Expr (*index)));

src_pink_Expr (*src_pink_new_expr_field(src_pink_SrcPos pos, src_pink_Expr (*expr), char const ((*name))));

src_pink_Expr (*src_pink_new_expr_unary(src_pink_SrcPos pos, src_pink_TokenKind op, src_pink_Expr (*expr)));

src_pink_Expr (*src_pink_new_expr_binary(src_pink_SrcPos pos, src_pink_TokenKind op, src_pink_Expr (*left), src_pink_Expr (*right)));

src_pink_Expr (*src_pink_new_expr_ternary(src_pink_SrcPos pos, src_pink_Expr (*cond), src_pink_Expr (*then_expr), src_pink_Expr (*else_expr)));

src_pink_Note (*src_pink_get_stmt_note(src_pink_Stmt (*stmt), char const ((*name))));

typedef int src_pink_StmtKind;

src_pink_Stmt (*src_pink_new_stmt(src_pink_StmtKind kind, src_pink_SrcPos pos));

src_pink_Stmt (*src_pink_new_stmt_label(src_pink_SrcPos pos, char const ((*label))));

src_pink_Stmt (*src_pink_new_stmt_goto(src_pink_SrcPos pos, char const ((*label))));

src_pink_Stmt (*src_pink_new_stmt_note(src_pink_SrcPos pos, src_pink_Note note));

src_pink_Stmt (*src_pink_new_stmt_decl(src_pink_SrcPos pos, src_pink_Decl (*decl)));

src_pink_Stmt (*src_pink_new_stmt_return(src_pink_SrcPos pos, src_pink_Expr (*expr)));

src_pink_Stmt (*src_pink_new_stmt_break(src_pink_SrcPos pos));

src_pink_Stmt (*src_pink_new_stmt_continue(src_pink_SrcPos pos));

src_pink_Stmt (*src_pink_new_stmt_block(src_pink_SrcPos pos, src_pink_StmtList block));

src_pink_Stmt (*src_pink_new_stmt_if(src_pink_SrcPos pos, src_pink_Stmt (*init), src_pink_Expr (*cond), src_pink_StmtList then_block, src_pink_ElseIf (*elseifs), size_t num_elseifs, src_pink_StmtList else_block));

src_pink_Stmt (*src_pink_new_stmt_while(src_pink_SrcPos pos, src_pink_Expr (*cond), src_pink_StmtList block));

src_pink_Stmt (*src_pink_new_stmt_do_while(src_pink_SrcPos pos, src_pink_Expr (*cond), src_pink_StmtList block));

src_pink_Stmt (*src_pink_new_stmt_for(src_pink_SrcPos pos, src_pink_Stmt (*init), src_pink_Expr (*cond), src_pink_Stmt (*next), src_pink_StmtList block));

src_pink_Stmt (*src_pink_new_stmt_switch(src_pink_SrcPos pos, src_pink_Expr (*expr), src_pink_SwitchCase (*cases), size_t num_cases));

src_pink_Stmt (*src_pink_new_stmt_assign(src_pink_SrcPos pos, src_pink_TokenKind op, src_pink_Expr (*left), src_pink_Expr (*right)));

src_pink_Stmt (*src_pink_new_stmt_init(src_pink_SrcPos pos, char const ((*name)), src_pink_Typespec (*type), src_pink_Expr (*expr)));

src_pink_Stmt (*src_pink_new_stmt_expr(src_pink_SrcPos pos, src_pink_Expr (*expr)));

#define SRC_PINK_TYPESPEC_NONE ((src_pink_TypespecKind)(0))

#define SRC_PINK_TYPESPEC_NAME ((src_pink_TypespecKind)((SRC_PINK_TYPESPEC_NONE) + (1)))

#define SRC_PINK_TYPESPEC_FUNC ((src_pink_TypespecKind)((SRC_PINK_TYPESPEC_NAME) + (1)))

#define SRC_PINK_TYPESPEC_ARRAY ((src_pink_TypespecKind)((SRC_PINK_TYPESPEC_FUNC) + (1)))

#define SRC_PINK_TYPESPEC_PTR ((src_pink_TypespecKind)((SRC_PINK_TYPESPEC_ARRAY) + (1)))

#define SRC_PINK_TYPESPEC_CONST ((src_pink_TypespecKind)((SRC_PINK_TYPESPEC_PTR) + (1)))

typedef int src_pink_AggregateItemKind;

#define SRC_PINK_AGGREGATE_ITEM_NONE ((src_pink_AggregateItemKind)(0))

#define SRC_PINK_AGGREGATE_ITEM_FIELD ((src_pink_AggregateItemKind)((SRC_PINK_AGGREGATE_ITEM_NONE) + (1)))

#define SRC_PINK_AGGREGATE_ITEM_SUBAGGREGATE ((src_pink_AggregateItemKind)((SRC_PINK_AGGREGATE_ITEM_FIELD) + (1)))

#define SRC_PINK_DECL_NONE ((src_pink_DeclKind)(0))

#define SRC_PINK_DECL_ENUM ((src_pink_DeclKind)((SRC_PINK_DECL_NONE) + (1)))

#define SRC_PINK_DECL_STRUCT ((src_pink_DeclKind)((SRC_PINK_DECL_ENUM) + (1)))

#define SRC_PINK_DECL_UNION ((src_pink_DeclKind)((SRC_PINK_DECL_STRUCT) + (1)))

#define SRC_PINK_DECL_VAR ((src_pink_DeclKind)((SRC_PINK_DECL_UNION) + (1)))

#define SRC_PINK_DECL_CONST ((src_pink_DeclKind)((SRC_PINK_DECL_VAR) + (1)))

#define SRC_PINK_DECL_TYPEDEF ((src_pink_DeclKind)((SRC_PINK_DECL_CONST) + (1)))

#define SRC_PINK_DECL_FUNC ((src_pink_DeclKind)((SRC_PINK_DECL_TYPEDEF) + (1)))

#define SRC_PINK_DECL_NOTE ((src_pink_DeclKind)((SRC_PINK_DECL_FUNC) + (1)))

#define SRC_PINK_DECL_IMPORT ((src_pink_DeclKind)((SRC_PINK_DECL_NOTE) + (1)))

#define SRC_PINK_AGGREGATE_NONE ((src_pink_AggregateKind)(0))

#define SRC_PINK_AGGREGATE_STRUCT ((src_pink_AggregateKind)((SRC_PINK_AGGREGATE_NONE) + (1)))

#define SRC_PINK_AGGREGATE_UNION ((src_pink_AggregateKind)((SRC_PINK_AGGREGATE_STRUCT) + (1)))

#define SRC_PINK_EXPR_NONE ((src_pink_ExprKind)(0))

#define SRC_PINK_EXPR_PAREN ((src_pink_ExprKind)((SRC_PINK_EXPR_NONE) + (1)))

#define SRC_PINK_EXPR_INT ((src_pink_ExprKind)((SRC_PINK_EXPR_PAREN) + (1)))

#define SRC_PINK_EXPR_FLOAT ((src_pink_ExprKind)((SRC_PINK_EXPR_INT) + (1)))

#define SRC_PINK_EXPR_STR ((src_pink_ExprKind)((SRC_PINK_EXPR_FLOAT) + (1)))

#define SRC_PINK_EXPR_NAME ((src_pink_ExprKind)((SRC_PINK_EXPR_STR) + (1)))

#define SRC_PINK_EXPR_CAST ((src_pink_ExprKind)((SRC_PINK_EXPR_NAME) + (1)))

#define SRC_PINK_EXPR_CALL ((src_pink_ExprKind)((SRC_PINK_EXPR_CAST) + (1)))

#define SRC_PINK_EXPR_INDEX ((src_pink_ExprKind)((SRC_PINK_EXPR_CALL) + (1)))

#define SRC_PINK_EXPR_FIELD ((src_pink_ExprKind)((SRC_PINK_EXPR_INDEX) + (1)))

#define SRC_PINK_EXPR_COMPOUND ((src_pink_ExprKind)((SRC_PINK_EXPR_FIELD) + (1)))

#define SRC_PINK_EXPR_UNARY ((src_pink_ExprKind)((SRC_PINK_EXPR_COMPOUND) + (1)))

#define SRC_PINK_EXPR_BINARY ((src_pink_ExprKind)((SRC_PINK_EXPR_UNARY) + (1)))

#define SRC_PINK_EXPR_TERNARY ((src_pink_ExprKind)((SRC_PINK_EXPR_BINARY) + (1)))

#define SRC_PINK_EXPR_MODIFY ((src_pink_ExprKind)((SRC_PINK_EXPR_TERNARY) + (1)))

#define SRC_PINK_EXPR_SIZEOF_EXPR ((src_pink_ExprKind)((SRC_PINK_EXPR_MODIFY) + (1)))

#define SRC_PINK_EXPR_SIZEOF_TYPE ((src_pink_ExprKind)((SRC_PINK_EXPR_SIZEOF_EXPR) + (1)))

#define SRC_PINK_EXPR_TYPEOF_EXPR ((src_pink_ExprKind)((SRC_PINK_EXPR_SIZEOF_TYPE) + (1)))

#define SRC_PINK_EXPR_TYPEOF_TYPE ((src_pink_ExprKind)((SRC_PINK_EXPR_TYPEOF_EXPR) + (1)))

#define SRC_PINK_EXPR_ALIGNOF_EXPR ((src_pink_ExprKind)((SRC_PINK_EXPR_TYPEOF_TYPE) + (1)))

#define SRC_PINK_EXPR_ALIGNOF_TYPE ((src_pink_ExprKind)((SRC_PINK_EXPR_ALIGNOF_EXPR) + (1)))

#define SRC_PINK_EXPR_OFFSETOF ((src_pink_ExprKind)((SRC_PINK_EXPR_ALIGNOF_TYPE) + (1)))

typedef int src_pink_CompoundFieldKind;

#define SRC_PINK_FIELD_DEFAULT ((src_pink_CompoundFieldKind)(0))

#define SRC_PINK_FIELD_NAME ((src_pink_CompoundFieldKind)((SRC_PINK_FIELD_DEFAULT) + (1)))

#define SRC_PINK_FIELD_INDEX ((src_pink_CompoundFieldKind)((SRC_PINK_FIELD_NAME) + (1)))

#define SRC_PINK_STMT_NONE ((src_pink_StmtKind)(0))

#define SRC_PINK_STMT_DECL ((src_pink_StmtKind)((SRC_PINK_STMT_NONE) + (1)))

#define SRC_PINK_STMT_RETURN ((src_pink_StmtKind)((SRC_PINK_STMT_DECL) + (1)))

#define SRC_PINK_STMT_BREAK ((src_pink_StmtKind)((SRC_PINK_STMT_RETURN) + (1)))

#define SRC_PINK_STMT_CONTINUE ((src_pink_StmtKind)((SRC_PINK_STMT_BREAK) + (1)))

#define SRC_PINK_STMT_BLOCK ((src_pink_StmtKind)((SRC_PINK_STMT_CONTINUE) + (1)))

#define SRC_PINK_STMT_IF ((src_pink_StmtKind)((SRC_PINK_STMT_BLOCK) + (1)))

#define SRC_PINK_STMT_WHILE ((src_pink_StmtKind)((SRC_PINK_STMT_IF) + (1)))

#define SRC_PINK_STMT_DO_WHILE ((src_pink_StmtKind)((SRC_PINK_STMT_WHILE) + (1)))

#define SRC_PINK_STMT_FOR ((src_pink_StmtKind)((SRC_PINK_STMT_DO_WHILE) + (1)))

#define SRC_PINK_STMT_SWITCH ((src_pink_StmtKind)((SRC_PINK_STMT_FOR) + (1)))

#define SRC_PINK_STMT_ASSIGN ((src_pink_StmtKind)((SRC_PINK_STMT_SWITCH) + (1)))

#define SRC_PINK_STMT_INIT ((src_pink_StmtKind)((SRC_PINK_STMT_ASSIGN) + (1)))

#define SRC_PINK_STMT_EXPR ((src_pink_StmtKind)((SRC_PINK_STMT_INIT) + (1)))

#define SRC_PINK_STMT_NOTE ((src_pink_StmtKind)((SRC_PINK_STMT_EXPR) + (1)))

#define SRC_PINK_STMT_LABEL ((src_pink_StmtKind)((SRC_PINK_STMT_NOTE) + (1)))

#define SRC_PINK_STMT_GOTO ((src_pink_StmtKind)((SRC_PINK_STMT_LABEL) + (1)))

extern char (*src_pink_gen_buf);

extern int src_pink_gen_indent;

extern src_pink_SrcPos src_pink_gen_pos;

extern char const ((*(*src_pink_gen_headers_buf)));

extern char (*src_pink_gen_preamble_str);

extern char (*src_pink_gen_postamble_str);

void src_pink_genln(void);

bool src_pink_is_incomplete_array_typespec(src_pink_Typespec (*typespec));

extern char (src_pink_char_to_escape[256]);

void src_pink_gen_char(char c);

void src_pink_gen_str(char const ((*str)), bool multiline);

void src_pink_gen_sync_pos(src_pink_SrcPos pos);

char const ((*src_pink_cdecl_paren(char const ((*str)), char c)));

char const ((*src_pink_cdecl_name(src_pink_Type (*type))));

char (*src_pink_type_to_cdecl(src_pink_Type (*type), char const ((*str))));

char const ((*src_pink_gen_expr_str(src_pink_Expr (*expr))));

struct old_std_Map {
    uint64_t (*keys);
    uint64_t (*vals);
    size_t len;
    size_t cap;
};

extern old_std_Map src_pink_gen_name_map;

char const ((*src_pink_get_gen_name_or_default(void const ((*ptr)), char const ((*default_name)))));

char const ((*src_pink_get_gen_name(void const ((*ptr)))));

char (*src_pink_typespec_to_cdecl(src_pink_Typespec (*typespec), char const ((*str))));

void src_pink_gen_func_decl(src_pink_Decl (*decl));

bool src_pink_gen_reachable(src_pink_Sym (*sym));

void src_pink_gen_forward_decls(void);

void src_pink_gen_aggregate_items(src_pink_Aggregate (*aggregate));

void src_pink_gen_aggregate(src_pink_Decl (*decl));

void src_pink_gen_paren_expr(src_pink_Expr (*expr));

void src_pink_gen_expr_compound(src_pink_Expr (*expr));

typedef int src_pink_CompilerTypeKind;

#define SRC_PINK_CMPL_TYPE_NONE ((src_pink_CompilerTypeKind)(0))

#define SRC_PINK_CMPL_TYPE_INCOMPLETE ((src_pink_CompilerTypeKind)((SRC_PINK_CMPL_TYPE_NONE) + (1)))

#define SRC_PINK_CMPL_TYPE_COMPLETING ((src_pink_CompilerTypeKind)((SRC_PINK_CMPL_TYPE_INCOMPLETE) + (1)))

#define SRC_PINK_CMPL_TYPE_VOID ((src_pink_CompilerTypeKind)((SRC_PINK_CMPL_TYPE_COMPLETING) + (1)))

#define SRC_PINK_CMPL_TYPE_BOOL ((src_pink_CompilerTypeKind)((SRC_PINK_CMPL_TYPE_VOID) + (1)))

#define SRC_PINK_CMPL_TYPE_CHAR ((src_pink_CompilerTypeKind)((SRC_PINK_CMPL_TYPE_BOOL) + (1)))

#define SRC_PINK_CMPL_TYPE_SCHAR ((src_pink_CompilerTypeKind)((SRC_PINK_CMPL_TYPE_CHAR) + (1)))

#define SRC_PINK_CMPL_TYPE_UCHAR ((src_pink_CompilerTypeKind)((SRC_PINK_CMPL_TYPE_SCHAR) + (1)))

#define SRC_PINK_CMPL_TYPE_SHORT ((src_pink_CompilerTypeKind)((SRC_PINK_CMPL_TYPE_UCHAR) + (1)))

#define SRC_PINK_CMPL_TYPE_USHORT ((src_pink_CompilerTypeKind)((SRC_PINK_CMPL_TYPE_SHORT) + (1)))

#define SRC_PINK_CMPL_TYPE_INT ((src_pink_CompilerTypeKind)((SRC_PINK_CMPL_TYPE_USHORT) + (1)))

#define SRC_PINK_CMPL_TYPE_UINT ((src_pink_CompilerTypeKind)((SRC_PINK_CMPL_TYPE_INT) + (1)))

#define SRC_PINK_CMPL_TYPE_LONG ((src_pink_CompilerTypeKind)((SRC_PINK_CMPL_TYPE_UINT) + (1)))

#define SRC_PINK_CMPL_TYPE_ULONG ((src_pink_CompilerTypeKind)((SRC_PINK_CMPL_TYPE_LONG) + (1)))

#define SRC_PINK_CMPL_TYPE_LLONG ((src_pink_CompilerTypeKind)((SRC_PINK_CMPL_TYPE_ULONG) + (1)))

#define SRC_PINK_CMPL_TYPE_ULLONG ((src_pink_CompilerTypeKind)((SRC_PINK_CMPL_TYPE_LLONG) + (1)))

#define SRC_PINK_CMPL_TYPE_ENUM ((src_pink_CompilerTypeKind)((SRC_PINK_CMPL_TYPE_ULLONG) + (1)))

#define SRC_PINK_CMPL_TYPE_FLOAT ((src_pink_CompilerTypeKind)((SRC_PINK_CMPL_TYPE_ENUM) + (1)))

#define SRC_PINK_CMPL_TYPE_DOUBLE ((src_pink_CompilerTypeKind)((SRC_PINK_CMPL_TYPE_FLOAT) + (1)))

#define SRC_PINK_CMPL_TYPE_PTR ((src_pink_CompilerTypeKind)((SRC_PINK_CMPL_TYPE_DOUBLE) + (1)))

#define SRC_PINK_CMPL_TYPE_FUNC ((src_pink_CompilerTypeKind)((SRC_PINK_CMPL_TYPE_PTR) + (1)))

#define SRC_PINK_CMPL_TYPE_ARRAY ((src_pink_CompilerTypeKind)((SRC_PINK_CMPL_TYPE_FUNC) + (1)))

#define SRC_PINK_CMPL_TYPE_STRUCT ((src_pink_CompilerTypeKind)((SRC_PINK_CMPL_TYPE_ARRAY) + (1)))

#define SRC_PINK_CMPL_TYPE_UNION ((src_pink_CompilerTypeKind)((SRC_PINK_CMPL_TYPE_STRUCT) + (1)))

#define SRC_PINK_CMPL_TYPE_CONST ((src_pink_CompilerTypeKind)((SRC_PINK_CMPL_TYPE_UNION) + (1)))

#define SRC_PINK_NUM_CMPL_TYPE_KINDS ((src_pink_CompilerTypeKind)((SRC_PINK_CMPL_TYPE_CONST) + (1)))

extern char const ((*(src_pink_typeid_kind_names[SRC_PINK_NUM_CMPL_TYPE_KINDS])));

char const ((*src_pink_typeid_kind_name(src_pink_Type (*type))));

bool src_pink_is_excluded_typeinfo(src_pink_Type (*type));

void src_pink_gen_typeid(src_pink_Type (*type));

void src_pink_gen_expr(src_pink_Expr (*expr));

void src_pink_gen_stmt_block(src_pink_StmtList block);

void src_pink_gen_simple_stmt(src_pink_Stmt (*stmt));

bool src_pink_is_char_lit(src_pink_Expr (*expr));

void src_pink_gen_stmt(src_pink_Stmt (*stmt));

void src_pink_gen_decl(src_pink_Sym (*sym));

void src_pink_gen_sorted_decls(void);

void src_pink_gen_defs(void);

extern old_std_Map src_pink_gen_foreign_headers_map;

extern char const ((*(*src_pink_gen_foreign_headers_buf)));

void src_pink_add_foreign_header(char const ((*name)));

extern char const ((*(*src_pink_gen_foreign_sources_buf)));

void src_pink_add_foreign_source(char const ((*name)));

void src_pink_gen_include(char const ((*path)));

void src_pink_gen_foreign_headers(void);

void src_pink_gen_foreign_sources(void);

extern char const ((*(*src_pink_gen_sources_buf)));

void src_pink_put_include_path(char (path[MAX_PATH]), src_pink_Package (*package), char const ((*filename)));

extern char (*src_pink_gen_preamble_buf);

extern char (*src_pink_gen_postamble_buf);

void src_pink_preprocess_package(src_pink_Package (*package));

void src_pink_preprocess_packages(void);

void src_pink_gen_typeinfo_header(char const ((*kind)), src_pink_Type (*type));

void src_pink_gen_typeinfo_fields(src_pink_Type (*type));

void src_pink_gen_typeinfo(src_pink_Type (*type));

void src_pink_gen_typeinfos(void);

void src_pink_gen_package_external_names(void);

void src_pink_gen_preamble(void);

void src_pink_gen_postamble(void);

void src_pink_gen_all(void);

extern char const ((*src_pink_typedef_keyword));

extern char const ((*src_pink_enum_keyword));

extern char const ((*src_pink_struct_keyword));

extern char const ((*src_pink_union_keyword));

extern char const ((*src_pink_var_keyword));

extern char const ((*src_pink_const_keyword));

extern char const ((*src_pink_func_keyword));

extern char const ((*src_pink_sizeof_keyword));

extern char const ((*src_pink_alignof_keyword));

extern char const ((*src_pink_typeof_keyword));

extern char const ((*src_pink_offsetof_keyword));

extern char const ((*src_pink_break_keyword));

extern char const ((*src_pink_continue_keyword));

extern char const ((*src_pink_return_keyword));

extern char const ((*src_pink_if_keyword));

extern char const ((*src_pink_else_keyword));

extern char const ((*src_pink_while_keyword));

extern char const ((*src_pink_do_keyword));

extern char const ((*src_pink_for_keyword));

extern char const ((*src_pink_switch_keyword));

extern char const ((*src_pink_case_keyword));

extern char const ((*src_pink_default_keyword));

extern char const ((*src_pink_import_keyword));

extern char const ((*src_pink_goto_keyword));

extern char const ((*src_pink_first_keyword));

extern char const ((*src_pink_last_keyword));

extern char const ((*(*src_pink_keywords)));

extern char const ((*src_pink_always_name));

extern char const ((*src_pink_foreign_name));

extern char const ((*src_pink_complete_name));

extern char const ((*src_pink_assert_name));

extern char const ((*src_pink_declare_note_name));

extern char const ((*src_pink_static_assert_name));

char const ((*src_pink_init_keyword(char const ((*keyword)))));

extern bool src_pink_keywords_inited;

void src_pink_init_keywords(void);

bool src_pink_is_keyword_name(char const ((*name)));

#define SRC_PINK_TOKEN_EOF ((src_pink_TokenKind)(0))

#define SRC_PINK_TOKEN_COLON ((src_pink_TokenKind)((SRC_PINK_TOKEN_EOF) + (1)))

#define SRC_PINK_TOKEN_LPAREN ((src_pink_TokenKind)((SRC_PINK_TOKEN_COLON) + (1)))

#define SRC_PINK_TOKEN_RPAREN ((src_pink_TokenKind)((SRC_PINK_TOKEN_LPAREN) + (1)))

#define SRC_PINK_TOKEN_LBRACE ((src_pink_TokenKind)((SRC_PINK_TOKEN_RPAREN) + (1)))

#define SRC_PINK_TOKEN_RBRACE ((src_pink_TokenKind)((SRC_PINK_TOKEN_LBRACE) + (1)))

#define SRC_PINK_TOKEN_LBRACKET ((src_pink_TokenKind)((SRC_PINK_TOKEN_RBRACE) + (1)))

#define SRC_PINK_TOKEN_RBRACKET ((src_pink_TokenKind)((SRC_PINK_TOKEN_LBRACKET) + (1)))

#define SRC_PINK_TOKEN_COMMA ((src_pink_TokenKind)((SRC_PINK_TOKEN_RBRACKET) + (1)))

#define SRC_PINK_TOKEN_DOT ((src_pink_TokenKind)((SRC_PINK_TOKEN_COMMA) + (1)))

#define SRC_PINK_TOKEN_AT ((src_pink_TokenKind)((SRC_PINK_TOKEN_DOT) + (1)))

#define SRC_PINK_TOKEN_POUND ((src_pink_TokenKind)((SRC_PINK_TOKEN_AT) + (1)))

#define SRC_PINK_TOKEN_ELLIPSIS ((src_pink_TokenKind)((SRC_PINK_TOKEN_POUND) + (1)))

#define SRC_PINK_TOKEN_QUESTION ((src_pink_TokenKind)((SRC_PINK_TOKEN_ELLIPSIS) + (1)))

#define SRC_PINK_TOKEN_SEMICOLON ((src_pink_TokenKind)((SRC_PINK_TOKEN_QUESTION) + (1)))

#define SRC_PINK_TOKEN_KEYWORD ((src_pink_TokenKind)((SRC_PINK_TOKEN_SEMICOLON) + (1)))

#define SRC_PINK_TOKEN_INT ((src_pink_TokenKind)((SRC_PINK_TOKEN_KEYWORD) + (1)))

#define SRC_PINK_TOKEN_FLOAT ((src_pink_TokenKind)((SRC_PINK_TOKEN_INT) + (1)))

#define SRC_PINK_TOKEN_STR ((src_pink_TokenKind)((SRC_PINK_TOKEN_FLOAT) + (1)))

#define SRC_PINK_TOKEN_NAME ((src_pink_TokenKind)((SRC_PINK_TOKEN_STR) + (1)))

#define SRC_PINK_TOKEN_NEG ((src_pink_TokenKind)((SRC_PINK_TOKEN_NAME) + (1)))

#define SRC_PINK_TOKEN_NOT ((src_pink_TokenKind)((SRC_PINK_TOKEN_NEG) + (1)))

#define SRC_PINK_TOKEN_FIRST_MUL ((src_pink_TokenKind)((SRC_PINK_TOKEN_NOT) + (1)))

#define SRC_PINK_TOKEN_MUL ((src_pink_TokenKind)(SRC_PINK_TOKEN_FIRST_MUL))

#define SRC_PINK_TOKEN_DIV ((src_pink_TokenKind)((SRC_PINK_TOKEN_MUL) + (1)))

#define SRC_PINK_TOKEN_MOD ((src_pink_TokenKind)((SRC_PINK_TOKEN_DIV) + (1)))

#define SRC_PINK_TOKEN_AND ((src_pink_TokenKind)((SRC_PINK_TOKEN_MOD) + (1)))

#define SRC_PINK_TOKEN_LSHIFT ((src_pink_TokenKind)((SRC_PINK_TOKEN_AND) + (1)))

#define SRC_PINK_TOKEN_RSHIFT ((src_pink_TokenKind)((SRC_PINK_TOKEN_LSHIFT) + (1)))

#define SRC_PINK_TOKEN_LAST_MUL ((src_pink_TokenKind)(SRC_PINK_TOKEN_RSHIFT))

#define SRC_PINK_TOKEN_FIRST_ADD ((src_pink_TokenKind)((SRC_PINK_TOKEN_LAST_MUL) + (1)))

#define SRC_PINK_TOKEN_ADD ((src_pink_TokenKind)(SRC_PINK_TOKEN_FIRST_ADD))

#define SRC_PINK_TOKEN_SUB ((src_pink_TokenKind)((SRC_PINK_TOKEN_ADD) + (1)))

#define SRC_PINK_TOKEN_XOR ((src_pink_TokenKind)((SRC_PINK_TOKEN_SUB) + (1)))

#define SRC_PINK_TOKEN_OR ((src_pink_TokenKind)((SRC_PINK_TOKEN_XOR) + (1)))

#define SRC_PINK_TOKEN_LAST_ADD ((src_pink_TokenKind)(SRC_PINK_TOKEN_OR))

#define SRC_PINK_TOKEN_FIRST_CMP ((src_pink_TokenKind)((SRC_PINK_TOKEN_LAST_ADD) + (1)))

#define SRC_PINK_TOKEN_EQ ((src_pink_TokenKind)(SRC_PINK_TOKEN_FIRST_CMP))

#define SRC_PINK_TOKEN_NOTEQ ((src_pink_TokenKind)((SRC_PINK_TOKEN_EQ) + (1)))

#define SRC_PINK_TOKEN_LT ((src_pink_TokenKind)((SRC_PINK_TOKEN_NOTEQ) + (1)))

#define SRC_PINK_TOKEN_GT ((src_pink_TokenKind)((SRC_PINK_TOKEN_LT) + (1)))

#define SRC_PINK_TOKEN_LTEQ ((src_pink_TokenKind)((SRC_PINK_TOKEN_GT) + (1)))

#define SRC_PINK_TOKEN_GTEQ ((src_pink_TokenKind)((SRC_PINK_TOKEN_LTEQ) + (1)))

#define SRC_PINK_TOKEN_LAST_CMP ((src_pink_TokenKind)(SRC_PINK_TOKEN_GTEQ))

#define SRC_PINK_TOKEN_AND_AND ((src_pink_TokenKind)((SRC_PINK_TOKEN_LAST_CMP) + (1)))

#define SRC_PINK_TOKEN_OR_OR ((src_pink_TokenKind)((SRC_PINK_TOKEN_AND_AND) + (1)))

#define SRC_PINK_TOKEN_FIRST_ASSIGN ((src_pink_TokenKind)((SRC_PINK_TOKEN_OR_OR) + (1)))

#define SRC_PINK_TOKEN_ASSIGN ((src_pink_TokenKind)(SRC_PINK_TOKEN_FIRST_ASSIGN))

#define SRC_PINK_TOKEN_ADD_ASSIGN ((src_pink_TokenKind)((SRC_PINK_TOKEN_ASSIGN) + (1)))

#define SRC_PINK_TOKEN_SUB_ASSIGN ((src_pink_TokenKind)((SRC_PINK_TOKEN_ADD_ASSIGN) + (1)))

#define SRC_PINK_TOKEN_OR_ASSIGN ((src_pink_TokenKind)((SRC_PINK_TOKEN_SUB_ASSIGN) + (1)))

#define SRC_PINK_TOKEN_AND_ASSIGN ((src_pink_TokenKind)((SRC_PINK_TOKEN_OR_ASSIGN) + (1)))

#define SRC_PINK_TOKEN_XOR_ASSIGN ((src_pink_TokenKind)((SRC_PINK_TOKEN_AND_ASSIGN) + (1)))

#define SRC_PINK_TOKEN_LSHIFT_ASSIGN ((src_pink_TokenKind)((SRC_PINK_TOKEN_XOR_ASSIGN) + (1)))

#define SRC_PINK_TOKEN_RSHIFT_ASSIGN ((src_pink_TokenKind)((SRC_PINK_TOKEN_LSHIFT_ASSIGN) + (1)))

#define SRC_PINK_TOKEN_MUL_ASSIGN ((src_pink_TokenKind)((SRC_PINK_TOKEN_RSHIFT_ASSIGN) + (1)))

#define SRC_PINK_TOKEN_DIV_ASSIGN ((src_pink_TokenKind)((SRC_PINK_TOKEN_MUL_ASSIGN) + (1)))

#define SRC_PINK_TOKEN_MOD_ASSIGN ((src_pink_TokenKind)((SRC_PINK_TOKEN_DIV_ASSIGN) + (1)))

#define SRC_PINK_TOKEN_LAST_ASSIGN ((src_pink_TokenKind)(SRC_PINK_TOKEN_MOD_ASSIGN))

#define SRC_PINK_TOKEN_INC ((src_pink_TokenKind)((SRC_PINK_TOKEN_LAST_ASSIGN) + (1)))

#define SRC_PINK_TOKEN_DEC ((src_pink_TokenKind)((SRC_PINK_TOKEN_INC) + (1)))

#define SRC_PINK_TOKEN_COLON_ASSIGN ((src_pink_TokenKind)((SRC_PINK_TOKEN_DEC) + (1)))

#define SRC_PINK_NUM_TOKEN_KINDS ((src_pink_TokenKind)((SRC_PINK_TOKEN_COLON_ASSIGN) + (1)))

#define SRC_PINK_MOD_NONE ((src_pink_TokenMod)(0))

#define SRC_PINK_MOD_HEX ((src_pink_TokenMod)((SRC_PINK_MOD_NONE) + (1)))

#define SRC_PINK_MOD_BIN ((src_pink_TokenMod)((SRC_PINK_MOD_HEX) + (1)))

#define SRC_PINK_MOD_OCT ((src_pink_TokenMod)((SRC_PINK_MOD_BIN) + (1)))

#define SRC_PINK_MOD_CHAR ((src_pink_TokenMod)((SRC_PINK_MOD_OCT) + (1)))

#define SRC_PINK_MOD_MULTILINE ((src_pink_TokenMod)((SRC_PINK_MOD_CHAR) + (1)))

#define SRC_PINK_SUFFIX_NONE ((src_pink_TokenSuffix)(0))

#define SRC_PINK_SUFFIX_D ((src_pink_TokenSuffix)((SRC_PINK_SUFFIX_NONE) + (1)))

#define SRC_PINK_SUFFIX_U ((src_pink_TokenSuffix)((SRC_PINK_SUFFIX_D) + (1)))

#define SRC_PINK_SUFFIX_L ((src_pink_TokenSuffix)((SRC_PINK_SUFFIX_U) + (1)))

#define SRC_PINK_SUFFIX_UL ((src_pink_TokenSuffix)((SRC_PINK_SUFFIX_L) + (1)))

#define SRC_PINK_SUFFIX_LL ((src_pink_TokenSuffix)((SRC_PINK_SUFFIX_UL) + (1)))

#define SRC_PINK_SUFFIX_ULL ((src_pink_TokenSuffix)((SRC_PINK_SUFFIX_LL) + (1)))

extern char const ((*(src_pink_token_suffix_names[7])));

extern char const ((*(src_pink_token_kind_names[54])));

char const ((*src_pink_token_kind_name(src_pink_TokenKind kind)));

extern src_pink_TokenKind (src_pink_assign_token_to_binary_token[SRC_PINK_NUM_TOKEN_KINDS]);

extern src_pink_SrcPos src_pink_pos_builtin;

struct src_pink_Token {
    src_pink_TokenKind kind;
    src_pink_TokenMod mod;
    src_pink_TokenSuffix suffix;
    src_pink_SrcPos pos;
    char const ((*start));
    char const ((*end));
    union {
        ullong int_val;
        double float_val;
        char const ((*str_val));
        char const ((*name));
    };
};

extern src_pink_Token src_pink_token;

extern char const ((*src_pink_stream));

extern char const ((*src_pink_line_start));

void src_pink_vnotice(char const ((*level)), src_pink_SrcPos pos, char const ((*fmt)), va_list args);

void src_pink_warning(src_pink_SrcPos pos, char const ((*fmt)), ...);

void src_pink_verror(src_pink_SrcPos pos, char const ((*fmt)), va_list args);

void src_pink_error(src_pink_SrcPos pos, char const ((*fmt)), ...);

void src_pink_fatal_error(src_pink_SrcPos pos, char const ((*fmt)), ...);

char const ((*src_pink_token_info(void)));

extern uint8_t (src_pink_char_to_digit[256]);

void src_pink_scan_int(void);

void src_pink_scan_float(void);

extern char (src_pink_escape_to_char[256]);

int src_pink_scan_hex_escape(void);

void src_pink_scan_char(void);

void src_pink_scan_str(void);

void src_pink_next_token(void);

void src_pink_init_stream(char const ((*name)), char const ((*buf)));

bool src_pink_is_token(src_pink_TokenKind kind);

bool src_pink_is_token_eof(void);

bool src_pink_is_token_name(char const ((*name)));

bool src_pink_is_keyword(char const ((*name)));

bool src_pink_match_keyword(char const ((*name)));

bool src_pink_match_token(src_pink_TokenKind kind);

bool src_pink_expect_token(src_pink_TokenKind kind);

extern bool src_pink_flag_verbose;

extern bool src_pink_flag_lazy;

extern bool src_pink_flag_nosourcemap;

extern bool src_pink_flag_notypeinfo;

extern bool src_pink_flag_fullgen;

src_pink_Typespec (*src_pink_parse_type_func_param(void));

src_pink_Typespec (*src_pink_parse_type_func(void));

src_pink_Typespec (*src_pink_parse_type_base(void));

src_pink_Typespec (*src_pink_parse_type(void));

struct src_pink_CompoundField {
    src_pink_CompoundFieldKind kind;
    src_pink_SrcPos pos;
    src_pink_Expr (*init);
    union {
        char const ((*name));
        src_pink_Expr (*index);
    };
};

src_pink_CompoundField src_pink_parse_expr_compound_field(void);

src_pink_Expr (*src_pink_parse_expr_compound(src_pink_Typespec (*type)));

src_pink_Expr (*src_pink_parse_expr_operand(void));

src_pink_Expr (*src_pink_parse_expr_base(void));

bool src_pink_is_unary_op(void);

src_pink_Expr (*src_pink_parse_expr_unary(void));

bool src_pink_is_mul_op(void);

src_pink_Expr (*src_pink_parse_expr_mul(void));

bool src_pink_is_add_op(void);

src_pink_Expr (*src_pink_parse_expr_add(void));

bool src_pink_is_cmp_op(void);

src_pink_Expr (*src_pink_parse_expr_cmp(void));

src_pink_Expr (*src_pink_parse_expr_and(void));

src_pink_Expr (*src_pink_parse_expr_or(void));

src_pink_Expr (*src_pink_parse_expr_ternary(void));

src_pink_Expr (*src_pink_parse_expr(void));

src_pink_Expr (*src_pink_parse_paren_expr(void));

src_pink_StmtList src_pink_parse_stmt_block(void);

src_pink_Stmt (*src_pink_parse_stmt_if(src_pink_SrcPos pos));

src_pink_Stmt (*src_pink_parse_stmt_while(src_pink_SrcPos pos));

src_pink_Stmt (*src_pink_parse_stmt_do_while(src_pink_SrcPos pos));

bool src_pink_is_assign_op(void);

src_pink_Stmt (*src_pink_parse_init_stmt(src_pink_Expr (*left)));

src_pink_Stmt (*src_pink_parse_simple_stmt(void));

src_pink_Stmt (*src_pink_parse_stmt_for(src_pink_SrcPos pos));

struct src_pink_SwitchCasePattern {
    src_pink_Expr (*start);
    src_pink_Expr (*end);
};

src_pink_SwitchCasePattern src_pink_parse_switch_case_pattern(void);

struct src_pink_SwitchCase {
    src_pink_SwitchCasePattern (*patterns);
    size_t num_patterns;
    bool is_default;
    src_pink_StmtList block;
};

src_pink_SwitchCase src_pink_parse_stmt_switch_case(void);

src_pink_Stmt (*src_pink_parse_stmt_switch(src_pink_SrcPos pos));

src_pink_Stmt (*src_pink_parse_stmt(void));

char const ((*src_pink_parse_name(void)));

struct src_pink_EnumItem {
    src_pink_SrcPos pos;
    char const ((*name));
    src_pink_Expr (*init);
};

src_pink_EnumItem src_pink_parse_decl_enum_item(void);

src_pink_Decl (*src_pink_parse_decl_enum(src_pink_SrcPos pos));

struct src_pink_AggregateItem {
    src_pink_SrcPos pos;
    src_pink_AggregateItemKind kind;
    union {
        struct {
            char const ((*(*names)));
            size_t num_names;
            src_pink_Typespec (*type);
        };
        src_pink_Aggregate (*subaggregate);
    };
};

src_pink_AggregateItem src_pink_parse_decl_aggregate_item(void);

src_pink_Aggregate (*src_pink_parse_aggregate(src_pink_AggregateKind kind));

src_pink_Decl (*src_pink_parse_decl_aggregate(src_pink_SrcPos pos, src_pink_DeclKind kind));

src_pink_Decl (*src_pink_parse_decl_var(src_pink_SrcPos pos));

src_pink_Decl (*src_pink_parse_decl_const(src_pink_SrcPos pos));

src_pink_Decl (*src_pink_parse_decl_typedef(src_pink_SrcPos pos));

struct src_pink_FuncParam {
    src_pink_SrcPos pos;
    char const ((*name));
    src_pink_Typespec (*type);
};

src_pink_FuncParam src_pink_parse_decl_func_param(void);

src_pink_Decl (*src_pink_parse_decl_func(src_pink_SrcPos pos));

struct src_pink_NoteArg {
    src_pink_SrcPos pos;
    char const ((*name));
    src_pink_Expr (*expr);
};

src_pink_NoteArg src_pink_parse_note_arg(void);

src_pink_Note src_pink_parse_note(void);

src_pink_Notes src_pink_parse_notes(void);

src_pink_Decl (*src_pink_parse_decl_note(src_pink_SrcPos pos));

src_pink_Decl (*src_pink_parse_decl_import(src_pink_SrcPos pos));

src_pink_Decl (*src_pink_parse_decl_opt(void));

src_pink_Decl (*src_pink_parse_decl(void));

src_pink_Decls (*src_pink_parse_decls(void));

#define SRC_PINK_MAX_SEARCH_PATHS ((int)(256))

extern char const ((*(src_pink_static_package_search_paths[SRC_PINK_MAX_SEARCH_PATHS])));

extern char const ((*(*src_pink_package_search_paths)));

extern int src_pink_num_package_search_paths;

void src_pink_add_package_search_path(char const ((*path)));

void src_pink_add_package_search_path_range(char const ((*start)), char const ((*end)));

void src_pink_init_package_search_paths(void);

void src_pink_init_compiler(void);

void src_pink_parse_env_vars(void);

int src_pink_pink_entry(int argc, char const ((*(*argv))), void (*gen_all)(void), char const ((*extension)));

typedef int src_pink_SymKind;

#define SRC_PINK_SYM_NONE ((src_pink_SymKind)(0))

#define SRC_PINK_SYM_VAR ((src_pink_SymKind)((SRC_PINK_SYM_NONE) + (1)))

#define SRC_PINK_SYM_CONST ((src_pink_SymKind)((SRC_PINK_SYM_VAR) + (1)))

#define SRC_PINK_SYM_FUNC ((src_pink_SymKind)((SRC_PINK_SYM_CONST) + (1)))

#define SRC_PINK_SYM_TYPE ((src_pink_SymKind)((SRC_PINK_SYM_FUNC) + (1)))

#define SRC_PINK_SYM_PACKAGE ((src_pink_SymKind)((SRC_PINK_SYM_TYPE) + (1)))

typedef int src_pink_SymState;

#define SRC_PINK_SYM_UNRESOLVED ((src_pink_SymState)(0))

#define SRC_PINK_SYM_RESOLVING ((src_pink_SymState)((SRC_PINK_SYM_UNRESOLVED) + (1)))

#define SRC_PINK_SYM_RESOLVED ((src_pink_SymState)((SRC_PINK_SYM_RESOLVING) + (1)))

#define SRC_PINK_MAX_LOCAL_SYMS ((int)(1024))

extern src_pink_Package (*src_pink_current_package);

extern src_pink_Package (*src_pink_builtin_package);

extern old_std_Map src_pink_package_map;

extern src_pink_Package (*(*src_pink_package_list));

#define SRC_PINK_REACHABLE_NONE ((int)(0))

#define SRC_PINK_REACHABLE_NATURAL ((int)((SRC_PINK_REACHABLE_NONE) + (1)))

#define SRC_PINK_REACHABLE_FORCED ((int)((SRC_PINK_REACHABLE_NATURAL) + (1)))

extern uint8_t src_pink_reachable_phase;

src_pink_Sym (*src_pink_get_package_sym(src_pink_Package (*package), char const ((*name))));

void src_pink_add_package(src_pink_Package (*package));

src_pink_Package (*src_pink_enter_package(src_pink_Package (*new_package)));

void src_pink_leave_package(src_pink_Package (*old_package));

extern src_pink_Sym (*(*src_pink_reachable_syms));

extern src_pink_Sym (*(*src_pink_sorted_syms));

union old_std_Val {
    bool b;
    char c;
    uchar uc;
    schar sc;
    short s;
    ushort us;
    int i;
    uint u;
    long l;
    ulong ul;
    llong ll;
    ullong ull;
    uintptr_t p;
};

struct src_pink_Sym {
    char const ((*name));
    src_pink_Package (*home_package);
    src_pink_SymKind kind;
    src_pink_SymState state;
    uint8_t reachable;
    src_pink_Decl (*decl);
    char const ((*external_name));
    union {
        struct {
            src_pink_Type (*type);
            old_std_Val val;
        };
        src_pink_Package (*package);
    };
};

extern src_pink_Sym (src_pink_local_syms[SRC_PINK_MAX_LOCAL_SYMS]);

extern src_pink_Sym (*src_pink_local_syms_end);

bool src_pink_is_local_sym(src_pink_Sym (*sym));

src_pink_Sym (*src_pink_sym_new(src_pink_SymKind kind, char const ((*name)), src_pink_Decl (*decl)));

void src_pink_process_decl_notes(src_pink_Decl (*decl), src_pink_Sym (*sym));

src_pink_Sym (*src_pink_sym_decl(src_pink_Decl (*decl)));

src_pink_Sym (*src_pink_sym_get_local(char const ((*name))));

src_pink_Sym (*src_pink_sym_get(char const ((*name))));

bool src_pink_sym_push_var(char const ((*name)), src_pink_Type (*type));

src_pink_Sym (*src_pink_sym_enter(void));

void src_pink_sym_leave(src_pink_Sym (*sym));

void src_pink_sym_global_put(char const ((*name)), src_pink_Sym (*sym));

src_pink_Sym (*src_pink_sym_global_type(char const ((*name)), src_pink_Type (*type)));

src_pink_Sym (*src_pink_sym_global_decl(src_pink_Decl (*decl)));

void src_pink_put_type_name(char (*(*buf)), src_pink_Type (*type));

char (*src_pink_get_type_name(src_pink_Type (*type)));

struct src_pink_Operand {
    src_pink_Type (*type);
    bool is_lvalue;
    bool is_const;
    old_std_Val val;
};

extern src_pink_Operand src_pink_operand_null;

src_pink_Operand src_pink_operand_rvalue(src_pink_Type (*type));

src_pink_Operand src_pink_operand_lvalue(src_pink_Type (*type));

src_pink_Operand src_pink_operand_const(src_pink_Type (*type), old_std_Val val);

src_pink_Type (*src_pink_type_decay(src_pink_Type (*type)));

src_pink_Operand src_pink_operand_decay(src_pink_Operand operand);

bool src_pink_is_convertible(src_pink_Operand (*operand), src_pink_Type (*dest));

bool src_pink_is_castable(src_pink_Operand (*operand), src_pink_Type (*dest));

bool src_pink_convert_operand(src_pink_Operand (*operand), src_pink_Type (*type));

bool src_pink_is_null_ptr(src_pink_Operand operand);

void src_pink_promote_operand(src_pink_Operand (*operand));

void src_pink_unify_arithmetic_operands(src_pink_Operand (*left), src_pink_Operand (*right));

extern old_std_Map src_pink_resolved_val_map;

old_std_Val src_pink_get_resolved_val(void (*ptr));

void src_pink_set_resolved_val(void (*ptr), old_std_Val val);

extern old_std_Map src_pink_resolved_type_map;

src_pink_Type (*src_pink_get_resolved_type(void (*ptr)));

void src_pink_set_resolved_type(void (*ptr), src_pink_Type (*type));

extern old_std_Map src_pink_resolved_sym_map;

src_pink_Sym (*src_pink_get_resolved_sym(void const ((*ptr))));

void src_pink_set_resolved_sym(void const ((*ptr)), src_pink_Sym (*sym));

extern old_std_Map src_pink_resolved_expected_type_map;

src_pink_Type (*src_pink_get_resolved_expected_type(src_pink_Expr (*expr)));

void src_pink_set_resolved_expected_type(src_pink_Expr (*expr), src_pink_Type (*type));

src_pink_Operand src_pink_resolve_expr(src_pink_Expr (*expr));

src_pink_Operand src_pink_resolve_expr_rvalue(src_pink_Expr (*expr));

src_pink_Operand src_pink_resolve_expected_expr_rvalue(src_pink_Expr (*expr), src_pink_Type (*expected_type));

src_pink_Type (*src_pink_resolve_typespec(src_pink_Typespec (*typespec)));

src_pink_Type (*src_pink_complete_aggregate(src_pink_Type (*type), src_pink_Aggregate (*aggregate)));

void src_pink_complete_type(src_pink_Type (*type));

src_pink_Type (*src_pink_resolve_typed_init(src_pink_SrcPos pos, src_pink_Type (*type), src_pink_Expr (*expr)));

src_pink_Type (*src_pink_resolve_init(src_pink_SrcPos pos, src_pink_Typespec (*typespec), src_pink_Expr (*expr)));

src_pink_Type (*src_pink_resolve_decl_var(src_pink_Decl (*decl)));

src_pink_Type (*src_pink_resolve_decl_const(src_pink_Decl (*decl), old_std_Val (*val)));

src_pink_Type (*src_pink_resolve_decl_func(src_pink_Decl (*decl)));

#define SRC_PINK_MAX_LABELS (256)

struct src_pink_Label {
    char const ((*name));
    src_pink_SrcPos pos;
    bool referenced;
    bool defined;
};

extern src_pink_Label (src_pink_labels[SRC_PINK_MAX_LABELS]);

extern src_pink_Label (*src_pink_labels_end);

src_pink_Label (*src_pink_get_label(src_pink_SrcPos pos, char const ((*name))));

void src_pink_reference_label(src_pink_SrcPos pos, char const ((*name)));

void src_pink_define_label(src_pink_SrcPos pos, char const ((*name)));

void src_pink_resolve_labels(void);

bool src_pink_is_cond_operand(src_pink_Operand operand);

void src_pink_resolve_cond_expr(src_pink_Expr (*expr));

struct src_pink_StmtCtx {
    bool is_break_legal;
    bool is_continue_legal;
};

bool src_pink_resolve_stmt_block(src_pink_StmtList block, src_pink_Type (*ret_type), src_pink_StmtCtx ctx);

void src_pink_resolve_stmt_assign(src_pink_Stmt (*stmt));

void src_pink_resolve_stmt_init(src_pink_Stmt (*stmt));

void src_pink_resolve_static_assert(src_pink_Note note);

bool src_pink_resolve_stmt(src_pink_Stmt (*stmt), src_pink_Type (*ret_type), src_pink_StmtCtx ctx);

void src_pink_resolve_func_body(src_pink_Sym (*sym));

void src_pink_resolve_sym(src_pink_Sym (*sym));

void src_pink_finalize_sym(src_pink_Sym (*sym));

src_pink_Sym (*src_pink_resolve_name(char const ((*name))));

src_pink_Package (*src_pink_try_resolve_package(src_pink_Expr (*expr)));

src_pink_Operand src_pink_resolve_expr_field(src_pink_Expr (*expr));

llong src_pink_eval_unary_op_ll(src_pink_TokenKind op, llong val);

ullong src_pink_eval_unary_op_ull(src_pink_TokenKind op, ullong val);

llong src_pink_eval_binary_op_ll(src_pink_TokenKind op, llong left, llong right);

ullong src_pink_eval_binary_op_ull(src_pink_TokenKind op, ullong left, ullong right);

old_std_Val src_pink_eval_unary_op(src_pink_TokenKind op, src_pink_Type (*type), old_std_Val val);

old_std_Val src_pink_eval_binary_op(src_pink_TokenKind op, src_pink_Type (*type), old_std_Val left, old_std_Val right);

src_pink_Operand src_pink_resolve_name_operand(src_pink_SrcPos pos, char const ((*name)));

src_pink_Operand src_pink_resolve_expr_name(src_pink_Expr (*expr));

src_pink_Operand src_pink_resolve_unary_op(src_pink_TokenKind op, src_pink_Operand operand);

src_pink_Operand src_pink_resolve_expr_unary(src_pink_Expr (*expr));

src_pink_Operand src_pink_resolve_binary_op(src_pink_TokenKind op, src_pink_Operand left, src_pink_Operand right);

src_pink_Operand src_pink_resolve_binary_arithmetic_op(src_pink_TokenKind op, src_pink_Operand left, src_pink_Operand right);

src_pink_Operand src_pink_resolve_expr_binary_op(src_pink_TokenKind op, char const ((*op_name)), src_pink_SrcPos pos, src_pink_Operand left, src_pink_Operand right);

src_pink_Operand src_pink_resolve_expr_binary(src_pink_Expr (*expr));

src_pink_Operand src_pink_resolve_expr_compound(src_pink_Expr (*expr), src_pink_Type (*expected_type));

src_pink_Operand src_pink_resolve_expr_call(src_pink_Expr (*expr));

src_pink_Operand src_pink_resolve_expr_ternary(src_pink_Expr (*expr), src_pink_Type (*expected_type));

src_pink_Operand src_pink_resolve_expr_index(src_pink_Expr (*expr));

src_pink_Operand src_pink_resolve_expr_cast(src_pink_Expr (*expr));

src_pink_Operand src_pink_resolve_expr_int(src_pink_Expr (*expr));

src_pink_Operand src_pink_resolve_expr_modify(src_pink_Expr (*expr));

src_pink_Operand src_pink_resolve_expected_expr(src_pink_Expr (*expr), src_pink_Type (*expected_type));

src_pink_Operand src_pink_resolve_const_expr(src_pink_Expr (*expr));

extern old_std_Map src_pink_decl_note_names;

void src_pink_init_builtin_syms(void);

void src_pink_add_package_decls(src_pink_Package (*package));

bool src_pink_is_package_dir(char const ((*search_path)), char const ((*package_path)));

bool src_pink_copy_package_full_path(char (dest[MAX_PATH]), char const ((*package_path)));

src_pink_Package (*src_pink_import_package(char const ((*package_path))));

void src_pink_import_all_package_symbols(src_pink_Package (*package));

void src_pink_import_package_symbols(src_pink_Decl (*decl), src_pink_Package (*package));

void src_pink_process_package_imports(src_pink_Package (*package));

bool src_pink_parse_package(src_pink_Package (*package));

bool src_pink_compile_package(src_pink_Package (*package));

void src_pink_resolve_package_syms(src_pink_Package (*package));

void src_pink_finalize_reachable_syms(void);

typedef int src_pink_Os;

#define SRC_PINK_OS_WINDOWS ((src_pink_Os)(0))

#define SRC_PINK_NUM_OSES ((src_pink_Os)((SRC_PINK_OS_WINDOWS) + (1)))

extern char const ((*(src_pink_os_names[SRC_PINK_NUM_OSES])));

typedef int src_pink_Arch;

#define SRC_PINK_ARCH_X64 ((src_pink_Arch)(0))

#define SRC_PINK_ARCH_X86 ((src_pink_Arch)((SRC_PINK_ARCH_X64) + (1)))

#define SRC_PINK_NUM_ARCHES ((src_pink_Arch)((SRC_PINK_ARCH_X86) + (1)))

extern char const ((*(src_pink_arch_names[SRC_PINK_NUM_ARCHES])));

extern int src_pink_target_os;

extern int src_pink_target_arch;

int src_pink_get_os(char const ((*name)));

int src_pink_get_arch(char const ((*name)));

struct src_pink_TypeMetrics {
    size_t size;
    size_t align;
    bool sign;
    ullong max;
};

void src_pink_init_default_type_metrics(src_pink_TypeMetrics (metrics[SRC_PINK_NUM_CMPL_TYPE_KINDS]));

extern src_pink_TypeMetrics (src_pink_win32_x86_metrics[SRC_PINK_NUM_CMPL_TYPE_KINDS]);

extern src_pink_TypeMetrics (src_pink_win32_x64_metrics[SRC_PINK_NUM_CMPL_TYPE_KINDS]);

extern src_pink_TypeMetrics (src_pink_ilp32_metrics[SRC_PINK_NUM_CMPL_TYPE_KINDS]);

extern src_pink_TypeMetrics (src_pink_lp64_metrics[SRC_PINK_NUM_CMPL_TYPE_KINDS]);

void src_pink_init_target(void);

bool src_pink_is_excluded_target_filename(char const ((*name)));

extern src_pink_TypeMetrics (*src_pink_type_metrics);

struct src_pink_TypeAggregate {
    src_pink_TypeField (*fields);
    size_t num_fields;
};

struct src_pink_TypeFunc {
    src_pink_Type (*(*params));
    size_t num_params;
    bool has_varargs;
    src_pink_Type (*ret);
};

struct src_pink_Type {
    src_pink_CompilerTypeKind kind;
    size_t size;
    size_t align;
    src_pink_Sym (*sym);
    src_pink_Type (*base);
    int typeid;
    bool nonmodifiable;
    union {
        size_t num_elems;
        src_pink_TypeAggregate aggregate;
        src_pink_TypeFunc function;
    };
};

extern src_pink_Type (*src_pink_type_void);

extern src_pink_Type (*src_pink_type_bool);

extern src_pink_Type (*src_pink_type_char);

extern src_pink_Type (*src_pink_type_uchar);

extern src_pink_Type (*src_pink_type_schar);

extern src_pink_Type (*src_pink_type_short);

extern src_pink_Type (*src_pink_type_ushort);

extern src_pink_Type (*src_pink_type_int);

extern src_pink_Type (*src_pink_type_uint);

extern src_pink_Type (*src_pink_type_long);

extern src_pink_Type (*src_pink_type_ulong);

extern src_pink_Type (*src_pink_type_llong);

extern src_pink_Type (*src_pink_type_ullong);

extern src_pink_Type (*src_pink_type_float);

extern src_pink_Type (*src_pink_type_double);

extern int src_pink_next_typeid;

extern src_pink_Type (*src_pink_type_uintptr);

extern src_pink_Type (*src_pink_type_usize);

extern src_pink_Type (*src_pink_type_ssize);

extern old_std_Map src_pink_typeid_map;

src_pink_Type (*src_pink_get_type_from_typeid(int typeid));

void src_pink_register_typeid(src_pink_Type (*type));

src_pink_Type (*src_pink_type_alloc(TypeKind kind));

bool src_pink_is_ptr_type(src_pink_Type (*type));

bool src_pink_is_func_type(src_pink_Type (*type));

bool src_pink_is_ptr_like_type(src_pink_Type (*type));

bool src_pink_is_const_type(src_pink_Type (*type));

bool src_pink_is_array_type(src_pink_Type (*type));

bool src_pink_is_incomplete_array_type(src_pink_Type (*type));

bool src_pink_is_integer_type(src_pink_Type (*type));

bool src_pink_is_floating_type(src_pink_Type (*type));

bool src_pink_is_arithmetic_type(src_pink_Type (*type));

bool src_pink_is_scalar_type(src_pink_Type (*type));

bool src_pink_is_aggregate_type(src_pink_Type (*type));

bool src_pink_is_signed_type(src_pink_Type (*type));

extern char const ((*(src_pink_type_names[SRC_PINK_NUM_CMPL_TYPE_KINDS])));

extern int (src_pink_type_ranks[SRC_PINK_NUM_CMPL_TYPE_KINDS]);

int src_pink_type_rank(src_pink_Type (*type));

src_pink_Type (*src_pink_unsigned_type(src_pink_Type (*type)));

size_t src_pink_type_sizeof(src_pink_Type (*type));

size_t src_pink_type_alignof(src_pink_Type (*type));

extern old_std_Map src_pink_cached_ptr_types;

src_pink_Type (*src_pink_type_ptr(src_pink_Type (*base)));

extern old_std_Map src_pink_cached_const_types;

src_pink_Type (*src_pink_type_const(src_pink_Type (*base)));

src_pink_Type (*src_pink_unqualify_type(src_pink_Type (*type)));

extern old_std_Map src_pink_cached_array_types;

src_pink_Type (*src_pink_type_array(src_pink_Type (*base), size_t num_elems));

extern old_std_Map src_pink_cached_func_types;

src_pink_Type (*src_pink_type_func(src_pink_Type (*(*params)), size_t num_params, src_pink_Type (*ret), bool has_varargs));

bool src_pink_has_duplicate_fields(src_pink_Type (*type));

void src_pink_add_type_fields(src_pink_TypeField (*(*fields)), src_pink_Type (*type), size_t offset);

void src_pink_type_complete_struct(src_pink_Type (*type), src_pink_TypeField (*fields), size_t num_fields);

void src_pink_type_complete_union(src_pink_Type (*type), src_pink_TypeField (*fields), size_t num_fields);

src_pink_Type (*src_pink_type_incomplete(src_pink_Sym (*sym)));

src_pink_Type (*src_pink_type_enum(src_pink_Sym (*sym), src_pink_Type (*base)));

void src_pink_init_builtin_type(src_pink_Type (*type));

void src_pink_init_builtin_types(void);

int src_pink_aggregate_item_field_index(src_pink_Type (*type), char const ((*name)));

src_pink_Type (*src_pink_aggregate_item_field_type_from_index(src_pink_Type (*type), int index));

src_pink_Type (*src_pink_aggregate_item_field_type_from_name(src_pink_Type (*type), char const ((*name))));




struct TypeFieldInfo {
    char const ((*name));
    typeid type;
    int offset;
};

struct Any {
    void (*ptr);
    typeid type;
};

void (*old_std_arena_alloc(old_std_Arena (*arena), size_t size));

struct src_pink_StmtIf {
    src_pink_Stmt (*init);
    src_pink_Expr (*cond);
    src_pink_StmtList then_block;
    src_pink_ElseIf (*elseifs);
    size_t num_elseifs;
    src_pink_StmtList else_block;
};

struct src_pink_StmtWhile {
    src_pink_Expr (*cond);
    src_pink_StmtList block;
};

struct src_pink_StmtFor {
    src_pink_Stmt (*init);
    src_pink_Expr (*cond);
    src_pink_Stmt (*next);
    src_pink_StmtList block;
};

struct src_pink_StmtSwitch {
    src_pink_Expr (*expr);
    src_pink_SwitchCase (*cases);
    size_t num_cases;
};

struct src_pink_StmtAssign {
    src_pink_TokenKind op;
    src_pink_Expr (*left);
    src_pink_Expr (*right);
};

struct src_pink_StmtInit {
    char const ((*name));
    src_pink_Typespec (*type);
    src_pink_Expr (*expr);
};

struct src_pink_Stmt {
    src_pink_StmtKind kind;
    src_pink_Notes notes;
    src_pink_SrcPos pos;
    union {
        src_pink_Note note;
        src_pink_Expr (*expr);
        src_pink_Decl (*decl);
        src_pink_StmtIf if_stmt;
        src_pink_StmtWhile while_stmt;
        src_pink_StmtFor for_stmt;
        src_pink_StmtSwitch switch_stmt;
        src_pink_StmtList block;
        src_pink_StmtAssign assign;
        src_pink_StmtInit init;
        char const ((*label));
    };
};

struct src_pink_TypespecFunc {
    src_pink_Typespec (*(*args));
    size_t num_args;
    bool has_varargs;
    src_pink_Typespec (*ret);
};

struct src_pink_Typespec {
    src_pink_TypespecKind kind;
    src_pink_SrcPos pos;
    src_pink_Typespec (*base);
    union {
        char const ((*name));
        src_pink_TypespecFunc function;
        src_pink_Expr (*num_elems);
    };
};

struct src_pink_ExprParen {
    src_pink_Expr (*expr);
};

struct src_pink_ExprIntLit {
    ullong val;
    src_pink_TokenMod mod;
    src_pink_TokenSuffix suffix;
};

struct src_pink_ExprFloatLit {
    char const ((*start));
    char const ((*end));
    double val;
    src_pink_TokenSuffix suffix;
};

struct src_pink_ExprStrLit {
    char const ((*val));
    src_pink_TokenMod mod;
};

struct src_pink_ExprOffsetofField {
    src_pink_Typespec (*type);
    char const ((*name));
};

struct src_pink_ExprCompound {
    src_pink_Typespec (*type);
    src_pink_CompoundField (*fields);
    size_t num_fields;
};

struct src_pink_ExprCast {
    src_pink_Typespec (*type);
    src_pink_Expr (*expr);
};

struct src_pink_ExprModify {
    src_pink_TokenKind op;
    bool post;
    src_pink_Expr (*expr);
};

struct src_pink_ExprUnary {
    src_pink_TokenKind op;
    src_pink_Expr (*expr);
};

struct src_pink_ExprBinary {
    src_pink_TokenKind op;
    src_pink_Expr (*left);
    src_pink_Expr (*right);
};

struct src_pink_ExprTernary {
    src_pink_Expr (*cond);
    src_pink_Expr (*then_expr);
    src_pink_Expr (*else_expr);
};

struct src_pink_ExprCall {
    src_pink_Expr (*expr);
    src_pink_Expr (*(*args));
    size_t num_args;
};

struct src_pink_ExprIndex {
    src_pink_Expr (*expr);
    src_pink_Expr (*index);
};

struct src_pink_ExprField {
    src_pink_Expr (*expr);
    char const ((*name));
};

struct src_pink_Expr {
    src_pink_ExprKind kind;
    src_pink_SrcPos pos;
    union {
        src_pink_ExprParen paren;
        src_pink_ExprIntLit int_lit;
        src_pink_ExprFloatLit float_lit;
        src_pink_ExprStrLit str_lit;
        char const ((*name));
        src_pink_Expr (*sizeof_expr);
        src_pink_Typespec (*sizeof_type);
        src_pink_Expr (*typeof_expr);
        src_pink_Typespec (*typeof_type);
        src_pink_Expr (*alignof_expr);
        src_pink_Typespec (*alignof_type);
        src_pink_ExprOffsetofField offsetof_field;
        src_pink_ExprCompound compound;
        src_pink_ExprCast cast;
        src_pink_ExprModify modify;
        src_pink_ExprUnary unary;
        src_pink_ExprBinary binary;
        src_pink_ExprTernary ternary;
        src_pink_ExprCall call;
        src_pink_ExprIndex index;
        src_pink_ExprField field;
    };
};

struct src_pink_Decls {
    src_pink_Decl (*(*decls));
    size_t num_decls;
};

struct src_pink_DeclEnum {
    src_pink_Typespec (*type);
    src_pink_EnumItem (*items);
    size_t num_items;
};

struct src_pink_DeclFunc {
    src_pink_FuncParam (*params);
    size_t num_params;
    src_pink_Typespec (*ret_type);
    bool has_varargs;
    src_pink_StmtList block;
};

struct src_pink_DeclTypedef {
    src_pink_Typespec (*type);
};

struct src_pink_DeclVar {
    src_pink_Typespec (*type);
    src_pink_Expr (*expr);
};

struct src_pink_DeclImport {
    bool is_relative;
    char const ((*(*names)));
    size_t num_names;
    bool import_all;
    src_pink_ImportItem (*items);
    size_t num_items;
};

struct src_pink_Decl {
    src_pink_DeclKind kind;
    src_pink_SrcPos pos;
    char const ((*name));
    src_pink_Notes notes;
    bool is_incomplete;
    union {
        src_pink_Note note;
        src_pink_DeclEnum enum_decl;
        src_pink_Aggregate (*aggregate);
        src_pink_DeclFunc function;
        src_pink_DeclTypedef typedef_decl;
        src_pink_DeclVar var_decl;
        src_pink_DeclVar const_decl;
        src_pink_DeclImport import_decl;
    };
};

struct src_pink_Aggregate {
    src_pink_SrcPos pos;
    src_pink_AggregateKind kind;
    src_pink_AggregateItem (*items);
    size_t num_items;
};

struct src_pink_ImportItem {
    char const ((*name));
    char const ((*rename));
};

struct src_pink_ElseIf {
    src_pink_Expr (*cond);
    src_pink_StmtList block;
};

void old_std_buf_printf(char (*(*buf)), char const ((*fmt)), ...);

char (*old_std_strf(char const ((*fmt)), ...));

void (*old_std_map_get(old_std_Map (*map), void const ((*key))));

struct src_pink_Package {
    char const ((*path));
    char (full_path[MAX_PATH]);
    src_pink_Decl (*(*decls));
    size_t num_decls;
    old_std_Map syms_map;
    src_pink_Sym (*(*syms));
    char const ((*external_name));
    bool always_reachable;
};

void old_std_map_put(old_std_Map (*map), void const ((*key)), void (*val));

void (*old_std_buf_end(void (*b), size_t elem_size));

size_t old_std_buf_len(void (*b));

char const ((*old_std_str_intern(char const ((*str)))));

void old_std_buf_push(void (*(*b)), void (*elem), size_t elem_size);

void old_std_os_path_copy(char (path[MAX_PATH]), char const ((*src)));

void old_std_os_path_join(char (path[MAX_PATH]), char const ((*src)));

void old_std_os_path_absolute(char (path[MAX_PATH]));

struct src_pink_TypeField {
    char const ((*name));
    src_pink_Type (*type);
    size_t offset;
};

extern old_std_Arena old_std_intern_arena;

char const ((*old_std_str_intern_range(char const ((*start)), char const ((*end)))));

size_t old_std_clamp_max(size_t x, size_t max);

void old_std_os_add_flag_str(char const ((*name)), char const ((*(*ptr))), char const ((*arg_name)), char const ((*help)));

void old_std_os_add_flag_enum(char const ((*name)), int (*ptr), char const ((*help)), char const ((*(*options))), int num_options);

void old_std_os_add_flag_bool(char const ((*name)), bool (*ptr), char const ((*help)));

char const ((*old_std_os_parse_flags(int (*argc_ptr), char const ((*(*(*argv_ptr)))))));

void old_std_os_print_flags_usage(void);

bool old_std_write_file(char const ((*path)), char const ((*buf)), size_t len);

void (*old_std_xcalloc(size_t num_elems, size_t elem_size));

void old_std_fatal(char const ((*fmt)), ...);

uint64_t old_std_map_get_uint64(old_std_Map (*map), void (*key));

void old_std_map_put_uint64(old_std_Map (*map), void (*key), uint64_t val);

size_t old_std_max(size_t x, size_t y);

struct old_std_os_DirListIter {
    bool valid;
    bool error;
    char (base[MAX_PATH]);
    char (name[MAX_PATH]);
    size_t size;
    bool is_dir;
    void (*handle);
};

void old_std_os_dir_list(old_std_os_DirListIter (*iter), char const ((*path)));

void old_std_os_dir_list_next(old_std_os_DirListIter (*iter));

char (*old_std_os_path_ext(char (path[MAX_PATH])));

void old_std_os_dir_list_free(old_std_os_DirListIter (*iter));

bool old_std_str_islower(char const ((*str)));

void old_std_buf_free(void (*(*b)));

char (*old_std_read_file(char const ((*path))));

struct src_pink_CachedArrayType {
    src_pink_Type (*type);
    src_pink_CachedArrayType (*next);
};

uint64_t old_std_hash_mix(uint64_t x, uint64_t y);

uint64_t old_std_hash_ptr(void const ((*ptr)));

uint64_t old_std_hash_uint64(uint64_t x);

void (*old_std_map_get_from_uint64(old_std_Map (*map), uint64_t key));

void (*old_std_xmalloc(size_t num_bytes));

void old_std_map_put_from_uint64(old_std_Map (*map), uint64_t key, void (*val));

struct src_pink_CachedFuncType {
    src_pink_Type (*type);
    src_pink_CachedFuncType (*next);
};

uint64_t old_std_hash_bytes(void const ((*ptr)), size_t len);

void (*old_std_memdup(void (*src), size_t size));

uintptr_t old_std_align_up(uintptr_t n, size_t a);

void old_std_arena_grow(old_std_Arena (*arena), size_t min_size);

void (*old_std_align_up_ptr(void (*p), size_t a));

#define OLD_STD_ARENA_ALIGNMENT (8)

size_t old_std_buf_cap(void const ((*b)));

void old_std_buf_fit(void (*(*b)), size_t new_len, size_t elem_size);

old_std_BufHdr (*old_std_buf__hdr(void (*b)));

struct old_std_BufHdr {
    size_t len;
    size_t cap;
    char (buf[1]);
};

uint64_t old_std_map_get_uint64_from_uint64(old_std_Map (*map), uint64_t key);

void old_std_map_put_uint64_from_uint64(old_std_Map (*map), uint64_t key, uint64_t val);

void old_std_os_path_normalize(char (*path));

extern old_std_Map old_std_interns;

struct old_std_Intern {
    size_t len;
    old_std_Intern (*next);
    char (str[1]);
};

size_t old_std_min(size_t x, size_t y);

typedef int old_std_os_FlagKind;

struct old_std_os_FlagDefPtr {
    int (*i);
    bool (*b);
    char const ((*(*s)));
};

struct old_std_os_FlagDef {
    old_std_os_FlagKind kind;
    char const ((*name));
    char const ((*help));
    char const ((*(*options)));
    char const ((*arg_name));
    int num_options;
    old_std_os_FlagDefPtr ptr;
};

#define OLD_STD_OS_FLAG_BOOL ((old_std_os_FlagKind)(0))

#define OLD_STD_OS_FLAG_STR ((old_std_os_FlagKind)((OLD_STD_OS_FLAG_BOOL) + (1)))

extern old_std_os_FlagDef (*old_std_os_flag_defs);

#define OLD_STD_OS_FLAG_ENUM ((old_std_os_FlagKind)((OLD_STD_OS_FLAG_STR) + (1)))

old_std_os_FlagDef (*old_std_os_get_flag_def(char const ((*name))));

char (*old_std_os_path_file(char (path[MAX_PATH])));

void old_std_os_dir__update(old_std_os_DirListIter (*iter), bool done, FindData (*fileinfo));

bool old_std_os_dir_excluded(old_std_os_DirListIter (*iter));

uintptr_t old_std_align_down(uintptr_t n, size_t a);

size_t old_std_clamp_min(size_t x, size_t min);

#define OLD_STD_ARENA_BLOCK_SIZE ((1024) * (1024))

void (*old_std_buf__grow(void const ((*buf)), size_t new_len, size_t elem_size));

void old_std_map_grow(old_std_Map (*map), size_t new_cap);

void (*old_std_xrealloc(void (*ptr), size_t num_bytes));

// Typeinfo
#define TYPEID0(index, kind) ((ullong)(index) | ((ullong)(kind) << 24))
#define TYPEID(index, kind, ...) ((ullong)(index) | ((ullong)sizeof(__VA_ARGS__) << 32) | ((ullong)(kind) << 24))

const TypeInfo *typeinfo_table[646] = {
    [0] = NULL, // No associated type
    [1] = &(TypeInfo){TYPE_VOID, .name = "void", .size = 0, .align = 0},
    [2] = &(TypeInfo){TYPE_BOOL, .size = sizeof(bool), .align = sizeof(bool), .name = "bool"},
    [3] = &(TypeInfo){TYPE_CHAR, .size = sizeof(char), .align = sizeof(char), .name = "char"},
    [4] = &(TypeInfo){TYPE_UCHAR, .size = sizeof(uchar), .align = sizeof(uchar), .name = "uchar"},
    [5] = &(TypeInfo){TYPE_SCHAR, .size = sizeof(schar), .align = sizeof(schar), .name = "schar"},
    [6] = &(TypeInfo){TYPE_SHORT, .size = sizeof(short), .align = sizeof(short), .name = "short"},
    [7] = &(TypeInfo){TYPE_USHORT, .size = sizeof(ushort), .align = sizeof(ushort), .name = "ushort"},
    [8] = &(TypeInfo){TYPE_INT, .size = sizeof(int), .align = sizeof(int), .name = "int"},
    [9] = &(TypeInfo){TYPE_UINT, .size = sizeof(uint), .align = sizeof(uint), .name = "uint"},
    [10] = &(TypeInfo){TYPE_LONG, .size = sizeof(long), .align = sizeof(long), .name = "long"},
    [11] = &(TypeInfo){TYPE_ULONG, .size = sizeof(ulong), .align = sizeof(ulong), .name = "ulong"},
    [12] = &(TypeInfo){TYPE_LLONG, .size = sizeof(llong), .align = sizeof(llong), .name = "llong"},
    [13] = &(TypeInfo){TYPE_ULLONG, .size = sizeof(ullong), .align = sizeof(ullong), .name = "ullong"},
    [14] = &(TypeInfo){TYPE_FLOAT, .size = sizeof(float), .align = sizeof(float), .name = "float"},
    [15] = &(TypeInfo){TYPE_DOUBLE, .size = sizeof(double), .align = sizeof(double), .name = "double"},
    [16] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID0(1, TYPE_VOID)},
    [17] = &(TypeInfo){TYPE_CONST, .size = sizeof(char const ), .align = alignof(char const ), .base = TYPEID(3, TYPE_CHAR, char)},
    [18] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(17, TYPE_CONST, char const )},
    [19] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(18, TYPE_PTR, char const (*))},
    [20] = NULL, // Func
    [21] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [8]), .align = alignof(char [8]), .base = TYPEID(3, TYPE_CHAR, char), .count = 8},
    [22] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(3, TYPE_CHAR, char)},
    [23] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [4]), .align = alignof(char [4]), .base = TYPEID(3, TYPE_CHAR, char), .count = 4},
    [24] = NULL, // Enum
    [25] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(TypeFieldInfo), .align = alignof(TypeFieldInfo), .name = "TypeFieldInfo", .num_fields = 3, .fields = (TypeFieldInfo[]) {
        {"name", .type = TYPEID(18, TYPE_PTR, char const (*)), .offset = offsetof(TypeFieldInfo, name)},
        {"type", .type = TYPEID(13, TYPE_ULLONG, ullong), .offset = offsetof(TypeFieldInfo, type)},
        {"offset", .type = TYPEID(8, TYPE_INT, int), .offset = offsetof(TypeFieldInfo, offset)},
    }},
    [26] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(TypeInfo), .align = alignof(TypeInfo), .name = "TypeInfo", .num_fields = 8, .fields = (TypeFieldInfo[]) {
        {"kind", .type = TYPEID(24, TYPE_NONE, TypeKind), .offset = offsetof(TypeInfo, kind)},
        {"size", .type = TYPEID(8, TYPE_INT, int), .offset = offsetof(TypeInfo, size)},
        {"align", .type = TYPEID(8, TYPE_INT, int), .offset = offsetof(TypeInfo, align)},
        {"name", .type = TYPEID(18, TYPE_PTR, char const (*)), .offset = offsetof(TypeInfo, name)},
        {"count", .type = TYPEID(8, TYPE_INT, int), .offset = offsetof(TypeInfo, count)},
        {"base", .type = TYPEID(13, TYPE_ULLONG, ullong), .offset = offsetof(TypeInfo, base)},
        {"fields", .type = TYPEID(27, TYPE_PTR, TypeFieldInfo *), .offset = offsetof(TypeInfo, fields)},
        {"num_fields", .type = TYPEID(8, TYPE_INT, int), .offset = offsetof(TypeInfo, num_fields)},
    }},
    [27] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(25, TYPE_STRUCT, TypeFieldInfo)},
    [28] = &(TypeInfo){TYPE_CONST, .size = sizeof(TypeInfo const ), .align = alignof(TypeInfo const ), .base = TYPEID(26, TYPE_STRUCT, TypeInfo)},
    [29] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(28, TYPE_CONST, TypeInfo const )},
    [30] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(29, TYPE_PTR, TypeInfo const (*))},
    [31] = NULL, // Func
    [32] = NULL, // Func
    [33] = NULL, // Func
    [34] = NULL, // Func
    [35] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(Any), .align = alignof(Any), .name = "Any", .num_fields = 2, .fields = (TypeFieldInfo[]) {
        {"ptr", .type = TYPEID(16, TYPE_PTR, void *), .offset = offsetof(Any, ptr)},
        {"type", .type = TYPEID(13, TYPE_ULLONG, ullong), .offset = offsetof(Any, type)},
    }},
    [36] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(old_std_Arena), .align = alignof(old_std_Arena), .name = "old_std_Arena", .num_fields = 3, .fields = (TypeFieldInfo[]) {
        {"ptr", .type = TYPEID(22, TYPE_PTR, char *), .offset = offsetof(old_std_Arena, ptr)},
        {"end", .type = TYPEID(22, TYPE_PTR, char *), .offset = offsetof(old_std_Arena, end)},
        {"blocks", .type = TYPEID(37, TYPE_PTR, char (**)), .offset = offsetof(old_std_Arena, blocks)},
    }},
    [37] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(22, TYPE_PTR, char *)},
    [38] = NULL, // Func
    [39] = &(TypeInfo){TYPE_CONST, .size = 0, .align = 0, .base = TYPEID0(1, TYPE_VOID)},
    [40] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID0(39, TYPE_CONST)},
    [41] = NULL, // Func
    [42] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_SrcPos), .align = alignof(src_pink_SrcPos), .name = "src_pink_SrcPos", .num_fields = 2, .fields = (TypeFieldInfo[]) {
        {"name", .type = TYPEID(18, TYPE_PTR, char const (*)), .offset = offsetof(src_pink_SrcPos, name)},
        {"line", .type = TYPEID(8, TYPE_INT, int), .offset = offsetof(src_pink_SrcPos, line)},
    }},
    [43] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_NoteArg), .align = alignof(src_pink_NoteArg), .name = "src_pink_NoteArg", .num_fields = 3, .fields = (TypeFieldInfo[]) {
        {"pos", .type = TYPEID(42, TYPE_STRUCT, src_pink_SrcPos), .offset = offsetof(src_pink_NoteArg, pos)},
        {"name", .type = TYPEID(18, TYPE_PTR, char const (*)), .offset = offsetof(src_pink_NoteArg, name)},
        {"expr", .type = TYPEID(62, TYPE_PTR, src_pink_Expr *), .offset = offsetof(src_pink_NoteArg, expr)},
    }},
    [44] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(43, TYPE_STRUCT, src_pink_NoteArg)},
    [45] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_Note), .align = alignof(src_pink_Note), .name = "src_pink_Note", .num_fields = 4, .fields = (TypeFieldInfo[]) {
        {"pos", .type = TYPEID(42, TYPE_STRUCT, src_pink_SrcPos), .offset = offsetof(src_pink_Note, pos)},
        {"name", .type = TYPEID(18, TYPE_PTR, char const (*)), .offset = offsetof(src_pink_Note, name)},
        {"args", .type = TYPEID(44, TYPE_PTR, src_pink_NoteArg *), .offset = offsetof(src_pink_Note, args)},
        {"num_args", .type = TYPEID(13, TYPE_ULLONG, ullong), .offset = offsetof(src_pink_Note, num_args)},
    }},
    [46] = NULL, // Func
    [47] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(45, TYPE_STRUCT, src_pink_Note)},
    [48] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_Notes), .align = alignof(src_pink_Notes), .name = "src_pink_Notes", .num_fields = 2, .fields = (TypeFieldInfo[]) {
        {"notes", .type = TYPEID(47, TYPE_PTR, src_pink_Note *), .offset = offsetof(src_pink_Notes, notes)},
        {"num_notes", .type = TYPEID(13, TYPE_ULLONG, ullong), .offset = offsetof(src_pink_Notes, num_notes)},
    }},
    [49] = NULL, // Func
    [50] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_Stmt), .align = alignof(src_pink_Stmt), .name = "src_pink_Stmt", .num_fields = 14, .fields = (TypeFieldInfo[]) {
        {"kind", .type = TYPEID(120, TYPE_NONE, src_pink_StmtKind), .offset = offsetof(src_pink_Stmt, kind)},
        {"notes", .type = TYPEID(48, TYPE_STRUCT, src_pink_Notes), .offset = offsetof(src_pink_Stmt, notes)},
        {"pos", .type = TYPEID(42, TYPE_STRUCT, src_pink_SrcPos), .offset = offsetof(src_pink_Stmt, pos)},
        {"note", .type = TYPEID(45, TYPE_STRUCT, src_pink_Note), .offset = offsetof(src_pink_Stmt, note)},
        {"expr", .type = TYPEID(62, TYPE_PTR, src_pink_Expr *), .offset = offsetof(src_pink_Stmt, expr)},
        {"decl", .type = TYPEID(67, TYPE_PTR, src_pink_Decl *), .offset = offsetof(src_pink_Stmt, decl)},
        {"if_stmt", .type = TYPEID(161, TYPE_STRUCT, src_pink_StmtIf), .offset = offsetof(src_pink_Stmt, if_stmt)},
        {"while_stmt", .type = TYPEID(162, TYPE_STRUCT, src_pink_StmtWhile), .offset = offsetof(src_pink_Stmt, while_stmt)},
        {"for_stmt", .type = TYPEID(163, TYPE_STRUCT, src_pink_StmtFor), .offset = offsetof(src_pink_Stmt, for_stmt)},
        {"switch_stmt", .type = TYPEID(164, TYPE_STRUCT, src_pink_StmtSwitch), .offset = offsetof(src_pink_Stmt, switch_stmt)},
        {"block", .type = TYPEID(53, TYPE_STRUCT, src_pink_StmtList), .offset = offsetof(src_pink_Stmt, block)},
        {"assign", .type = TYPEID(165, TYPE_STRUCT, src_pink_StmtAssign), .offset = offsetof(src_pink_Stmt, assign)},
        {"init", .type = TYPEID(166, TYPE_STRUCT, src_pink_StmtInit), .offset = offsetof(src_pink_Stmt, init)},
        {"label", .type = TYPEID(18, TYPE_PTR, char const (*)), .offset = offsetof(src_pink_Stmt, label)},
    }},
    [51] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(50, TYPE_STRUCT, src_pink_Stmt)},
    [52] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(51, TYPE_PTR, src_pink_Stmt *)},
    [53] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_StmtList), .align = alignof(src_pink_StmtList), .name = "src_pink_StmtList", .num_fields = 3, .fields = (TypeFieldInfo[]) {
        {"pos", .type = TYPEID(42, TYPE_STRUCT, src_pink_SrcPos), .offset = offsetof(src_pink_StmtList, pos)},
        {"stmts", .type = TYPEID(52, TYPE_PTR, src_pink_Stmt (**)), .offset = offsetof(src_pink_StmtList, stmts)},
        {"num_stmts", .type = TYPEID(13, TYPE_ULLONG, ullong), .offset = offsetof(src_pink_StmtList, num_stmts)},
    }},
    [54] = NULL, // Func
    [55] = NULL, // Enum
    [56] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_Typespec), .align = alignof(src_pink_Typespec), .name = "src_pink_Typespec", .num_fields = 6, .fields = (TypeFieldInfo[]) {
        {"kind", .type = TYPEID(55, TYPE_NONE, src_pink_TypespecKind), .offset = offsetof(src_pink_Typespec, kind)},
        {"pos", .type = TYPEID(42, TYPE_STRUCT, src_pink_SrcPos), .offset = offsetof(src_pink_Typespec, pos)},
        {"base", .type = TYPEID(57, TYPE_PTR, src_pink_Typespec *), .offset = offsetof(src_pink_Typespec, base)},
        {"name", .type = TYPEID(18, TYPE_PTR, char const (*)), .offset = offsetof(src_pink_Typespec, name)},
        {"function", .type = TYPEID(138, TYPE_STRUCT, src_pink_TypespecFunc), .offset = offsetof(src_pink_Typespec, function)},
        {"num_elems", .type = TYPEID(62, TYPE_PTR, src_pink_Expr *), .offset = offsetof(src_pink_Typespec, num_elems)},
    }},
    [57] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(56, TYPE_STRUCT, src_pink_Typespec)},
    [58] = NULL, // Func
    [59] = NULL, // Func
    [60] = NULL, // Func
    [61] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_Expr), .align = alignof(src_pink_Expr), .name = "src_pink_Expr", .num_fields = 23, .fields = (TypeFieldInfo[]) {
        {"kind", .type = TYPEID(95, TYPE_NONE, src_pink_ExprKind), .offset = offsetof(src_pink_Expr, kind)},
        {"pos", .type = TYPEID(42, TYPE_STRUCT, src_pink_SrcPos), .offset = offsetof(src_pink_Expr, pos)},
        {"paren", .type = TYPEID(146, TYPE_STRUCT, src_pink_ExprParen), .offset = offsetof(src_pink_Expr, paren)},
        {"int_lit", .type = TYPEID(147, TYPE_STRUCT, src_pink_ExprIntLit), .offset = offsetof(src_pink_Expr, int_lit)},
        {"float_lit", .type = TYPEID(148, TYPE_STRUCT, src_pink_ExprFloatLit), .offset = offsetof(src_pink_Expr, float_lit)},
        {"str_lit", .type = TYPEID(149, TYPE_STRUCT, src_pink_ExprStrLit), .offset = offsetof(src_pink_Expr, str_lit)},
        {"name", .type = TYPEID(18, TYPE_PTR, char const (*)), .offset = offsetof(src_pink_Expr, name)},
        {"sizeof_expr", .type = TYPEID(62, TYPE_PTR, src_pink_Expr *), .offset = offsetof(src_pink_Expr, sizeof_expr)},
        {"sizeof_type", .type = TYPEID(57, TYPE_PTR, src_pink_Typespec *), .offset = offsetof(src_pink_Expr, sizeof_type)},
        {"typeof_expr", .type = TYPEID(62, TYPE_PTR, src_pink_Expr *), .offset = offsetof(src_pink_Expr, typeof_expr)},
        {"typeof_type", .type = TYPEID(57, TYPE_PTR, src_pink_Typespec *), .offset = offsetof(src_pink_Expr, typeof_type)},
        {"alignof_expr", .type = TYPEID(62, TYPE_PTR, src_pink_Expr *), .offset = offsetof(src_pink_Expr, alignof_expr)},
        {"alignof_type", .type = TYPEID(57, TYPE_PTR, src_pink_Typespec *), .offset = offsetof(src_pink_Expr, alignof_type)},
        {"offsetof_field", .type = TYPEID(150, TYPE_STRUCT, src_pink_ExprOffsetofField), .offset = offsetof(src_pink_Expr, offsetof_field)},
        {"compound", .type = TYPEID(151, TYPE_STRUCT, src_pink_ExprCompound), .offset = offsetof(src_pink_Expr, compound)},
        {"cast", .type = TYPEID(152, TYPE_STRUCT, src_pink_ExprCast), .offset = offsetof(src_pink_Expr, cast)},
        {"modify", .type = TYPEID(153, TYPE_STRUCT, src_pink_ExprModify), .offset = offsetof(src_pink_Expr, modify)},
        {"unary", .type = TYPEID(154, TYPE_STRUCT, src_pink_ExprUnary), .offset = offsetof(src_pink_Expr, unary)},
        {"binary", .type = TYPEID(155, TYPE_STRUCT, src_pink_ExprBinary), .offset = offsetof(src_pink_Expr, binary)},
        {"ternary", .type = TYPEID(156, TYPE_STRUCT, src_pink_ExprTernary), .offset = offsetof(src_pink_Expr, ternary)},
        {"call", .type = TYPEID(157, TYPE_STRUCT, src_pink_ExprCall), .offset = offsetof(src_pink_Expr, call)},
        {"index", .type = TYPEID(158, TYPE_STRUCT, src_pink_ExprIndex), .offset = offsetof(src_pink_Expr, index)},
        {"field", .type = TYPEID(159, TYPE_STRUCT, src_pink_ExprField), .offset = offsetof(src_pink_Expr, field)},
    }},
    [62] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(61, TYPE_STRUCT, src_pink_Expr)},
    [63] = NULL, // Func
    [64] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(57, TYPE_PTR, src_pink_Typespec *)},
    [65] = NULL, // Func
    [66] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_Decl), .align = alignof(src_pink_Decl), .name = "src_pink_Decl", .num_fields = 13, .fields = (TypeFieldInfo[]) {
        {"kind", .type = TYPEID(72, TYPE_NONE, src_pink_DeclKind), .offset = offsetof(src_pink_Decl, kind)},
        {"pos", .type = TYPEID(42, TYPE_STRUCT, src_pink_SrcPos), .offset = offsetof(src_pink_Decl, pos)},
        {"name", .type = TYPEID(18, TYPE_PTR, char const (*)), .offset = offsetof(src_pink_Decl, name)},
        {"notes", .type = TYPEID(48, TYPE_STRUCT, src_pink_Notes), .offset = offsetof(src_pink_Decl, notes)},
        {"is_incomplete", .type = TYPEID(2, TYPE_BOOL, bool), .offset = offsetof(src_pink_Decl, is_incomplete)},
        {"note", .type = TYPEID(45, TYPE_STRUCT, src_pink_Note), .offset = offsetof(src_pink_Decl, note)},
        {"enum_decl", .type = TYPEID(140, TYPE_STRUCT, src_pink_DeclEnum), .offset = offsetof(src_pink_Decl, enum_decl)},
        {"aggregate", .type = TYPEID(83, TYPE_PTR, src_pink_Aggregate *), .offset = offsetof(src_pink_Decl, aggregate)},
        {"function", .type = TYPEID(141, TYPE_STRUCT, src_pink_DeclFunc), .offset = offsetof(src_pink_Decl, function)},
        {"typedef_decl", .type = TYPEID(142, TYPE_STRUCT, src_pink_DeclTypedef), .offset = offsetof(src_pink_Decl, typedef_decl)},
        {"var_decl", .type = TYPEID(143, TYPE_STRUCT, src_pink_DeclVar), .offset = offsetof(src_pink_Decl, var_decl)},
        {"const_decl", .type = TYPEID(143, TYPE_STRUCT, src_pink_DeclVar), .offset = offsetof(src_pink_Decl, const_decl)},
        {"import_decl", .type = TYPEID(144, TYPE_STRUCT, src_pink_DeclImport), .offset = offsetof(src_pink_Decl, import_decl)},
    }},
    [67] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(66, TYPE_STRUCT, src_pink_Decl)},
    [68] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(67, TYPE_PTR, src_pink_Decl *)},
    [69] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_Decls), .align = alignof(src_pink_Decls), .name = "src_pink_Decls", .num_fields = 2, .fields = (TypeFieldInfo[]) {
        {"decls", .type = TYPEID(68, TYPE_PTR, src_pink_Decl (**)), .offset = offsetof(src_pink_Decls, decls)},
        {"num_decls", .type = TYPEID(13, TYPE_ULLONG, ullong), .offset = offsetof(src_pink_Decls, num_decls)},
    }},
    [70] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(69, TYPE_STRUCT, src_pink_Decls)},
    [71] = NULL, // Func
    [72] = NULL, // Enum
    [73] = NULL, // Func
    [74] = NULL, // Func
    [75] = NULL, // Func
    [76] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_EnumItem), .align = alignof(src_pink_EnumItem), .name = "src_pink_EnumItem", .num_fields = 3, .fields = (TypeFieldInfo[]) {
        {"pos", .type = TYPEID(42, TYPE_STRUCT, src_pink_SrcPos), .offset = offsetof(src_pink_EnumItem, pos)},
        {"name", .type = TYPEID(18, TYPE_PTR, char const (*)), .offset = offsetof(src_pink_EnumItem, name)},
        {"init", .type = TYPEID(62, TYPE_PTR, src_pink_Expr *), .offset = offsetof(src_pink_EnumItem, init)},
    }},
    [77] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(76, TYPE_STRUCT, src_pink_EnumItem)},
    [78] = NULL, // Func
    [79] = NULL, // Enum
    [80] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_AggregateItem), .align = alignof(src_pink_AggregateItem), .name = "src_pink_AggregateItem", .num_fields = 6, .fields = (TypeFieldInfo[]) {
        {"pos", .type = TYPEID(42, TYPE_STRUCT, src_pink_SrcPos), .offset = offsetof(src_pink_AggregateItem, pos)},
        {"kind", .type = TYPEID(139, TYPE_NONE, src_pink_AggregateItemKind), .offset = offsetof(src_pink_AggregateItem, kind)},
        {"names", .type = TYPEID(19, TYPE_PTR, char const ((**))), .offset = offsetof(src_pink_AggregateItem, names)},
        {"num_names", .type = TYPEID(13, TYPE_ULLONG, ullong), .offset = offsetof(src_pink_AggregateItem, num_names)},
        {"type", .type = TYPEID(57, TYPE_PTR, src_pink_Typespec *), .offset = offsetof(src_pink_AggregateItem, type)},
        {"subaggregate", .type = TYPEID(83, TYPE_PTR, src_pink_Aggregate *), .offset = offsetof(src_pink_AggregateItem, subaggregate)},
    }},
    [81] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(80, TYPE_STRUCT, src_pink_AggregateItem)},
    [82] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_Aggregate), .align = alignof(src_pink_Aggregate), .name = "src_pink_Aggregate", .num_fields = 4, .fields = (TypeFieldInfo[]) {
        {"pos", .type = TYPEID(42, TYPE_STRUCT, src_pink_SrcPos), .offset = offsetof(src_pink_Aggregate, pos)},
        {"kind", .type = TYPEID(79, TYPE_NONE, src_pink_AggregateKind), .offset = offsetof(src_pink_Aggregate, kind)},
        {"items", .type = TYPEID(81, TYPE_PTR, src_pink_AggregateItem *), .offset = offsetof(src_pink_Aggregate, items)},
        {"num_items", .type = TYPEID(13, TYPE_ULLONG, ullong), .offset = offsetof(src_pink_Aggregate, num_items)},
    }},
    [83] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(82, TYPE_STRUCT, src_pink_Aggregate)},
    [84] = NULL, // Func
    [85] = NULL, // Func
    [86] = NULL, // Func
    [87] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_FuncParam), .align = alignof(src_pink_FuncParam), .name = "src_pink_FuncParam", .num_fields = 3, .fields = (TypeFieldInfo[]) {
        {"pos", .type = TYPEID(42, TYPE_STRUCT, src_pink_SrcPos), .offset = offsetof(src_pink_FuncParam, pos)},
        {"name", .type = TYPEID(18, TYPE_PTR, char const (*)), .offset = offsetof(src_pink_FuncParam, name)},
        {"type", .type = TYPEID(57, TYPE_PTR, src_pink_Typespec *), .offset = offsetof(src_pink_FuncParam, type)},
    }},
    [88] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(87, TYPE_STRUCT, src_pink_FuncParam)},
    [89] = NULL, // Func
    [90] = NULL, // Func
    [91] = NULL, // Func
    [92] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_ImportItem), .align = alignof(src_pink_ImportItem), .name = "src_pink_ImportItem", .num_fields = 2, .fields = (TypeFieldInfo[]) {
        {"name", .type = TYPEID(18, TYPE_PTR, char const (*)), .offset = offsetof(src_pink_ImportItem, name)},
        {"rename", .type = TYPEID(18, TYPE_PTR, char const (*)), .offset = offsetof(src_pink_ImportItem, rename)},
    }},
    [93] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(92, TYPE_STRUCT, src_pink_ImportItem)},
    [94] = NULL, // Func
    [95] = NULL, // Enum
    [96] = NULL, // Func
    [97] = NULL, // Func
    [98] = NULL, // Func
    [99] = NULL, // Func
    [100] = NULL, // Enum
    [101] = NULL, // Func
    [102] = NULL, // Enum
    [103] = NULL, // Enum
    [104] = NULL, // Func
    [105] = NULL, // Func
    [106] = NULL, // Func
    [107] = NULL, // Func
    [108] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_CompoundField), .align = alignof(src_pink_CompoundField), .name = "src_pink_CompoundField", .num_fields = 5, .fields = (TypeFieldInfo[]) {
        {"kind", .type = TYPEID(145, TYPE_NONE, src_pink_CompoundFieldKind), .offset = offsetof(src_pink_CompoundField, kind)},
        {"pos", .type = TYPEID(42, TYPE_STRUCT, src_pink_SrcPos), .offset = offsetof(src_pink_CompoundField, pos)},
        {"init", .type = TYPEID(62, TYPE_PTR, src_pink_Expr *), .offset = offsetof(src_pink_CompoundField, init)},
        {"name", .type = TYPEID(18, TYPE_PTR, char const (*)), .offset = offsetof(src_pink_CompoundField, name)},
        {"index", .type = TYPEID(62, TYPE_PTR, src_pink_Expr *), .offset = offsetof(src_pink_CompoundField, index)},
    }},
    [109] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(108, TYPE_STRUCT, src_pink_CompoundField)},
    [110] = NULL, // Func
    [111] = NULL, // Func
    [112] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(62, TYPE_PTR, src_pink_Expr *)},
    [113] = NULL, // Func
    [114] = NULL, // Func
    [115] = NULL, // Func
    [116] = NULL, // Func
    [117] = NULL, // Func
    [118] = NULL, // Func
    [119] = NULL, // Func
    [120] = NULL, // Enum
    [121] = NULL, // Func
    [122] = NULL, // Func
    [123] = NULL, // Func
    [124] = NULL, // Func
    [125] = NULL, // Func
    [126] = NULL, // Func
    [127] = NULL, // Func
    [128] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_ElseIf), .align = alignof(src_pink_ElseIf), .name = "src_pink_ElseIf", .num_fields = 2, .fields = (TypeFieldInfo[]) {
        {"cond", .type = TYPEID(62, TYPE_PTR, src_pink_Expr *), .offset = offsetof(src_pink_ElseIf, cond)},
        {"block", .type = TYPEID(53, TYPE_STRUCT, src_pink_StmtList), .offset = offsetof(src_pink_ElseIf, block)},
    }},
    [129] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(128, TYPE_STRUCT, src_pink_ElseIf)},
    [130] = NULL, // Func
    [131] = NULL, // Func
    [132] = NULL, // Func
    [133] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_SwitchCase), .align = alignof(src_pink_SwitchCase), .name = "src_pink_SwitchCase", .num_fields = 4, .fields = (TypeFieldInfo[]) {
        {"patterns", .type = TYPEID(243, TYPE_PTR, src_pink_SwitchCasePattern *), .offset = offsetof(src_pink_SwitchCase, patterns)},
        {"num_patterns", .type = TYPEID(13, TYPE_ULLONG, ullong), .offset = offsetof(src_pink_SwitchCase, num_patterns)},
        {"is_default", .type = TYPEID(2, TYPE_BOOL, bool), .offset = offsetof(src_pink_SwitchCase, is_default)},
        {"block", .type = TYPEID(53, TYPE_STRUCT, src_pink_StmtList), .offset = offsetof(src_pink_SwitchCase, block)},
    }},
    [134] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(133, TYPE_STRUCT, src_pink_SwitchCase)},
    [135] = NULL, // Func
    [136] = NULL, // Func
    [137] = NULL, // Func
    [138] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_TypespecFunc), .align = alignof(src_pink_TypespecFunc), .name = "src_pink_TypespecFunc", .num_fields = 4, .fields = (TypeFieldInfo[]) {
        {"args", .type = TYPEID(64, TYPE_PTR, src_pink_Typespec (**)), .offset = offsetof(src_pink_TypespecFunc, args)},
        {"num_args", .type = TYPEID(13, TYPE_ULLONG, ullong), .offset = offsetof(src_pink_TypespecFunc, num_args)},
        {"has_varargs", .type = TYPEID(2, TYPE_BOOL, bool), .offset = offsetof(src_pink_TypespecFunc, has_varargs)},
        {"ret", .type = TYPEID(57, TYPE_PTR, src_pink_Typespec *), .offset = offsetof(src_pink_TypespecFunc, ret)},
    }},
    [139] = NULL, // Enum
    [140] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_DeclEnum), .align = alignof(src_pink_DeclEnum), .name = "src_pink_DeclEnum", .num_fields = 3, .fields = (TypeFieldInfo[]) {
        {"type", .type = TYPEID(57, TYPE_PTR, src_pink_Typespec *), .offset = offsetof(src_pink_DeclEnum, type)},
        {"items", .type = TYPEID(77, TYPE_PTR, src_pink_EnumItem *), .offset = offsetof(src_pink_DeclEnum, items)},
        {"num_items", .type = TYPEID(13, TYPE_ULLONG, ullong), .offset = offsetof(src_pink_DeclEnum, num_items)},
    }},
    [141] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_DeclFunc), .align = alignof(src_pink_DeclFunc), .name = "src_pink_DeclFunc", .num_fields = 5, .fields = (TypeFieldInfo[]) {
        {"params", .type = TYPEID(88, TYPE_PTR, src_pink_FuncParam *), .offset = offsetof(src_pink_DeclFunc, params)},
        {"num_params", .type = TYPEID(13, TYPE_ULLONG, ullong), .offset = offsetof(src_pink_DeclFunc, num_params)},
        {"ret_type", .type = TYPEID(57, TYPE_PTR, src_pink_Typespec *), .offset = offsetof(src_pink_DeclFunc, ret_type)},
        {"has_varargs", .type = TYPEID(2, TYPE_BOOL, bool), .offset = offsetof(src_pink_DeclFunc, has_varargs)},
        {"block", .type = TYPEID(53, TYPE_STRUCT, src_pink_StmtList), .offset = offsetof(src_pink_DeclFunc, block)},
    }},
    [142] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_DeclTypedef), .align = alignof(src_pink_DeclTypedef), .name = "src_pink_DeclTypedef", .num_fields = 1, .fields = (TypeFieldInfo[]) {
        {"type", .type = TYPEID(57, TYPE_PTR, src_pink_Typespec *), .offset = offsetof(src_pink_DeclTypedef, type)},
    }},
    [143] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_DeclVar), .align = alignof(src_pink_DeclVar), .name = "src_pink_DeclVar", .num_fields = 2, .fields = (TypeFieldInfo[]) {
        {"type", .type = TYPEID(57, TYPE_PTR, src_pink_Typespec *), .offset = offsetof(src_pink_DeclVar, type)},
        {"expr", .type = TYPEID(62, TYPE_PTR, src_pink_Expr *), .offset = offsetof(src_pink_DeclVar, expr)},
    }},
    [144] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_DeclImport), .align = alignof(src_pink_DeclImport), .name = "src_pink_DeclImport", .num_fields = 6, .fields = (TypeFieldInfo[]) {
        {"is_relative", .type = TYPEID(2, TYPE_BOOL, bool), .offset = offsetof(src_pink_DeclImport, is_relative)},
        {"names", .type = TYPEID(19, TYPE_PTR, char const ((**))), .offset = offsetof(src_pink_DeclImport, names)},
        {"num_names", .type = TYPEID(13, TYPE_ULLONG, ullong), .offset = offsetof(src_pink_DeclImport, num_names)},
        {"import_all", .type = TYPEID(2, TYPE_BOOL, bool), .offset = offsetof(src_pink_DeclImport, import_all)},
        {"items", .type = TYPEID(93, TYPE_PTR, src_pink_ImportItem *), .offset = offsetof(src_pink_DeclImport, items)},
        {"num_items", .type = TYPEID(13, TYPE_ULLONG, ullong), .offset = offsetof(src_pink_DeclImport, num_items)},
    }},
    [145] = NULL, // Enum
    [146] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_ExprParen), .align = alignof(src_pink_ExprParen), .name = "src_pink_ExprParen", .num_fields = 1, .fields = (TypeFieldInfo[]) {
        {"expr", .type = TYPEID(62, TYPE_PTR, src_pink_Expr *), .offset = offsetof(src_pink_ExprParen, expr)},
    }},
    [147] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_ExprIntLit), .align = alignof(src_pink_ExprIntLit), .name = "src_pink_ExprIntLit", .num_fields = 3, .fields = (TypeFieldInfo[]) {
        {"val", .type = TYPEID(13, TYPE_ULLONG, ullong), .offset = offsetof(src_pink_ExprIntLit, val)},
        {"mod", .type = TYPEID(102, TYPE_NONE, src_pink_TokenMod), .offset = offsetof(src_pink_ExprIntLit, mod)},
        {"suffix", .type = TYPEID(103, TYPE_NONE, src_pink_TokenSuffix), .offset = offsetof(src_pink_ExprIntLit, suffix)},
    }},
    [148] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_ExprFloatLit), .align = alignof(src_pink_ExprFloatLit), .name = "src_pink_ExprFloatLit", .num_fields = 4, .fields = (TypeFieldInfo[]) {
        {"start", .type = TYPEID(18, TYPE_PTR, char const (*)), .offset = offsetof(src_pink_ExprFloatLit, start)},
        {"end", .type = TYPEID(18, TYPE_PTR, char const (*)), .offset = offsetof(src_pink_ExprFloatLit, end)},
        {"val", .type = TYPEID(15, TYPE_DOUBLE, double), .offset = offsetof(src_pink_ExprFloatLit, val)},
        {"suffix", .type = TYPEID(103, TYPE_NONE, src_pink_TokenSuffix), .offset = offsetof(src_pink_ExprFloatLit, suffix)},
    }},
    [149] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_ExprStrLit), .align = alignof(src_pink_ExprStrLit), .name = "src_pink_ExprStrLit", .num_fields = 2, .fields = (TypeFieldInfo[]) {
        {"val", .type = TYPEID(18, TYPE_PTR, char const (*)), .offset = offsetof(src_pink_ExprStrLit, val)},
        {"mod", .type = TYPEID(102, TYPE_NONE, src_pink_TokenMod), .offset = offsetof(src_pink_ExprStrLit, mod)},
    }},
    [150] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_ExprOffsetofField), .align = alignof(src_pink_ExprOffsetofField), .name = "src_pink_ExprOffsetofField", .num_fields = 2, .fields = (TypeFieldInfo[]) {
        {"type", .type = TYPEID(57, TYPE_PTR, src_pink_Typespec *), .offset = offsetof(src_pink_ExprOffsetofField, type)},
        {"name", .type = TYPEID(18, TYPE_PTR, char const (*)), .offset = offsetof(src_pink_ExprOffsetofField, name)},
    }},
    [151] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_ExprCompound), .align = alignof(src_pink_ExprCompound), .name = "src_pink_ExprCompound", .num_fields = 3, .fields = (TypeFieldInfo[]) {
        {"type", .type = TYPEID(57, TYPE_PTR, src_pink_Typespec *), .offset = offsetof(src_pink_ExprCompound, type)},
        {"fields", .type = TYPEID(109, TYPE_PTR, src_pink_CompoundField *), .offset = offsetof(src_pink_ExprCompound, fields)},
        {"num_fields", .type = TYPEID(13, TYPE_ULLONG, ullong), .offset = offsetof(src_pink_ExprCompound, num_fields)},
    }},
    [152] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_ExprCast), .align = alignof(src_pink_ExprCast), .name = "src_pink_ExprCast", .num_fields = 2, .fields = (TypeFieldInfo[]) {
        {"type", .type = TYPEID(57, TYPE_PTR, src_pink_Typespec *), .offset = offsetof(src_pink_ExprCast, type)},
        {"expr", .type = TYPEID(62, TYPE_PTR, src_pink_Expr *), .offset = offsetof(src_pink_ExprCast, expr)},
    }},
    [153] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_ExprModify), .align = alignof(src_pink_ExprModify), .name = "src_pink_ExprModify", .num_fields = 3, .fields = (TypeFieldInfo[]) {
        {"op", .type = TYPEID(100, TYPE_NONE, src_pink_TokenKind), .offset = offsetof(src_pink_ExprModify, op)},
        {"post", .type = TYPEID(2, TYPE_BOOL, bool), .offset = offsetof(src_pink_ExprModify, post)},
        {"expr", .type = TYPEID(62, TYPE_PTR, src_pink_Expr *), .offset = offsetof(src_pink_ExprModify, expr)},
    }},
    [154] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_ExprUnary), .align = alignof(src_pink_ExprUnary), .name = "src_pink_ExprUnary", .num_fields = 2, .fields = (TypeFieldInfo[]) {
        {"op", .type = TYPEID(100, TYPE_NONE, src_pink_TokenKind), .offset = offsetof(src_pink_ExprUnary, op)},
        {"expr", .type = TYPEID(62, TYPE_PTR, src_pink_Expr *), .offset = offsetof(src_pink_ExprUnary, expr)},
    }},
    [155] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_ExprBinary), .align = alignof(src_pink_ExprBinary), .name = "src_pink_ExprBinary", .num_fields = 3, .fields = (TypeFieldInfo[]) {
        {"op", .type = TYPEID(100, TYPE_NONE, src_pink_TokenKind), .offset = offsetof(src_pink_ExprBinary, op)},
        {"left", .type = TYPEID(62, TYPE_PTR, src_pink_Expr *), .offset = offsetof(src_pink_ExprBinary, left)},
        {"right", .type = TYPEID(62, TYPE_PTR, src_pink_Expr *), .offset = offsetof(src_pink_ExprBinary, right)},
    }},
    [156] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_ExprTernary), .align = alignof(src_pink_ExprTernary), .name = "src_pink_ExprTernary", .num_fields = 3, .fields = (TypeFieldInfo[]) {
        {"cond", .type = TYPEID(62, TYPE_PTR, src_pink_Expr *), .offset = offsetof(src_pink_ExprTernary, cond)},
        {"then_expr", .type = TYPEID(62, TYPE_PTR, src_pink_Expr *), .offset = offsetof(src_pink_ExprTernary, then_expr)},
        {"else_expr", .type = TYPEID(62, TYPE_PTR, src_pink_Expr *), .offset = offsetof(src_pink_ExprTernary, else_expr)},
    }},
    [157] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_ExprCall), .align = alignof(src_pink_ExprCall), .name = "src_pink_ExprCall", .num_fields = 3, .fields = (TypeFieldInfo[]) {
        {"expr", .type = TYPEID(62, TYPE_PTR, src_pink_Expr *), .offset = offsetof(src_pink_ExprCall, expr)},
        {"args", .type = TYPEID(112, TYPE_PTR, src_pink_Expr (**)), .offset = offsetof(src_pink_ExprCall, args)},
        {"num_args", .type = TYPEID(13, TYPE_ULLONG, ullong), .offset = offsetof(src_pink_ExprCall, num_args)},
    }},
    [158] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_ExprIndex), .align = alignof(src_pink_ExprIndex), .name = "src_pink_ExprIndex", .num_fields = 2, .fields = (TypeFieldInfo[]) {
        {"expr", .type = TYPEID(62, TYPE_PTR, src_pink_Expr *), .offset = offsetof(src_pink_ExprIndex, expr)},
        {"index", .type = TYPEID(62, TYPE_PTR, src_pink_Expr *), .offset = offsetof(src_pink_ExprIndex, index)},
    }},
    [159] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_ExprField), .align = alignof(src_pink_ExprField), .name = "src_pink_ExprField", .num_fields = 2, .fields = (TypeFieldInfo[]) {
        {"expr", .type = TYPEID(62, TYPE_PTR, src_pink_Expr *), .offset = offsetof(src_pink_ExprField, expr)},
        {"name", .type = TYPEID(18, TYPE_PTR, char const (*)), .offset = offsetof(src_pink_ExprField, name)},
    }},
    [160] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_SwitchCasePattern), .align = alignof(src_pink_SwitchCasePattern), .name = "src_pink_SwitchCasePattern", .num_fields = 2, .fields = (TypeFieldInfo[]) {
        {"start", .type = TYPEID(62, TYPE_PTR, src_pink_Expr *), .offset = offsetof(src_pink_SwitchCasePattern, start)},
        {"end", .type = TYPEID(62, TYPE_PTR, src_pink_Expr *), .offset = offsetof(src_pink_SwitchCasePattern, end)},
    }},
    [161] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_StmtIf), .align = alignof(src_pink_StmtIf), .name = "src_pink_StmtIf", .num_fields = 6, .fields = (TypeFieldInfo[]) {
        {"init", .type = TYPEID(51, TYPE_PTR, src_pink_Stmt *), .offset = offsetof(src_pink_StmtIf, init)},
        {"cond", .type = TYPEID(62, TYPE_PTR, src_pink_Expr *), .offset = offsetof(src_pink_StmtIf, cond)},
        {"then_block", .type = TYPEID(53, TYPE_STRUCT, src_pink_StmtList), .offset = offsetof(src_pink_StmtIf, then_block)},
        {"elseifs", .type = TYPEID(129, TYPE_PTR, src_pink_ElseIf *), .offset = offsetof(src_pink_StmtIf, elseifs)},
        {"num_elseifs", .type = TYPEID(13, TYPE_ULLONG, ullong), .offset = offsetof(src_pink_StmtIf, num_elseifs)},
        {"else_block", .type = TYPEID(53, TYPE_STRUCT, src_pink_StmtList), .offset = offsetof(src_pink_StmtIf, else_block)},
    }},
    [162] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_StmtWhile), .align = alignof(src_pink_StmtWhile), .name = "src_pink_StmtWhile", .num_fields = 2, .fields = (TypeFieldInfo[]) {
        {"cond", .type = TYPEID(62, TYPE_PTR, src_pink_Expr *), .offset = offsetof(src_pink_StmtWhile, cond)},
        {"block", .type = TYPEID(53, TYPE_STRUCT, src_pink_StmtList), .offset = offsetof(src_pink_StmtWhile, block)},
    }},
    [163] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_StmtFor), .align = alignof(src_pink_StmtFor), .name = "src_pink_StmtFor", .num_fields = 4, .fields = (TypeFieldInfo[]) {
        {"init", .type = TYPEID(51, TYPE_PTR, src_pink_Stmt *), .offset = offsetof(src_pink_StmtFor, init)},
        {"cond", .type = TYPEID(62, TYPE_PTR, src_pink_Expr *), .offset = offsetof(src_pink_StmtFor, cond)},
        {"next", .type = TYPEID(51, TYPE_PTR, src_pink_Stmt *), .offset = offsetof(src_pink_StmtFor, next)},
        {"block", .type = TYPEID(53, TYPE_STRUCT, src_pink_StmtList), .offset = offsetof(src_pink_StmtFor, block)},
    }},
    [164] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_StmtSwitch), .align = alignof(src_pink_StmtSwitch), .name = "src_pink_StmtSwitch", .num_fields = 3, .fields = (TypeFieldInfo[]) {
        {"expr", .type = TYPEID(62, TYPE_PTR, src_pink_Expr *), .offset = offsetof(src_pink_StmtSwitch, expr)},
        {"cases", .type = TYPEID(134, TYPE_PTR, src_pink_SwitchCase *), .offset = offsetof(src_pink_StmtSwitch, cases)},
        {"num_cases", .type = TYPEID(13, TYPE_ULLONG, ullong), .offset = offsetof(src_pink_StmtSwitch, num_cases)},
    }},
    [165] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_StmtAssign), .align = alignof(src_pink_StmtAssign), .name = "src_pink_StmtAssign", .num_fields = 3, .fields = (TypeFieldInfo[]) {
        {"op", .type = TYPEID(100, TYPE_NONE, src_pink_TokenKind), .offset = offsetof(src_pink_StmtAssign, op)},
        {"left", .type = TYPEID(62, TYPE_PTR, src_pink_Expr *), .offset = offsetof(src_pink_StmtAssign, left)},
        {"right", .type = TYPEID(62, TYPE_PTR, src_pink_Expr *), .offset = offsetof(src_pink_StmtAssign, right)},
    }},
    [166] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_StmtInit), .align = alignof(src_pink_StmtInit), .name = "src_pink_StmtInit", .num_fields = 3, .fields = (TypeFieldInfo[]) {
        {"name", .type = TYPEID(18, TYPE_PTR, char const (*)), .offset = offsetof(src_pink_StmtInit, name)},
        {"type", .type = TYPEID(57, TYPE_PTR, src_pink_Typespec *), .offset = offsetof(src_pink_StmtInit, type)},
        {"expr", .type = TYPEID(62, TYPE_PTR, src_pink_Expr *), .offset = offsetof(src_pink_StmtInit, expr)},
    }},
    [167] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [909]), .align = alignof(char [909]), .base = TYPEID(3, TYPE_CHAR, char), .count = 909},
    [168] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [1513]), .align = alignof(char [1513]), .base = TYPEID(3, TYPE_CHAR, char), .count = 1513},
    [169] = NULL, // Func
    [170] = NULL, // Func
    [171] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [256]), .align = alignof(char [256]), .base = TYPEID(3, TYPE_CHAR, char), .count = 256},
    [172] = NULL, // Func
    [173] = NULL, // Func
    [174] = NULL, // Func
    [175] = NULL, // Func
    [176] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_Type), .align = alignof(src_pink_Type), .name = "src_pink_Type", .num_fields = 10, .fields = (TypeFieldInfo[]) {
        {"kind", .type = TYPEID(192, TYPE_NONE, src_pink_CompilerTypeKind), .offset = offsetof(src_pink_Type, kind)},
        {"size", .type = TYPEID(13, TYPE_ULLONG, ullong), .offset = offsetof(src_pink_Type, size)},
        {"align", .type = TYPEID(13, TYPE_ULLONG, ullong), .offset = offsetof(src_pink_Type, align)},
        {"sym", .type = TYPEID(188, TYPE_PTR, src_pink_Sym *), .offset = offsetof(src_pink_Type, sym)},
        {"base", .type = TYPEID(177, TYPE_PTR, src_pink_Type *), .offset = offsetof(src_pink_Type, base)},
        {"typeid", .type = TYPEID(8, TYPE_INT, int), .offset = offsetof(src_pink_Type, typeid)},
        {"nonmodifiable", .type = TYPEID(2, TYPE_BOOL, bool), .offset = offsetof(src_pink_Type, nonmodifiable)},
        {"num_elems", .type = TYPEID(13, TYPE_ULLONG, ullong), .offset = offsetof(src_pink_Type, num_elems)},
        {"aggregate", .type = TYPEID(341, TYPE_STRUCT, src_pink_TypeAggregate), .offset = offsetof(src_pink_Type, aggregate)},
        {"function", .type = TYPEID(342, TYPE_STRUCT, src_pink_TypeFunc), .offset = offsetof(src_pink_Type, function)},
    }},
    [177] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(176, TYPE_STRUCT, src_pink_Type)},
    [178] = NULL, // Func
    [179] = NULL, // Func
    [180] = NULL, // Func
    [181] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(old_std_Map), .align = alignof(old_std_Map), .name = "old_std_Map", .num_fields = 4, .fields = (TypeFieldInfo[]) {
        {"keys", .type = TYPEID(182, TYPE_PTR, ullong *), .offset = offsetof(old_std_Map, keys)},
        {"vals", .type = TYPEID(182, TYPE_PTR, ullong *), .offset = offsetof(old_std_Map, vals)},
        {"len", .type = TYPEID(13, TYPE_ULLONG, ullong), .offset = offsetof(old_std_Map, len)},
        {"cap", .type = TYPEID(13, TYPE_ULLONG, ullong), .offset = offsetof(old_std_Map, cap)},
    }},
    [182] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(13, TYPE_ULLONG, ullong)},
    [183] = NULL, // Func
    [184] = NULL, // Func
    [185] = NULL, // Func
    [186] = NULL, // Func
    [187] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_Sym), .align = alignof(src_pink_Sym), .name = "src_pink_Sym", .num_fields = 10, .fields = (TypeFieldInfo[]) {
        {"name", .type = TYPEID(18, TYPE_PTR, char const (*)), .offset = offsetof(src_pink_Sym, name)},
        {"home_package", .type = TYPEID(206, TYPE_PTR, src_pink_Package *), .offset = offsetof(src_pink_Sym, home_package)},
        {"kind", .type = TYPEID(260, TYPE_NONE, src_pink_SymKind), .offset = offsetof(src_pink_Sym, kind)},
        {"state", .type = TYPEID(261, TYPE_NONE, src_pink_SymState), .offset = offsetof(src_pink_Sym, state)},
        {"reachable", .type = TYPEID(4, TYPE_UCHAR, uchar), .offset = offsetof(src_pink_Sym, reachable)},
        {"decl", .type = TYPEID(67, TYPE_PTR, src_pink_Decl *), .offset = offsetof(src_pink_Sym, decl)},
        {"external_name", .type = TYPEID(18, TYPE_PTR, char const (*)), .offset = offsetof(src_pink_Sym, external_name)},
        {"type", .type = TYPEID(177, TYPE_PTR, src_pink_Type *), .offset = offsetof(src_pink_Sym, type)},
        {"val", .type = TYPEID(266, TYPE_UNION, old_std_Val), .offset = offsetof(src_pink_Sym, val)},
        {"package", .type = TYPEID(206, TYPE_PTR, src_pink_Package *), .offset = offsetof(src_pink_Sym, package)},
    }},
    [188] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(187, TYPE_STRUCT, src_pink_Sym)},
    [189] = NULL, // Func
    [190] = NULL, // Func
    [191] = NULL, // Func
    [192] = NULL, // Enum
    [193] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char const (*[25])), .align = alignof(char const (*[25])), .base = TYPEID(18, TYPE_PTR, char const (*)), .count = 25},
    [194] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [10]), .align = alignof(char [10]), .base = TYPEID(3, TYPE_CHAR, char), .count = 10},
    [195] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [11]), .align = alignof(char [11]), .base = TYPEID(3, TYPE_CHAR, char), .count = 11},
    [196] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [12]), .align = alignof(char [12]), .base = TYPEID(3, TYPE_CHAR, char), .count = 12},
    [197] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [9]), .align = alignof(char [9]), .base = TYPEID(3, TYPE_CHAR, char), .count = 9},
    [198] = NULL, // Func
    [199] = NULL, // Func
    [200] = NULL, // Func
    [201] = NULL, // Func
    [202] = NULL, // Func
    [203] = NULL, // Func
    [204] = NULL, // Func
    [205] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_Package), .align = alignof(src_pink_Package), .name = "src_pink_Package", .num_fields = 8, .fields = (TypeFieldInfo[]) {
        {"path", .type = TYPEID(18, TYPE_PTR, char const (*)), .offset = offsetof(src_pink_Package, path)},
        {"full_path", .type = TYPEID(171, TYPE_ARRAY, char [256]), .offset = offsetof(src_pink_Package, full_path)},
        {"decls", .type = TYPEID(68, TYPE_PTR, src_pink_Decl (**)), .offset = offsetof(src_pink_Package, decls)},
        {"num_decls", .type = TYPEID(13, TYPE_ULLONG, ullong), .offset = offsetof(src_pink_Package, num_decls)},
        {"syms_map", .type = TYPEID(181, TYPE_STRUCT, old_std_Map), .offset = offsetof(src_pink_Package, syms_map)},
        {"syms", .type = TYPEID(265, TYPE_PTR, src_pink_Sym (**)), .offset = offsetof(src_pink_Package, syms)},
        {"external_name", .type = TYPEID(18, TYPE_PTR, char const (*)), .offset = offsetof(src_pink_Package, external_name)},
        {"always_reachable", .type = TYPEID(2, TYPE_BOOL, bool), .offset = offsetof(src_pink_Package, always_reachable)},
    }},
    [206] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(205, TYPE_STRUCT, src_pink_Package)},
    [207] = NULL, // Func
    [208] = NULL, // Func
    [209] = NULL, // Func
    [210] = NULL, // Func
    [211] = NULL, // Func
    [212] = NULL, // Incomplete array type
    [213] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [1]), .align = alignof(char [1]), .base = TYPEID(3, TYPE_CHAR, char), .count = 1},
    [214] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [2]), .align = alignof(char [2]), .base = TYPEID(3, TYPE_CHAR, char), .count = 2},
    [215] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [3]), .align = alignof(char [3]), .base = TYPEID(3, TYPE_CHAR, char), .count = 3},
    [216] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char const (*[7])), .align = alignof(char const (*[7])), .base = TYPEID(18, TYPE_PTR, char const (*)), .count = 7},
    [217] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [6]), .align = alignof(char [6]), .base = TYPEID(3, TYPE_CHAR, char), .count = 6},
    [218] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [7]), .align = alignof(char [7]), .base = TYPEID(3, TYPE_CHAR, char), .count = 7},
    [219] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [5]), .align = alignof(char [5]), .base = TYPEID(3, TYPE_CHAR, char), .count = 5},
    [220] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char const (*[54])), .align = alignof(char const (*[54])), .base = TYPEID(18, TYPE_PTR, char const (*)), .count = 54},
    [221] = NULL, // Func
    [222] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(src_pink_TokenKind [54]), .align = alignof(src_pink_TokenKind [54]), .base = TYPEID(100, TYPE_NONE, src_pink_TokenKind), .count = 54},
    [223] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_Token), .align = alignof(src_pink_Token), .name = "src_pink_Token", .num_fields = 10, .fields = (TypeFieldInfo[]) {
        {"kind", .type = TYPEID(100, TYPE_NONE, src_pink_TokenKind), .offset = offsetof(src_pink_Token, kind)},
        {"mod", .type = TYPEID(102, TYPE_NONE, src_pink_TokenMod), .offset = offsetof(src_pink_Token, mod)},
        {"suffix", .type = TYPEID(103, TYPE_NONE, src_pink_TokenSuffix), .offset = offsetof(src_pink_Token, suffix)},
        {"pos", .type = TYPEID(42, TYPE_STRUCT, src_pink_SrcPos), .offset = offsetof(src_pink_Token, pos)},
        {"start", .type = TYPEID(18, TYPE_PTR, char const (*)), .offset = offsetof(src_pink_Token, start)},
        {"end", .type = TYPEID(18, TYPE_PTR, char const (*)), .offset = offsetof(src_pink_Token, end)},
        {"int_val", .type = TYPEID(13, TYPE_ULLONG, ullong), .offset = offsetof(src_pink_Token, int_val)},
        {"float_val", .type = TYPEID(15, TYPE_DOUBLE, double), .offset = offsetof(src_pink_Token, float_val)},
        {"str_val", .type = TYPEID(18, TYPE_PTR, char const (*)), .offset = offsetof(src_pink_Token, str_val)},
        {"name", .type = TYPEID(18, TYPE_PTR, char const (*)), .offset = offsetof(src_pink_Token, name)},
    }},
    [224] = NULL, // No associated type
    [225] = NULL, // Func
    [226] = NULL, // Func
    [227] = NULL, // Func
    [228] = NULL, // Func
    [229] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(uchar [256]), .align = alignof(uchar [256]), .base = TYPEID(4, TYPE_UCHAR, uchar), .count = 256},
    [230] = NULL, // Func
    [231] = NULL, // Func
    [232] = NULL, // Func
    [233] = NULL, // Func
    [234] = NULL, // Func
    [235] = NULL, // No associated type
    [236] = NULL, // Func
    [237] = NULL, // Func
    [238] = NULL, // Func
    [239] = NULL, // Func
    [240] = NULL, // Func
    [241] = NULL, // Func
    [242] = NULL, // Func
    [243] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(160, TYPE_STRUCT, src_pink_SwitchCasePattern)},
    [244] = NULL, // Func
    [245] = NULL, // Func
    [246] = NULL, // Func
    [247] = NULL, // No associated type
    [248] = NULL, // No associated type
    [249] = NULL, // Func
    [250] = NULL, // Func
    [251] = NULL, // Func
    [252] = NULL, // Func
    [253] = NULL, // Func
    [254] = NULL, // Func
    [255] = NULL, // Func
    [256] = NULL, // Func
    [257] = NULL, // Func
    [258] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char const (*[256])), .align = alignof(char const (*[256])), .base = TYPEID(18, TYPE_PTR, char const (*)), .count = 256},
    [259] = NULL, // Func
    [260] = NULL, // Enum
    [261] = NULL, // Enum
    [262] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(206, TYPE_PTR, src_pink_Package *)},
    [263] = NULL, // Func
    [264] = NULL, // Func
    [265] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(188, TYPE_PTR, src_pink_Sym *)},
    [266] = &(TypeInfo){TYPE_UNION, .size = sizeof(old_std_Val), .align = alignof(old_std_Val), .name = "old_std_Val", .num_fields = 13, .fields = (TypeFieldInfo[]) {
        {"b", .type = TYPEID(2, TYPE_BOOL, bool), .offset = offsetof(old_std_Val, b)},
        {"c", .type = TYPEID(3, TYPE_CHAR, char), .offset = offsetof(old_std_Val, c)},
        {"uc", .type = TYPEID(4, TYPE_UCHAR, uchar), .offset = offsetof(old_std_Val, uc)},
        {"sc", .type = TYPEID(5, TYPE_SCHAR, schar), .offset = offsetof(old_std_Val, sc)},
        {"s", .type = TYPEID(6, TYPE_SHORT, short), .offset = offsetof(old_std_Val, s)},
        {"us", .type = TYPEID(7, TYPE_USHORT, ushort), .offset = offsetof(old_std_Val, us)},
        {"i", .type = TYPEID(8, TYPE_INT, int), .offset = offsetof(old_std_Val, i)},
        {"u", .type = TYPEID(9, TYPE_UINT, uint), .offset = offsetof(old_std_Val, u)},
        {"l", .type = TYPEID(10, TYPE_LONG, long), .offset = offsetof(old_std_Val, l)},
        {"ul", .type = TYPEID(11, TYPE_ULONG, ulong), .offset = offsetof(old_std_Val, ul)},
        {"ll", .type = TYPEID(12, TYPE_LLONG, llong), .offset = offsetof(old_std_Val, ll)},
        {"ull", .type = TYPEID(13, TYPE_ULLONG, ullong), .offset = offsetof(old_std_Val, ull)},
        {"p", .type = TYPEID(13, TYPE_ULLONG, ullong), .offset = offsetof(old_std_Val, p)},
    }},
    [267] = NULL, // No associated type
    [268] = NULL, // No associated type
    [269] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(src_pink_Sym [1024]), .align = alignof(src_pink_Sym [1024]), .base = TYPEID(187, TYPE_STRUCT, src_pink_Sym), .count = 1024},
    [270] = NULL, // Func
    [271] = NULL, // Func
    [272] = NULL, // Func
    [273] = NULL, // Func
    [274] = NULL, // Func
    [275] = NULL, // Func
    [276] = NULL, // Func
    [277] = NULL, // Func
    [278] = NULL, // Func
    [279] = NULL, // Func
    [280] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_Operand), .align = alignof(src_pink_Operand), .name = "src_pink_Operand", .num_fields = 4, .fields = (TypeFieldInfo[]) {
        {"type", .type = TYPEID(177, TYPE_PTR, src_pink_Type *), .offset = offsetof(src_pink_Operand, type)},
        {"is_lvalue", .type = TYPEID(2, TYPE_BOOL, bool), .offset = offsetof(src_pink_Operand, is_lvalue)},
        {"is_const", .type = TYPEID(2, TYPE_BOOL, bool), .offset = offsetof(src_pink_Operand, is_const)},
        {"val", .type = TYPEID(266, TYPE_UNION, old_std_Val), .offset = offsetof(src_pink_Operand, val)},
    }},
    [281] = NULL, // Func
    [282] = NULL, // Func
    [283] = NULL, // Func
    [284] = NULL, // Func
    [285] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(280, TYPE_STRUCT, src_pink_Operand)},
    [286] = NULL, // Func
    [287] = NULL, // Func
    [288] = NULL, // Func
    [289] = NULL, // Func
    [290] = NULL, // Func
    [291] = NULL, // Func
    [292] = NULL, // Func
    [293] = NULL, // Func
    [294] = NULL, // Func
    [295] = NULL, // Func
    [296] = NULL, // Func
    [297] = NULL, // Func
    [298] = NULL, // Func
    [299] = NULL, // Func
    [300] = NULL, // Func
    [301] = NULL, // Func
    [302] = NULL, // Func
    [303] = NULL, // Func
    [304] = NULL, // Func
    [305] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(266, TYPE_UNION, old_std_Val)},
    [306] = NULL, // Func
    [307] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_StmtCtx), .align = alignof(src_pink_StmtCtx), .name = "src_pink_StmtCtx", .num_fields = 2, .fields = (TypeFieldInfo[]) {
        {"is_break_legal", .type = TYPEID(2, TYPE_BOOL, bool), .offset = offsetof(src_pink_StmtCtx, is_break_legal)},
        {"is_continue_legal", .type = TYPEID(2, TYPE_BOOL, bool), .offset = offsetof(src_pink_StmtCtx, is_continue_legal)},
    }},
    [308] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_Label), .align = alignof(src_pink_Label), .name = "src_pink_Label", .num_fields = 4, .fields = (TypeFieldInfo[]) {
        {"name", .type = TYPEID(18, TYPE_PTR, char const (*)), .offset = offsetof(src_pink_Label, name)},
        {"pos", .type = TYPEID(42, TYPE_STRUCT, src_pink_SrcPos), .offset = offsetof(src_pink_Label, pos)},
        {"referenced", .type = TYPEID(2, TYPE_BOOL, bool), .offset = offsetof(src_pink_Label, referenced)},
        {"defined", .type = TYPEID(2, TYPE_BOOL, bool), .offset = offsetof(src_pink_Label, defined)},
    }},
    [309] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(src_pink_Label [256]), .align = alignof(src_pink_Label [256]), .base = TYPEID(308, TYPE_STRUCT, src_pink_Label), .count = 256},
    [310] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(308, TYPE_STRUCT, src_pink_Label)},
    [311] = NULL, // Func
    [312] = NULL, // Func
    [313] = NULL, // Func
    [314] = NULL, // Func
    [315] = NULL, // Func
    [316] = NULL, // Func
    [317] = NULL, // Func
    [318] = NULL, // Func
    [319] = NULL, // Func
    [320] = NULL, // Func
    [321] = NULL, // Func
    [322] = NULL, // Func
    [323] = NULL, // Func
    [324] = NULL, // Func
    [325] = NULL, // Func
    [326] = NULL, // Func
    [327] = NULL, // Func
    [328] = NULL, // Func
    [329] = NULL, // Func
    [330] = NULL, // Func
    [331] = NULL, // Func
    [332] = NULL, // Enum
    [333] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char const (*[1])), .align = alignof(char const (*[1])), .base = TYPEID(18, TYPE_PTR, char const (*)), .count = 1},
    [334] = NULL, // Enum
    [335] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char const (*[2])), .align = alignof(char const (*[2])), .base = TYPEID(18, TYPE_PTR, char const (*)), .count = 2},
    [336] = NULL, // Func
    [337] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_TypeMetrics), .align = alignof(src_pink_TypeMetrics), .name = "src_pink_TypeMetrics", .num_fields = 4, .fields = (TypeFieldInfo[]) {
        {"size", .type = TYPEID(13, TYPE_ULLONG, ullong), .offset = offsetof(src_pink_TypeMetrics, size)},
        {"align", .type = TYPEID(13, TYPE_ULLONG, ullong), .offset = offsetof(src_pink_TypeMetrics, align)},
        {"sign", .type = TYPEID(2, TYPE_BOOL, bool), .offset = offsetof(src_pink_TypeMetrics, sign)},
        {"max", .type = TYPEID(13, TYPE_ULLONG, ullong), .offset = offsetof(src_pink_TypeMetrics, max)},
    }},
    [338] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(src_pink_TypeMetrics [25]), .align = alignof(src_pink_TypeMetrics [25]), .base = TYPEID(337, TYPE_STRUCT, src_pink_TypeMetrics), .count = 25},
    [339] = NULL, // Func
    [340] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_TypeField), .align = alignof(src_pink_TypeField), .name = "src_pink_TypeField", .num_fields = 3, .fields = (TypeFieldInfo[]) {
        {"name", .type = TYPEID(18, TYPE_PTR, char const (*)), .offset = offsetof(src_pink_TypeField, name)},
        {"type", .type = TYPEID(177, TYPE_PTR, src_pink_Type *), .offset = offsetof(src_pink_TypeField, type)},
        {"offset", .type = TYPEID(13, TYPE_ULLONG, ullong), .offset = offsetof(src_pink_TypeField, offset)},
    }},
    [341] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_TypeAggregate), .align = alignof(src_pink_TypeAggregate), .name = "src_pink_TypeAggregate", .num_fields = 2, .fields = (TypeFieldInfo[]) {
        {"fields", .type = TYPEID(344, TYPE_PTR, src_pink_TypeField *), .offset = offsetof(src_pink_TypeAggregate, fields)},
        {"num_fields", .type = TYPEID(13, TYPE_ULLONG, ullong), .offset = offsetof(src_pink_TypeAggregate, num_fields)},
    }},
    [342] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_TypeFunc), .align = alignof(src_pink_TypeFunc), .name = "src_pink_TypeFunc", .num_fields = 4, .fields = (TypeFieldInfo[]) {
        {"params", .type = TYPEID(345, TYPE_PTR, src_pink_Type (**)), .offset = offsetof(src_pink_TypeFunc, params)},
        {"num_params", .type = TYPEID(13, TYPE_ULLONG, ullong), .offset = offsetof(src_pink_TypeFunc, num_params)},
        {"has_varargs", .type = TYPEID(2, TYPE_BOOL, bool), .offset = offsetof(src_pink_TypeFunc, has_varargs)},
        {"ret", .type = TYPEID(177, TYPE_PTR, src_pink_Type *), .offset = offsetof(src_pink_TypeFunc, ret)},
    }},
    [343] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(337, TYPE_STRUCT, src_pink_TypeMetrics)},
    [344] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(340, TYPE_STRUCT, src_pink_TypeField)},
    [345] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(177, TYPE_PTR, src_pink_Type *)},
    [346] = NULL, // No associated type
    [347] = NULL, // Func
    [348] = NULL, // Func
    [349] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(int [25]), .align = alignof(int [25]), .base = TYPEID(8, TYPE_INT, int), .count = 25},
    [350] = NULL, // Func
    [351] = NULL, // Func
    [352] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_CachedArrayType), .align = alignof(src_pink_CachedArrayType), .name = "src_pink_CachedArrayType", .num_fields = 2, .fields = (TypeFieldInfo[]) {
        {"type", .type = TYPEID(177, TYPE_PTR, src_pink_Type *), .offset = offsetof(src_pink_CachedArrayType, type)},
        {"next", .type = TYPEID(501, TYPE_PTR, src_pink_CachedArrayType *), .offset = offsetof(src_pink_CachedArrayType, next)},
    }},
    [353] = NULL, // Func
    [354] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(src_pink_CachedFuncType), .align = alignof(src_pink_CachedFuncType), .name = "src_pink_CachedFuncType", .num_fields = 2, .fields = (TypeFieldInfo[]) {
        {"type", .type = TYPEID(177, TYPE_PTR, src_pink_Type *), .offset = offsetof(src_pink_CachedFuncType, type)},
        {"next", .type = TYPEID(505, TYPE_PTR, src_pink_CachedFuncType *), .offset = offsetof(src_pink_CachedFuncType, next)},
    }},
    [355] = NULL, // Func
    [356] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(344, TYPE_PTR, src_pink_TypeField *)},
    [357] = NULL, // Func
    [358] = NULL, // Func
    [359] = NULL, // Func
    [360] = NULL, // Func
    [361] = NULL, // Func
    [362] = NULL, // Func
    [363] = NULL, // Func
    [364] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(36, TYPE_STRUCT, old_std_Arena)},
    [365] = NULL, // Func
    [366] = NULL, // Func
    [367] = NULL, // Func
    [368] = NULL, // No associated type
    [369] = NULL, // No associated type
    [370] = NULL, // No associated type
    [371] = NULL, // No associated type
    [372] = NULL, // Func
    [373] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [67]), .align = alignof(char [67]), .base = TYPEID(3, TYPE_CHAR, char), .count = 67},
    [374] = NULL, // Func
    [375] = NULL, // Func
    [376] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(181, TYPE_STRUCT, old_std_Map)},
    [377] = NULL, // Func
    [378] = NULL, // Func
    [379] = NULL, // Func
    [380] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [18]), .align = alignof(char [18]), .base = TYPEID(3, TYPE_CHAR, char), .count = 18},
    [381] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [16]), .align = alignof(char [16]), .base = TYPEID(3, TYPE_CHAR, char), .count = 16},
    [382] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [19]), .align = alignof(char [19]), .base = TYPEID(3, TYPE_CHAR, char), .count = 19},
    [383] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [17]), .align = alignof(char [17]), .base = TYPEID(3, TYPE_CHAR, char), .count = 17},
    [384] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [64]), .align = alignof(char [64]), .base = TYPEID(3, TYPE_CHAR, char), .count = 64},
    [385] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [55]), .align = alignof(char [55]), .base = TYPEID(3, TYPE_CHAR, char), .count = 55},
    [386] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [13]), .align = alignof(char [13]), .base = TYPEID(3, TYPE_CHAR, char), .count = 13},
    [387] = NULL, // Func
    [388] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(16, TYPE_PTR, void *)},
    [389] = NULL, // Func
    [390] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(19, TYPE_PTR, char const ((**)))},
    [391] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [24]), .align = alignof(char [24]), .base = TYPEID(3, TYPE_CHAR, char), .count = 24},
    [392] = NULL, // Func
    [393] = NULL, // Func
    [394] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [35]), .align = alignof(char [35]), .base = TYPEID(3, TYPE_CHAR, char), .count = 35},
    [395] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [37]), .align = alignof(char [37]), .base = TYPEID(3, TYPE_CHAR, char), .count = 37},
    [396] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [38]), .align = alignof(char [38]), .base = TYPEID(3, TYPE_CHAR, char), .count = 38},
    [397] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [57]), .align = alignof(char [57]), .base = TYPEID(3, TYPE_CHAR, char), .count = 57},
    [398] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [31]), .align = alignof(char [31]), .base = TYPEID(3, TYPE_CHAR, char), .count = 31},
    [399] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [77]), .align = alignof(char [77]), .base = TYPEID(3, TYPE_CHAR, char), .count = 77},
    [400] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [80]), .align = alignof(char [80]), .base = TYPEID(3, TYPE_CHAR, char), .count = 80},
    [401] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [83]), .align = alignof(char [83]), .base = TYPEID(3, TYPE_CHAR, char), .count = 83},
    [402] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [74]), .align = alignof(char [74]), .base = TYPEID(3, TYPE_CHAR, char), .count = 74},
    [403] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [63]), .align = alignof(char [63]), .base = TYPEID(3, TYPE_CHAR, char), .count = 63},
    [404] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [81]), .align = alignof(char [81]), .base = TYPEID(3, TYPE_CHAR, char), .count = 81},
    [405] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [50]), .align = alignof(char [50]), .base = TYPEID(3, TYPE_CHAR, char), .count = 50},
    [406] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [14]), .align = alignof(char [14]), .base = TYPEID(3, TYPE_CHAR, char), .count = 14},
    [407] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [72]), .align = alignof(char [72]), .base = TYPEID(3, TYPE_CHAR, char), .count = 72},
    [408] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [114]), .align = alignof(char [114]), .base = TYPEID(3, TYPE_CHAR, char), .count = 114},
    [409] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [28]), .align = alignof(char [28]), .base = TYPEID(3, TYPE_CHAR, char), .count = 28},
    [410] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [39]), .align = alignof(char [39]), .base = TYPEID(3, TYPE_CHAR, char), .count = 39},
    [411] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [20]), .align = alignof(char [20]), .base = TYPEID(3, TYPE_CHAR, char), .count = 20},
    [412] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [21]), .align = alignof(char [21]), .base = TYPEID(3, TYPE_CHAR, char), .count = 21},
    [413] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [23]), .align = alignof(char [23]), .base = TYPEID(3, TYPE_CHAR, char), .count = 23},
    [414] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [15]), .align = alignof(char [15]), .base = TYPEID(3, TYPE_CHAR, char), .count = 15},
    [415] = NULL, // Func
    [416] = NULL, // Func
    [417] = NULL, // Func
    [418] = NULL, // Func
    [419] = NULL, // Func
    [420] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(4, TYPE_UCHAR, uchar)},
    [421] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [36]), .align = alignof(char [36]), .base = TYPEID(3, TYPE_CHAR, char), .count = 36},
    [422] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [25]), .align = alignof(char [25]), .base = TYPEID(3, TYPE_CHAR, char), .count = 25},
    [423] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [33]), .align = alignof(char [33]), .base = TYPEID(3, TYPE_CHAR, char), .count = 33},
    [424] = NULL, // Func
    [425] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [30]), .align = alignof(char [30]), .base = TYPEID(3, TYPE_CHAR, char), .count = 30},
    [426] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [29]), .align = alignof(char [29]), .base = TYPEID(3, TYPE_CHAR, char), .count = 29},
    [427] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [34]), .align = alignof(char [34]), .base = TYPEID(3, TYPE_CHAR, char), .count = 34},
    [428] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [56]), .align = alignof(char [56]), .base = TYPEID(3, TYPE_CHAR, char), .count = 56},
    [429] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [45]), .align = alignof(char [45]), .base = TYPEID(3, TYPE_CHAR, char), .count = 45},
    [430] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(8, TYPE_INT, int)},
    [431] = NULL, // Func
    [432] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [26]), .align = alignof(char [26]), .base = TYPEID(3, TYPE_CHAR, char), .count = 26},
    [433] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [61]), .align = alignof(char [61]), .base = TYPEID(3, TYPE_CHAR, char), .count = 61},
    [434] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [49]), .align = alignof(char [49]), .base = TYPEID(3, TYPE_CHAR, char), .count = 49},
    [435] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(64, TYPE_PTR, src_pink_Typespec (**))},
    [436] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [69]), .align = alignof(char [69]), .base = TYPEID(3, TYPE_CHAR, char), .count = 69},
    [437] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(109, TYPE_PTR, src_pink_CompoundField *)},
    [438] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(112, TYPE_PTR, src_pink_Expr (**))},
    [439] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(52, TYPE_PTR, src_pink_Stmt (**))},
    [440] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(129, TYPE_PTR, src_pink_ElseIf *)},
    [441] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [59]), .align = alignof(char [59]), .base = TYPEID(3, TYPE_CHAR, char), .count = 59},
    [442] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(243, TYPE_PTR, src_pink_SwitchCasePattern *)},
    [443] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [47]), .align = alignof(char [47]), .base = TYPEID(3, TYPE_CHAR, char), .count = 47},
    [444] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(134, TYPE_PTR, src_pink_SwitchCase *)},
    [445] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(77, TYPE_PTR, src_pink_EnumItem *)},
    [446] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(81, TYPE_PTR, src_pink_AggregateItem *)},
    [447] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [42]), .align = alignof(char [42]), .base = TYPEID(3, TYPE_CHAR, char), .count = 42},
    [448] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(88, TYPE_PTR, src_pink_FuncParam *)},
    [449] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [51]), .align = alignof(char [51]), .base = TYPEID(3, TYPE_CHAR, char), .count = 51},
    [450] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(44, TYPE_PTR, src_pink_NoteArg *)},
    [451] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(47, TYPE_PTR, src_pink_Note *)},
    [452] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(93, TYPE_PTR, src_pink_ImportItem *)},
    [453] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(68, TYPE_PTR, src_pink_Decl (**))},
    [454] = NULL, // Func
    [455] = NULL, // Func
    [456] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [99]), .align = alignof(char [99]), .base = TYPEID(3, TYPE_CHAR, char), .count = 99},
    [457] = NULL, // Func
    [458] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [44]), .align = alignof(char [44]), .base = TYPEID(3, TYPE_CHAR, char), .count = 44},
    [459] = NULL, // Func
    [460] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(2, TYPE_BOOL, bool)},
    [461] = NULL, // Func
    [462] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [52]), .align = alignof(char [52]), .base = TYPEID(3, TYPE_CHAR, char), .count = 52},
    [463] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [58]), .align = alignof(char [58]), .base = TYPEID(3, TYPE_CHAR, char), .count = 58},
    [464] = NULL, // Func
    [465] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [54]), .align = alignof(char [54]), .base = TYPEID(3, TYPE_CHAR, char), .count = 54},
    [466] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [48]), .align = alignof(char [48]), .base = TYPEID(3, TYPE_CHAR, char), .count = 48},
    [467] = NULL, // Func
    [468] = NULL, // Func
    [469] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(262, TYPE_PTR, src_pink_Package (**))},
    [470] = NULL, // Func
    [471] = NULL, // Func
    [472] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(265, TYPE_PTR, src_pink_Sym (**))},
    [473] = NULL, // Func
    [474] = NULL, // Func
    [475] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [22]), .align = alignof(char [22]), .base = TYPEID(3, TYPE_CHAR, char), .count = 22},
    [476] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(345, TYPE_PTR, src_pink_Type (**))},
    [477] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [41]), .align = alignof(char [41]), .base = TYPEID(3, TYPE_CHAR, char), .count = 41},
    [478] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [53]), .align = alignof(char [53]), .base = TYPEID(3, TYPE_CHAR, char), .count = 53},
    [479] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(100, TYPE_NONE, src_pink_TokenKind)},
    [480] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [32]), .align = alignof(char [32]), .base = TYPEID(3, TYPE_CHAR, char), .count = 32},
    [481] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [27]), .align = alignof(char [27]), .base = TYPEID(3, TYPE_CHAR, char), .count = 27},
    [482] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [60]), .align = alignof(char [60]), .base = TYPEID(3, TYPE_CHAR, char), .count = 60},
    [483] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [46]), .align = alignof(char [46]), .base = TYPEID(3, TYPE_CHAR, char), .count = 46},
    [484] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [43]), .align = alignof(char [43]), .base = TYPEID(3, TYPE_CHAR, char), .count = 43},
    [485] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [100]), .align = alignof(char [100]), .base = TYPEID(3, TYPE_CHAR, char), .count = 100},
    [486] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [68]), .align = alignof(char [68]), .base = TYPEID(3, TYPE_CHAR, char), .count = 68},
    [487] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [73]), .align = alignof(char [73]), .base = TYPEID(3, TYPE_CHAR, char), .count = 73},
    [488] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [70]), .align = alignof(char [70]), .base = TYPEID(3, TYPE_CHAR, char), .count = 70},
    [489] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [66]), .align = alignof(char [66]), .base = TYPEID(3, TYPE_CHAR, char), .count = 66},
    [490] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [92]), .align = alignof(char [92]), .base = TYPEID(3, TYPE_CHAR, char), .count = 92},
    [491] = NULL, // Func
    [492] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(old_std_os_DirListIter), .align = alignof(old_std_os_DirListIter), .name = "old_std_os_DirListIter", .num_fields = 7, .fields = (TypeFieldInfo[]) {
        {"valid", .type = TYPEID(2, TYPE_BOOL, bool), .offset = offsetof(old_std_os_DirListIter, valid)},
        {"error", .type = TYPEID(2, TYPE_BOOL, bool), .offset = offsetof(old_std_os_DirListIter, error)},
        {"base", .type = TYPEID(171, TYPE_ARRAY, char [256]), .offset = offsetof(old_std_os_DirListIter, base)},
        {"name", .type = TYPEID(171, TYPE_ARRAY, char [256]), .offset = offsetof(old_std_os_DirListIter, name)},
        {"size", .type = TYPEID(13, TYPE_ULLONG, ullong), .offset = offsetof(old_std_os_DirListIter, size)},
        {"is_dir", .type = TYPEID(2, TYPE_BOOL, bool), .offset = offsetof(old_std_os_DirListIter, is_dir)},
        {"handle", .type = TYPEID(16, TYPE_PTR, void *), .offset = offsetof(old_std_os_DirListIter, handle)},
    }},
    [493] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(492, TYPE_STRUCT, old_std_os_DirListIter)},
    [494] = NULL, // Func
    [495] = NULL, // Func
    [496] = NULL, // Func
    [497] = NULL, // Func
    [498] = NULL, // Func
    [499] = NULL, // Func
    [500] = &(TypeInfo){TYPE_ARRAY, .size = sizeof(char [40]), .align = alignof(char [40]), .base = TYPEID(3, TYPE_CHAR, char), .count = 40},
    [501] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(352, TYPE_STRUCT, src_pink_CachedArrayType)},
    [502] = NULL, // Func
    [503] = NULL, // Func
    [504] = NULL, // Func
    [505] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(354, TYPE_STRUCT, src_pink_CachedFuncType)},
    [506] = NULL, // Func
    [507] = NULL, // Func
    [508] = NULL, // Func
    [509] = NULL, // Func
    [510] = NULL, // Func
    [511] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(old_std_BufHdr), .align = alignof(old_std_BufHdr), .name = "old_std_BufHdr", .num_fields = 3, .fields = (TypeFieldInfo[]) {
        {"len", .type = TYPEID(13, TYPE_ULLONG, ullong), .offset = offsetof(old_std_BufHdr, len)},
        {"cap", .type = TYPEID(13, TYPE_ULLONG, ullong), .offset = offsetof(old_std_BufHdr, cap)},
        {"buf", .type = TYPEID(213, TYPE_ARRAY, char [1]), .offset = offsetof(old_std_BufHdr, buf)},
    }},
    [512] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(511, TYPE_STRUCT, old_std_BufHdr)},
    [513] = NULL, // Func
    [514] = NULL, // Func
    [515] = NULL, // Func
    [516] = NULL, // Func
    [517] = NULL, // Func
    [518] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(old_std_Intern), .align = alignof(old_std_Intern), .name = "old_std_Intern", .num_fields = 3, .fields = (TypeFieldInfo[]) {
        {"len", .type = TYPEID(13, TYPE_ULLONG, ullong), .offset = offsetof(old_std_Intern, len)},
        {"next", .type = TYPEID(519, TYPE_PTR, old_std_Intern *), .offset = offsetof(old_std_Intern, next)},
        {"str", .type = TYPEID(213, TYPE_ARRAY, char [1]), .offset = offsetof(old_std_Intern, str)},
    }},
    [519] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(518, TYPE_STRUCT, old_std_Intern)},
    [520] = NULL, // Func
    [521] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(old_std_os_FlagDef), .align = alignof(old_std_os_FlagDef), .name = "old_std_os_FlagDef", .num_fields = 7, .fields = (TypeFieldInfo[]) {
        {"kind", .type = TYPEID(522, TYPE_NONE, old_std_os_FlagKind), .offset = offsetof(old_std_os_FlagDef, kind)},
        {"name", .type = TYPEID(18, TYPE_PTR, char const (*)), .offset = offsetof(old_std_os_FlagDef, name)},
        {"help", .type = TYPEID(18, TYPE_PTR, char const (*)), .offset = offsetof(old_std_os_FlagDef, help)},
        {"options", .type = TYPEID(19, TYPE_PTR, char const ((**))), .offset = offsetof(old_std_os_FlagDef, options)},
        {"arg_name", .type = TYPEID(18, TYPE_PTR, char const (*)), .offset = offsetof(old_std_os_FlagDef, arg_name)},
        {"num_options", .type = TYPEID(8, TYPE_INT, int), .offset = offsetof(old_std_os_FlagDef, num_options)},
        {"ptr", .type = TYPEID(523, TYPE_STRUCT, old_std_os_FlagDefPtr), .offset = offsetof(old_std_os_FlagDef, ptr)},
    }},
    [522] = NULL, // Enum
    [523] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(old_std_os_FlagDefPtr), .align = alignof(old_std_os_FlagDefPtr), .name = "old_std_os_FlagDefPtr", .num_fields = 3, .fields = (TypeFieldInfo[]) {
        {"i", .type = TYPEID(430, TYPE_PTR, int *), .offset = offsetof(old_std_os_FlagDefPtr, i)},
        {"b", .type = TYPEID(460, TYPE_PTR, bool *), .offset = offsetof(old_std_os_FlagDefPtr, b)},
        {"s", .type = TYPEID(19, TYPE_PTR, char const ((**))), .offset = offsetof(old_std_os_FlagDefPtr, s)},
    }},
    [524] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(521, TYPE_STRUCT, old_std_os_FlagDef)},
    [525] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(524, TYPE_PTR, old_std_os_FlagDef *)},
    [526] = NULL, // Func
    [527] = NULL, // Incomplete: FILE
    [528] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID0(527, TYPE_NONE)},
    [529] = NULL, // Func
    [530] = NULL, // Func
    [531] = NULL, // Func
    [532] = &(TypeInfo){TYPE_STRUCT, .size = sizeof(FindData), .align = alignof(FindData), .name = "FindData", .num_fields = 3, .fields = (TypeFieldInfo[]) {
        {"attrib", .type = TYPEID(9, TYPE_UINT, uint), .offset = offsetof(FindData, attrib)},
        {"size", .type = TYPEID(9, TYPE_UINT, uint), .offset = offsetof(FindData, size)},
        {"name", .type = TYPEID(171, TYPE_ARRAY, char [256]), .offset = offsetof(FindData, name)},
    }},
    [533] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(532, TYPE_STRUCT, FindData)},
    [534] = NULL, // Func
    [535] = NULL, // Func
    [536] = NULL, // Func
    [537] = NULL, // Func
    [538] = NULL, // Func
    [539] = NULL, // Func
    [540] = NULL, // Func
    [541] = NULL, // Func
    [542] = NULL, // Func
    [543] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(37, TYPE_PTR, char (**))},
    [544] = NULL, // Func
    [545] = NULL, // Func
    [546] = NULL, // Func
    [547] = NULL, // Func
    [548] = NULL, // Func
    [549] = NULL, // Func
    [550] = NULL, // Func
    [551] = NULL, // Func
    [552] = NULL, // Func
    [553] = NULL, // Func
    [554] = NULL, // Func
    [555] = NULL, // Func
    [556] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(14, TYPE_FLOAT, float)},
    [557] = NULL, // Func
    [558] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(15, TYPE_DOUBLE, double)},
    [559] = NULL, // Func
    [560] = NULL, // Func
    [561] = NULL, // Func
    [562] = NULL, // Func
    [563] = NULL, // Func
    [564] = NULL, // Func
    [565] = NULL, // Func
    [566] = NULL, // Func
    [567] = NULL, // Func
    [568] = NULL, // Func
    [569] = NULL, // Func
    [570] = NULL, // Func
    [571] = NULL, // Func
    [572] = NULL, // Func
    [573] = &(TypeInfo){TYPE_CONST, .size = sizeof(char (*const )), .align = alignof(char (*const )), .base = TYPEID(22, TYPE_PTR, char *)},
    [574] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(573, TYPE_CONST, char (*const ))},
    [575] = NULL, // Func
    [576] = NULL, // No associated type
    [577] = NULL, // Func
    [578] = NULL, // Func
    [579] = NULL, // Func
    [580] = NULL, // Func
    [581] = NULL, // Func
    [582] = NULL, // Func
    [583] = NULL, // Func
    [584] = NULL, // Func
    [585] = NULL, // Func
    [586] = NULL, // Func
    [587] = NULL, // Func
    [588] = NULL, // Func
    [589] = NULL, // Func
    [590] = NULL, // Func
    [591] = NULL, // No associated type
    [592] = NULL, // Func
    [593] = NULL, // Func
    [594] = NULL, // No associated type
    [595] = NULL, // No associated type
    [596] = NULL, // No associated type
    [597] = NULL, // Func
    [598] = NULL, // Func
    [599] = NULL, // Func
    [600] = NULL, // Func
    [601] = NULL, // Func
    [602] = NULL, // Func
    [603] = NULL, // Func
    [604] = NULL, // Func
    [605] = NULL, // Func
    [606] = NULL, // Func
    [607] = NULL, // Func
    [608] = NULL, // Func
    [609] = NULL, // Func
    [610] = NULL, // Func
    [611] = NULL, // Func
    [612] = NULL, // Func
    [613] = NULL, // Func
    [614] = NULL, // Func
    [615] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(6, TYPE_SHORT, short)},
    [616] = NULL, // Func
    [617] = NULL, // Func
    [618] = NULL, // Func
    [619] = &(TypeInfo){TYPE_CONST, .size = sizeof(short const ), .align = alignof(short const ), .base = TYPEID(6, TYPE_SHORT, short)},
    [620] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(619, TYPE_CONST, short const )},
    [621] = NULL, // Func
    [622] = NULL, // Func
    [623] = NULL, // Func
    [624] = NULL, // Func
    [625] = NULL, // Func
    [626] = NULL, // Func
    [627] = NULL, // Func
    [628] = NULL, // No associated type
    [629] = NULL, // Func
    [630] = NULL, // Func
    [631] = NULL, // No associated type
    [632] = NULL, // Func
    [633] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(12, TYPE_LLONG, llong)},
    [634] = NULL, // Func
    [635] = NULL, // No associated type
    [636] = NULL, // No associated type
    [637] = NULL, // Func
    [638] = &(TypeInfo){TYPE_CONST, .size = sizeof(llong const ), .align = alignof(llong const ), .base = TYPEID(12, TYPE_LLONG, llong)},
    [639] = &(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = TYPEID(638, TYPE_CONST, llong const )},
    [640] = NULL, // Func
    [641] = NULL, // Func
    [642] = NULL, // Func
    [643] = NULL, // Func
    [644] = NULL, // Func
    [645] = NULL, // Func
};

int num_typeinfos = 646;
const TypeInfo **typeinfos = (const TypeInfo **)typeinfo_table;

// Definitions
int main(int argc, char const ((*(*argv)))) {
    src_pink_pink_entry(argc, argv, src_pink_gen_all, "c");
    return 0;
}

char const ((*current_os)) = "windows";
char const ((*current_arch)) = "x64";
TypeKind typeid_kind(typeid type) {
    return (TypeKind)((((type) >> (24))) & (0xff));
}

int typeid_index(typeid type) {
    return (int)((type) & (0xffffff));
}

size_t typeid_size(typeid type) {
    return (size_t)((type) >> (32));
}

TypeInfo const ((*get_typeinfo(typeid type))) {
    int index = typeid_index(type);
    if ((typeinfos) && ((index) < (num_typeinfos))) {
        return typeinfos[index];
    } else {
        return NULL;
    }
}

old_std_Arena src_pink_ast_arena;
void (*src_pink_ast_alloc(size_t size)) {
    void (*ptr) = old_std_arena_alloc(&(src_pink_ast_arena), size);
    memset(ptr, 0, size);
    return ptr;
}

void (*src_pink_ast_dup(void const ((*src)), size_t size)) {
    if ((size) == (0)) {
        return NULL;
    }
    void (*ptr) = old_std_arena_alloc(&(src_pink_ast_arena), size);
    memcpy(ptr, src, size);
    return ptr;
}

src_pink_Note src_pink_new_note(src_pink_SrcPos pos, char const ((*name)), src_pink_NoteArg (*args), size_t num_args) {
    return (src_pink_Note){.pos = pos, .name = name, .args = src_pink_ast_dup(args, (num_args) * (sizeof(*(args)))), .num_args = num_args};
}

src_pink_Notes src_pink_new_notes(src_pink_Note (*notes), size_t num_notes) {
    return (src_pink_Notes){src_pink_ast_dup(notes, (num_notes) * (sizeof(*(notes)))), num_notes};
}

src_pink_StmtList src_pink_new_stmt_list(src_pink_SrcPos pos, src_pink_Stmt (*(*stmts)), size_t num_stmts) {
    return (src_pink_StmtList){pos, src_pink_ast_dup(stmts, (num_stmts) * (sizeof(*(stmts)))), num_stmts};
}

src_pink_Typespec (*src_pink_new_typespec(src_pink_TypespecKind kind, src_pink_SrcPos pos)) {
    src_pink_Typespec (*t) = src_pink_ast_alloc(sizeof(src_pink_Typespec));
    t->kind = kind;
    t->pos = pos;
    return t;
}

src_pink_Typespec (*src_pink_new_typespec_name(src_pink_SrcPos pos, char const ((*name)))) {
    src_pink_Typespec (*t) = src_pink_new_typespec(SRC_PINK_TYPESPEC_NAME, pos);
    t->name = name;
    return t;
}

src_pink_Typespec (*src_pink_new_typespec_ptr(src_pink_SrcPos pos, src_pink_Typespec (*base))) {
    src_pink_Typespec (*t) = src_pink_new_typespec(SRC_PINK_TYPESPEC_PTR, pos);
    t->base = base;
    return t;
}

src_pink_Typespec (*src_pink_new_typespec_const(src_pink_SrcPos pos, src_pink_Typespec (*base))) {
    src_pink_Typespec (*t) = src_pink_new_typespec(SRC_PINK_TYPESPEC_CONST, pos);
    t->base = base;
    return t;
}

src_pink_Typespec (*src_pink_new_typespec_array(src_pink_SrcPos pos, src_pink_Typespec (*elem), src_pink_Expr (*size))) {
    src_pink_Typespec (*t) = src_pink_new_typespec(SRC_PINK_TYPESPEC_ARRAY, pos);
    t->base = elem;
    t->num_elems = size;
    return t;
}

src_pink_Typespec (*src_pink_new_typespec_func(src_pink_SrcPos pos, src_pink_Typespec (*(*args)), size_t num_args, src_pink_Typespec (*ret), bool has_varargs)) {
    src_pink_Typespec (*t) = src_pink_new_typespec(SRC_PINK_TYPESPEC_FUNC, pos);
    t->function.args = src_pink_ast_dup(args, (num_args) * (sizeof(*(args))));
    t->function.num_args = num_args;
    t->function.ret = ret;
    t->function.has_varargs = has_varargs;
    return t;
}

src_pink_Decls (*src_pink_new_decls(src_pink_Decl (*(*decls)), size_t num_decls)) {
    src_pink_Decls (*d) = src_pink_ast_alloc(sizeof(src_pink_Decls));
    d->decls = src_pink_ast_dup(decls, (num_decls) * (sizeof(*(decls))));
    d->num_decls = num_decls;
    return d;
}

src_pink_Decl (*src_pink_new_decl(src_pink_DeclKind kind, src_pink_SrcPos pos, char const ((*name)))) {
    src_pink_Decl (*d) = src_pink_ast_alloc(sizeof(src_pink_Decl));
    d->kind = kind;
    d->pos = pos;
    d->name = name;
    return d;
}

src_pink_Note (*src_pink_get_decl_note(src_pink_Decl (*decl), char const ((*name)))) {
    for (size_t i = 0; (i) < (decl->notes.num_notes); (i)++) {
        src_pink_Note (*note) = (decl->notes.notes) + (i);
        if ((note->name) == (name)) {
            return note;
        }
    }
    return NULL;
}

bool src_pink_is_decl_foreign(src_pink_Decl (*decl)) {
    return (src_pink_get_decl_note(decl, src_pink_foreign_name)) != (NULL);
}

src_pink_Decl (*src_pink_new_decl_enum(src_pink_SrcPos pos, char const ((*name)), src_pink_Typespec (*type), src_pink_EnumItem (*items), size_t num_items)) {
    src_pink_Decl (*d) = src_pink_new_decl(SRC_PINK_DECL_ENUM, pos, name);
    d->enum_decl.type = type;
    d->enum_decl.items = src_pink_ast_dup(items, (num_items) * (sizeof(*(items))));
    d->enum_decl.num_items = num_items;
    return d;
}

src_pink_Aggregate (*src_pink_new_aggregate(src_pink_SrcPos pos, src_pink_AggregateKind kind, src_pink_AggregateItem (*items), size_t num_items)) {
    src_pink_Aggregate (*aggregate) = src_pink_ast_alloc(sizeof(src_pink_Aggregate));
    aggregate->pos = pos;
    aggregate->kind = kind;
    aggregate->items = src_pink_ast_dup(items, (num_items) * (sizeof(*(items))));
    aggregate->num_items = num_items;
    return aggregate;
}

src_pink_Decl (*src_pink_new_decl_aggregate(src_pink_SrcPos pos, src_pink_DeclKind kind, char const ((*name)), src_pink_Aggregate (*aggregate))) {
    src_pink_Decl (*d) = src_pink_new_decl(kind, pos, name);
    d->aggregate = aggregate;
    return d;
}

src_pink_Decl (*src_pink_new_decl_var(src_pink_SrcPos pos, char const ((*name)), src_pink_Typespec (*type), src_pink_Expr (*expr))) {
    src_pink_Decl (*d) = src_pink_new_decl(SRC_PINK_DECL_VAR, pos, name);
    d->var_decl.type = type;
    d->var_decl.expr = expr;
    return d;
}

src_pink_Decl (*src_pink_new_decl_func(src_pink_SrcPos pos, char const ((*name)), src_pink_FuncParam (*params), size_t num_params, src_pink_Typespec (*ret_type), bool has_varargs, src_pink_StmtList block)) {
    src_pink_Decl (*d) = src_pink_new_decl(SRC_PINK_DECL_FUNC, pos, name);
    d->function.params = src_pink_ast_dup(params, (num_params) * (sizeof(*(params))));
    d->function.num_params = num_params;
    d->function.ret_type = ret_type;
    d->function.has_varargs = has_varargs;
    d->function.block = block;
    return d;
}

src_pink_Decl (*src_pink_new_decl_const(src_pink_SrcPos pos, char const ((*name)), src_pink_Typespec (*type), src_pink_Expr (*expr))) {
    src_pink_Decl (*d) = src_pink_new_decl(SRC_PINK_DECL_CONST, pos, name);
    d->const_decl.type = type;
    d->const_decl.expr = expr;
    return d;
}

src_pink_Decl (*src_pink_new_decl_typedef(src_pink_SrcPos pos, char const ((*name)), src_pink_Typespec (*type))) {
    src_pink_Decl (*d) = src_pink_new_decl(SRC_PINK_DECL_TYPEDEF, pos, name);
    d->typedef_decl.type = type;
    return d;
}

src_pink_Decl (*src_pink_new_decl_note(src_pink_SrcPos pos, src_pink_Note note)) {
    src_pink_Decl (*d) = src_pink_new_decl(SRC_PINK_DECL_NOTE, pos, NULL);
    d->note = note;
    return d;
}

src_pink_Decl (*src_pink_new_decl_import(src_pink_SrcPos pos, char const ((*rename_name)), bool is_relative, char const ((*(*names))), size_t num_names, bool import_all, src_pink_ImportItem (*items), size_t num_items)) {
    src_pink_Decl (*d) = src_pink_new_decl(SRC_PINK_DECL_IMPORT, pos, NULL);
    d->name = rename_name;
    d->import_decl.is_relative = is_relative;
    d->import_decl.names = src_pink_ast_dup(names, (num_names) * (sizeof(*(names))));
    d->import_decl.num_names = num_names;
    d->import_decl.import_all = import_all;
    d->import_decl.items = src_pink_ast_dup(items, (num_items) * (sizeof(*(items))));
    d->import_decl.num_items = num_items;
    return d;
}

src_pink_Expr (*src_pink_new_expr(src_pink_ExprKind kind, src_pink_SrcPos pos)) {
    src_pink_Expr (*e) = src_pink_ast_alloc(sizeof(src_pink_Expr));
    e->kind = kind;
    e->pos = pos;
    return e;
}

src_pink_Expr (*src_pink_new_expr_paren(src_pink_SrcPos pos, src_pink_Expr (*expr))) {
    src_pink_Expr (*e) = src_pink_new_expr(SRC_PINK_EXPR_PAREN, pos);
    e->paren.expr = expr;
    return e;
}

src_pink_Expr (*src_pink_new_expr_sizeof_expr(src_pink_SrcPos pos, src_pink_Expr (*expr))) {
    src_pink_Expr (*e) = src_pink_new_expr(SRC_PINK_EXPR_SIZEOF_EXPR, pos);
    e->sizeof_expr = expr;
    return e;
}

src_pink_Expr (*src_pink_new_expr_sizeof_type(src_pink_SrcPos pos, src_pink_Typespec (*type))) {
    src_pink_Expr (*e) = src_pink_new_expr(SRC_PINK_EXPR_SIZEOF_TYPE, pos);
    e->sizeof_type = type;
    return e;
}

src_pink_Expr (*src_pink_new_expr_typeof_expr(src_pink_SrcPos pos, src_pink_Expr (*expr))) {
    src_pink_Expr (*e) = src_pink_new_expr(SRC_PINK_EXPR_TYPEOF_EXPR, pos);
    e->typeof_expr = expr;
    return e;
}

src_pink_Expr (*src_pink_new_expr_typeof_type(src_pink_SrcPos pos, src_pink_Typespec (*type))) {
    src_pink_Expr (*e) = src_pink_new_expr(SRC_PINK_EXPR_TYPEOF_TYPE, pos);
    e->typeof_type = type;
    return e;
}

src_pink_Expr (*src_pink_new_expr_alignof_expr(src_pink_SrcPos pos, src_pink_Expr (*expr))) {
    src_pink_Expr (*e) = src_pink_new_expr(SRC_PINK_EXPR_ALIGNOF_EXPR, pos);
    e->alignof_expr = expr;
    return e;
}

src_pink_Expr (*src_pink_new_expr_alignof_type(src_pink_SrcPos pos, src_pink_Typespec (*type))) {
    src_pink_Expr (*e) = src_pink_new_expr(SRC_PINK_EXPR_ALIGNOF_TYPE, pos);
    e->alignof_type = type;
    return e;
}

src_pink_Expr (*src_pink_new_expr_offsetof(src_pink_SrcPos pos, src_pink_Typespec (*type), char const ((*name)))) {
    src_pink_Expr (*e) = src_pink_new_expr(SRC_PINK_EXPR_OFFSETOF, pos);
    e->offsetof_field.type = type;
    e->offsetof_field.name = name;
    return e;
}

src_pink_Expr (*src_pink_new_expr_modify(src_pink_SrcPos pos, src_pink_TokenKind op, bool post, src_pink_Expr (*expr))) {
    src_pink_Expr (*e) = src_pink_new_expr(SRC_PINK_EXPR_MODIFY, pos);
    e->modify.op = op;
    e->modify.post = post;
    e->modify.expr = expr;
    return e;
}

src_pink_Expr (*src_pink_new_expr_int(src_pink_SrcPos pos, ullong val, src_pink_TokenMod mod, src_pink_TokenSuffix suffix)) {
    src_pink_Expr (*e) = src_pink_new_expr(SRC_PINK_EXPR_INT, pos);
    e->int_lit.val = val;
    e->int_lit.mod = mod;
    e->int_lit.suffix = suffix;
    return e;
}

src_pink_Expr (*src_pink_new_expr_float(src_pink_SrcPos pos, char const ((*start)), char const ((*end)), double val, src_pink_TokenSuffix suffix)) {
    src_pink_Expr (*e) = src_pink_new_expr(SRC_PINK_EXPR_FLOAT, pos);
    e->float_lit.start = start;
    e->float_lit.end = end;
    e->float_lit.val = val;
    e->float_lit.suffix = suffix;
    return e;
}

src_pink_Expr (*src_pink_new_expr_str(src_pink_SrcPos pos, char const ((*val)), src_pink_TokenMod mod)) {
    src_pink_Expr (*e) = src_pink_new_expr(SRC_PINK_EXPR_STR, pos);
    e->str_lit.val = val;
    e->str_lit.mod = mod;
    return e;
}

src_pink_Expr (*src_pink_new_expr_name(src_pink_SrcPos pos, char const ((*name)))) {
    src_pink_Expr (*e) = src_pink_new_expr(SRC_PINK_EXPR_NAME, pos);
    e->name = name;
    return e;
}

src_pink_Expr (*src_pink_new_expr_compound(src_pink_SrcPos pos, src_pink_Typespec (*type), src_pink_CompoundField (*fields), size_t num_fields)) {
    src_pink_Expr (*e) = src_pink_new_expr(SRC_PINK_EXPR_COMPOUND, pos);
    e->compound.type = type;
    e->compound.fields = src_pink_ast_dup(fields, (num_fields) * (sizeof(*(fields))));
    e->compound.num_fields = num_fields;
    return e;
}

src_pink_Expr (*src_pink_new_expr_cast(src_pink_SrcPos pos, src_pink_Typespec (*type), src_pink_Expr (*expr))) {
    src_pink_Expr (*e) = src_pink_new_expr(SRC_PINK_EXPR_CAST, pos);
    e->cast.type = type;
    e->cast.expr = expr;
    return e;
}

src_pink_Expr (*src_pink_new_expr_call(src_pink_SrcPos pos, src_pink_Expr (*expr), src_pink_Expr (*(*args)), size_t num_args)) {
    src_pink_Expr (*e) = src_pink_new_expr(SRC_PINK_EXPR_CALL, pos);
    e->call.expr = expr;
    e->call.args = src_pink_ast_dup(args, (num_args) * (sizeof(*(args))));
    e->call.num_args = num_args;
    return e;
}

src_pink_Expr (*src_pink_new_expr_index(src_pink_SrcPos pos, src_pink_Expr (*expr), src_pink_Expr (*index))) {
    src_pink_Expr (*e) = src_pink_new_expr(SRC_PINK_EXPR_INDEX, pos);
    e->index.expr = expr;
    e->index.index = index;
    return e;
}

src_pink_Expr (*src_pink_new_expr_field(src_pink_SrcPos pos, src_pink_Expr (*expr), char const ((*name)))) {
    src_pink_Expr (*e) = src_pink_new_expr(SRC_PINK_EXPR_FIELD, pos);
    e->field.expr = expr;
    e->field.name = name;
    return e;
}

src_pink_Expr (*src_pink_new_expr_unary(src_pink_SrcPos pos, src_pink_TokenKind op, src_pink_Expr (*expr))) {
    src_pink_Expr (*e) = src_pink_new_expr(SRC_PINK_EXPR_UNARY, pos);
    e->unary.op = op;
    e->unary.expr = expr;
    return e;
}

src_pink_Expr (*src_pink_new_expr_binary(src_pink_SrcPos pos, src_pink_TokenKind op, src_pink_Expr (*left), src_pink_Expr (*right))) {
    src_pink_Expr (*e) = src_pink_new_expr(SRC_PINK_EXPR_BINARY, pos);
    e->binary.op = op;
    e->binary.left = left;
    e->binary.right = right;
    return e;
}

src_pink_Expr (*src_pink_new_expr_ternary(src_pink_SrcPos pos, src_pink_Expr (*cond), src_pink_Expr (*then_expr), src_pink_Expr (*else_expr))) {
    src_pink_Expr (*e) = src_pink_new_expr(SRC_PINK_EXPR_TERNARY, pos);
    e->ternary.cond = cond;
    e->ternary.then_expr = then_expr;
    e->ternary.else_expr = else_expr;
    return e;
}

src_pink_Note (*src_pink_get_stmt_note(src_pink_Stmt (*stmt), char const ((*name)))) {
    for (size_t i = 0; (i) < (stmt->notes.num_notes); (i)++) {
        src_pink_Note (*note) = (stmt->notes.notes) + (i);
        if ((note->name) == (name)) {
            return note;
        }
    }
    return NULL;
}

src_pink_Stmt (*src_pink_new_stmt(src_pink_StmtKind kind, src_pink_SrcPos pos)) {
    src_pink_Stmt (*s) = src_pink_ast_alloc(sizeof(src_pink_Stmt));
    s->kind = kind;
    s->pos = pos;
    return s;
}

src_pink_Stmt (*src_pink_new_stmt_label(src_pink_SrcPos pos, char const ((*label)))) {
    src_pink_Stmt (*s) = src_pink_new_stmt(SRC_PINK_STMT_LABEL, pos);
    s->label = label;
    return s;
}

src_pink_Stmt (*src_pink_new_stmt_goto(src_pink_SrcPos pos, char const ((*label)))) {
    src_pink_Stmt (*s) = src_pink_new_stmt(SRC_PINK_STMT_GOTO, pos);
    s->label = label;
    return s;
}

src_pink_Stmt (*src_pink_new_stmt_note(src_pink_SrcPos pos, src_pink_Note note)) {
    src_pink_Stmt (*s) = src_pink_new_stmt(SRC_PINK_STMT_NOTE, pos);
    s->note = note;
    return s;
}

src_pink_Stmt (*src_pink_new_stmt_decl(src_pink_SrcPos pos, src_pink_Decl (*decl))) {
    src_pink_Stmt (*s) = src_pink_new_stmt(SRC_PINK_STMT_DECL, pos);
    s->decl = decl;
    return s;
}

src_pink_Stmt (*src_pink_new_stmt_return(src_pink_SrcPos pos, src_pink_Expr (*expr))) {
    src_pink_Stmt (*s) = src_pink_new_stmt(SRC_PINK_STMT_RETURN, pos);
    s->expr = expr;
    return s;
}

src_pink_Stmt (*src_pink_new_stmt_break(src_pink_SrcPos pos)) {
    return src_pink_new_stmt(SRC_PINK_STMT_BREAK, pos);
}

src_pink_Stmt (*src_pink_new_stmt_continue(src_pink_SrcPos pos)) {
    return src_pink_new_stmt(SRC_PINK_STMT_CONTINUE, pos);
}

src_pink_Stmt (*src_pink_new_stmt_block(src_pink_SrcPos pos, src_pink_StmtList block)) {
    src_pink_Stmt (*s) = src_pink_new_stmt(SRC_PINK_STMT_BLOCK, pos);
    s->block = block;
    return s;
}

src_pink_Stmt (*src_pink_new_stmt_if(src_pink_SrcPos pos, src_pink_Stmt (*init), src_pink_Expr (*cond), src_pink_StmtList then_block, src_pink_ElseIf (*elseifs), size_t num_elseifs, src_pink_StmtList else_block)) {
    src_pink_Stmt (*s) = src_pink_new_stmt(SRC_PINK_STMT_IF, pos);
    s->if_stmt.init = init;
    s->if_stmt.cond = cond;
    s->if_stmt.then_block = then_block;
    s->if_stmt.elseifs = src_pink_ast_dup(elseifs, (num_elseifs) * (sizeof(*(elseifs))));
    s->if_stmt.num_elseifs = num_elseifs;
    s->if_stmt.else_block = else_block;
    return s;
}

src_pink_Stmt (*src_pink_new_stmt_while(src_pink_SrcPos pos, src_pink_Expr (*cond), src_pink_StmtList block)) {
    src_pink_Stmt (*s) = src_pink_new_stmt(SRC_PINK_STMT_WHILE, pos);
    s->while_stmt.cond = cond;
    s->while_stmt.block = block;
    return s;
}

src_pink_Stmt (*src_pink_new_stmt_do_while(src_pink_SrcPos pos, src_pink_Expr (*cond), src_pink_StmtList block)) {
    src_pink_Stmt (*s) = src_pink_new_stmt(SRC_PINK_STMT_DO_WHILE, pos);
    s->while_stmt.cond = cond;
    s->while_stmt.block = block;
    return s;
}

src_pink_Stmt (*src_pink_new_stmt_for(src_pink_SrcPos pos, src_pink_Stmt (*init), src_pink_Expr (*cond), src_pink_Stmt (*next), src_pink_StmtList block)) {
    src_pink_Stmt (*s) = src_pink_new_stmt(SRC_PINK_STMT_FOR, pos);
    s->for_stmt.init = init;
    s->for_stmt.cond = cond;
    s->for_stmt.next = next;
    s->for_stmt.block = block;
    return s;
}

src_pink_Stmt (*src_pink_new_stmt_switch(src_pink_SrcPos pos, src_pink_Expr (*expr), src_pink_SwitchCase (*cases), size_t num_cases)) {
    src_pink_Stmt (*s) = src_pink_new_stmt(SRC_PINK_STMT_SWITCH, pos);
    s->switch_stmt.expr = expr;
    s->switch_stmt.cases = src_pink_ast_dup(cases, (num_cases) * (sizeof(*(cases))));
    s->switch_stmt.num_cases = num_cases;
    return s;
}

src_pink_Stmt (*src_pink_new_stmt_assign(src_pink_SrcPos pos, src_pink_TokenKind op, src_pink_Expr (*left), src_pink_Expr (*right))) {
    src_pink_Stmt (*s) = src_pink_new_stmt(SRC_PINK_STMT_ASSIGN, pos);
    s->assign.op = op;
    s->assign.left = left;
    s->assign.right = right;
    return s;
}

src_pink_Stmt (*src_pink_new_stmt_init(src_pink_SrcPos pos, char const ((*name)), src_pink_Typespec (*type), src_pink_Expr (*expr))) {
    src_pink_Stmt (*s) = src_pink_new_stmt(SRC_PINK_STMT_INIT, pos);
    s->init.name = name;
    s->init.type = type;
    s->init.expr = expr;
    return s;
}

src_pink_Stmt (*src_pink_new_stmt_expr(src_pink_SrcPos pos, src_pink_Expr (*expr))) {
    src_pink_Stmt (*s) = src_pink_new_stmt(SRC_PINK_STMT_EXPR, pos);
    s->expr = expr;
    return s;
}

char (*src_pink_gen_buf) = NULL;
int src_pink_gen_indent;
src_pink_SrcPos src_pink_gen_pos;
char const ((*(*src_pink_gen_headers_buf)));
char (*src_pink_gen_preamble_str) = 
    "// Generated by Pink\n"
    "\n"
    "#define __USE_MINGW_ANSI_STDIO 1\n"
    "#ifndef _CRT_SECURE_NO_WARNINGS\n"
    "#define _CRT_SECURE_NO_WARNINGS\n"
    "#endif\n"
    "#ifndef _CRT_NONSTDC_NO_DEPRECATE\n"
    "#define _CRT_NONSTDC_NO_DEPRECATE\n"
    "#endif\n"
    "\n"
    "#ifdef __GNUC__\n"
    "#pragma GCC diagnostic push\n"
    "#pragma GCC diagnostic ignored \"-Wvarargs\"\n"
    "#endif\n"
    "\n"
    "#include <stdbool.h>\n"
    "#include <stdint.h>\n"
    "#include <stddef.h>\n"
    "#include <stdarg.h>\n"
    "\n"
    "typedef unsigned char uchar;\n"
    "typedef signed char schar;\n"
    "typedef unsigned short ushort;\n"
    "typedef unsigned int uint;\n"
    "typedef unsigned long ulong;\n"
    "typedef long long llong;\n"
    "typedef unsigned long long ullong;\n"
    "\n"
    "#ifdef _MSC_VER\n"
    "#define alignof(x) __alignof(x)\n"
    "#else\n"
    "#define alignof(x) __alignof__(x)\n"
    "#endif\n"
    "\n"
    "#define va_start_ptr(args, arg) (va_start(*(args), *(arg)))\n"
    "#define va_copy_ptr(dest, src) (va_copy(*(dest), *(src)))\n"
    "#define va_end_ptr(args) (va_end(*(args)))\n"
    "\n"
    "struct Any;\n"
    "static void va_arg_ptr(va_list *args, struct Any any);\n";
char (*src_pink_gen_postamble_str) = 
    "\n"
    "static void va_arg_ptr(va_list *args, Any any) {\n"
    "    switch (typeid_kind(any.type)) {\n"
    "    case TYPE_BOOL:\n"
    "        *(bool *)any.ptr = (bool)va_arg(*args, int);\n"
    "        break;\n"
    "    case TYPE_CHAR:\n"
    "        *(char *)any.ptr = (char)va_arg(*args, int);\n"
    "        break;\n"
    "    case TYPE_UCHAR:\n"
    "        *(uchar *)any.ptr = (uchar)va_arg(*args, int);\n"
    "        break;\n"
    "    case TYPE_SCHAR:\n"
    "        *(schar *)any.ptr = (schar)va_arg(*args, int);\n"
    "        break;\n"
    "    case TYPE_SHORT:\n"
    "        *(short *)any.ptr = (short)va_arg(*args, int);\n"
    "        break;\n"
    "    case TYPE_USHORT:\n"
    "        *(ushort *)any.ptr = (ushort)va_arg(*args, int);\n"
    "        break;\n"
    "    case TYPE_INT:\n"
    "        *(int *)any.ptr = va_arg(*args, int);\n"
    "        break;\n"
    "    case TYPE_UINT:\n"
    "        *(uint *)any.ptr = va_arg(*args, uint);\n"
    "        break;\n"
    "    case TYPE_LONG:\n"
    "        *(long *)any.ptr = va_arg(*args, long);\n"
    "        break;\n"
    "    case TYPE_ULONG:\n"
    "        *(ulong *)any.ptr = va_arg(*args, ulong);\n"
    "        break;\n"
    "    case TYPE_LLONG:\n"
    "        *(llong *)any.ptr = va_arg(*args, llong);\n"
    "        break;\n"
    "    case TYPE_ULLONG:\n"
    "        *(ullong *)any.ptr = va_arg(*args, ullong);\n"
    "        break;\n"
    "    case TYPE_FLOAT:\n"
    "        *(float *)any.ptr = (float)va_arg(*args, double);\n"
    "        break;\n"
    "    case TYPE_DOUBLE:\n"
    "        *(double *)any.ptr = va_arg(*args, double);\n"
    "        break;\n"
    "    case TYPE_FUNC:\n"
    "    case TYPE_PTR:\n"
    "        *(void **)any.ptr = va_arg(*args, void *);\n"
    "        break;\n"
    "    default:\n"
    "        break;\n"
    "    }\n"
    "}\n"
    "\n"
    "#ifdef __GNUC__\n"
    "#pragma GCC diagnostic pop\n"
    "#endif\n";
void src_pink_genln(void) {
    old_std_buf_printf(&(src_pink_gen_buf), "\n"
    "%.*s", (src_pink_gen_indent) * (4), "                                                                  ");
    (src_pink_gen_pos.line)++;
}

bool src_pink_is_incomplete_array_typespec(src_pink_Typespec (*typespec)) {
    return ((typespec->kind) == (SRC_PINK_TYPESPEC_ARRAY)) && (!(typespec->num_elems));
}

char (src_pink_char_to_escape[256]) = {['\0'] = '0', ['\n'] = 'n', ['\r'] = 'r', ['\t'] = 't', ['\v'] = 'v', ['\b'] = 'b', ['\a'] = 'a', ['\\'] = '\\', ['\"'] = '\"', ['\''] = '\''};
void src_pink_gen_char(char c) {
    if (src_pink_char_to_escape[(uchar)(c)]) {
        old_std_buf_printf(&(src_pink_gen_buf), "\'\\%c\'", src_pink_char_to_escape[(uchar)(c)]);
    } else if (isprint(c)) {
        old_std_buf_printf(&(src_pink_gen_buf), "\'%c\'", c);
    } else {
        old_std_buf_printf(&(src_pink_gen_buf), "\'\\x%X\'", (uchar)(c));
    }
}

void src_pink_gen_str(char const ((*str)), bool multiline) {
    if (multiline) {
        (src_pink_gen_indent)++;
        src_pink_genln();
    }
    old_std_buf_printf(&(src_pink_gen_buf), "\"");
    while (*(str)) {
        char const ((*start)) = str;
        while (((*(str)) && (isprint(*(str)))) && (!(src_pink_char_to_escape[(uchar)(*(str))]))) {
            (str)++;
        }
        if ((start) != (str)) {
            old_std_buf_printf(&(src_pink_gen_buf), "%.*s", (str) - (start), start);
        }
        if (*(str)) {
            if (src_pink_char_to_escape[(uchar)(*(str))]) {
                old_std_buf_printf(&(src_pink_gen_buf), "\\%c", src_pink_char_to_escape[(uchar)(*(str))]);
                if (((str[0]) == ('\n')) && (str[1])) {
                    old_std_buf_printf(&(src_pink_gen_buf), "\"");
                    src_pink_genln();
                    old_std_buf_printf(&(src_pink_gen_buf), "\"");
                }
            } else {
                old_std_buf_printf(&(src_pink_gen_buf), "\\x%X", (uchar)(*(str)));
            }
            (str)++;
        }
    }
    old_std_buf_printf(&(src_pink_gen_buf), "\"");
    if (multiline) {
        (src_pink_gen_indent)--;
    }
}

void src_pink_gen_sync_pos(src_pink_SrcPos pos) {
    if (src_pink_flag_nosourcemap) {
        return;
    }
    if (((src_pink_gen_pos.line) != (pos.line)) || ((src_pink_gen_pos.name) != (pos.name))) {
        src_pink_genln();
        old_std_buf_printf(&(src_pink_gen_buf), "#line %d", pos.line);
        if ((src_pink_gen_pos.name) != (pos.name)) {
            old_std_buf_printf(&(src_pink_gen_buf), " ");
            src_pink_gen_str(pos.name, false);
        }
        src_pink_gen_pos = pos;
    }
}

char const ((*src_pink_cdecl_paren(char const ((*str)), char c))) {
    return ((c) && ((c) != ('[')) ? (char const (*))(old_std_strf("(%s)", str)) : str);
}

char const ((*src_pink_cdecl_name(src_pink_Type (*type)))) {
    char const ((*type_name)) = src_pink_type_names[type->kind];
    if (type_name) {
        return type_name;
    } else {
        return src_pink_get_gen_name(type->sym);
    }
}

char (*src_pink_type_to_cdecl(src_pink_Type (*type), char const ((*str)))) {
    switch (type->kind) {
    case SRC_PINK_CMPL_TYPE_PTR: {
        return src_pink_type_to_cdecl(type->base, src_pink_cdecl_paren(old_std_strf("*%s", str), *(str)));
        break;
    }
    case SRC_PINK_CMPL_TYPE_CONST: {
        return src_pink_type_to_cdecl(type->base, old_std_strf("const %s", src_pink_cdecl_paren(str, *(str))));
        break;
    }
    case SRC_PINK_CMPL_TYPE_ARRAY: {
        if ((type->num_elems) == (0)) {
            return src_pink_type_to_cdecl(type->base, src_pink_cdecl_paren(old_std_strf("%s[]", str), *(str)));
        } else {
            return src_pink_type_to_cdecl(type->base, src_pink_cdecl_paren(old_std_strf("%s[%zu]", str, type->num_elems), *(str)));
        }
        break;
    }
    case SRC_PINK_CMPL_TYPE_FUNC: {
        {
            char (*result) = NULL;
            old_std_buf_printf(&(result), "(*%s)(", str);
            if ((type->function.num_params) == (0)) {
                old_std_buf_printf(&(result), "void");
            } else {
                for (size_t i = 0; (i) < (type->function.num_params); (i)++) {
                    old_std_buf_printf(&(result), "%s%s", ((i) == (0) ? "" : ", "), src_pink_type_to_cdecl(type->function.params[i], ""));
                }
            }
            if (type->function.has_varargs) {
                old_std_buf_printf(&(result), ", ...");
            }
            old_std_buf_printf(&(result), ")");
            return src_pink_type_to_cdecl(type->function.ret, result);
        }
        break;
    }
    default: {
        return old_std_strf("%s%s%s", src_pink_cdecl_name(type), (*(str) ? " " : ""), str);
        break;
    }
    }
}

char const ((*src_pink_gen_expr_str(src_pink_Expr (*expr)))) {
    char (*temp) = src_pink_gen_buf;
    src_pink_gen_buf = NULL;
    src_pink_gen_expr(expr);
    char (*result) = src_pink_gen_buf;
    src_pink_gen_buf = temp;
    return result;
}

old_std_Map src_pink_gen_name_map;
char const ((*src_pink_get_gen_name_or_default(void const ((*ptr)), char const ((*default_name))))) {
    char const ((*name)) = old_std_map_get(&(src_pink_gen_name_map), ptr);
    if (!(name)) {
        src_pink_Sym (*sym) = src_pink_get_resolved_sym(ptr);
        if (sym) {
            if (sym->external_name) {
                name = sym->external_name;
            } else if (sym->home_package->external_name) {
                char const ((*external_name)) = sym->home_package->external_name;
                char (buf[256]) = {0};
                if ((sym->kind) == (SRC_PINK_SYM_CONST)) {
                    char (*ptr2) = buf;
                    for (char const ((*str)) = external_name; (*(str)) && ((ptr2) < (((buf) + (sizeof(buf))) - (1))); (str)++) {
                        *(ptr2) = toupper(*(str));
                        (ptr2)++;
                    }
                    *(ptr2) = 0;
                    if ((ptr2) < ((buf) + (sizeof(buf)))) {
                        external_name = buf;
                    }
                }
                name = old_std_strf("%s%s", external_name, sym->name);
            } else {
                name = sym->name;
            }
        } else {
            name = default_name;
        }
        old_std_map_put(&(src_pink_gen_name_map), ptr, (void *)(name));
    }
    return name;
}

char const ((*src_pink_get_gen_name(void const ((*ptr))))) {
    return src_pink_get_gen_name_or_default(ptr, "ERROR");
}

char (*src_pink_typespec_to_cdecl(src_pink_Typespec (*typespec), char const ((*str)))) {
    if (!(typespec)) {
        return old_std_strf("void%s%s", (*(str) ? " " : ""), str);
    }
    switch (typespec->kind) {
    case SRC_PINK_TYPESPEC_NAME: {
        return old_std_strf("%s%s%s", src_pink_get_gen_name_or_default(typespec, typespec->name), (*(str) ? " " : ""), str);
        break;
    }
    case SRC_PINK_TYPESPEC_PTR: {
        return src_pink_typespec_to_cdecl(typespec->base, src_pink_cdecl_paren(old_std_strf("*%s", str), *(str)));
        break;
    }
    case SRC_PINK_TYPESPEC_CONST: {
        return src_pink_typespec_to_cdecl(typespec->base, old_std_strf("const %s", src_pink_cdecl_paren(str, *(str))));
        break;
    }
    case SRC_PINK_TYPESPEC_ARRAY: {
        if ((typespec->num_elems) == (0)) {
            return src_pink_typespec_to_cdecl(typespec->base, src_pink_cdecl_paren(old_std_strf("%s[]", str), *(str)));
        } else {
            return src_pink_typespec_to_cdecl(typespec->base, src_pink_cdecl_paren(old_std_strf("%s[%s]", str, src_pink_gen_expr_str(typespec->num_elems)), *(str)));
        }
        break;
    }
    case SRC_PINK_TYPESPEC_FUNC: {
        {
            char (*result) = NULL;
            old_std_buf_printf(&(result), "(*%s)(", str);
            if ((typespec->function.num_args) == (0)) {
                old_std_buf_printf(&(result), "void");
            } else {
                for (size_t i = 0; (i) < (typespec->function.num_args); (i)++) {
                    old_std_buf_printf(&(result), "%s%s", ((i) == (0) ? "" : ", "), src_pink_typespec_to_cdecl(typespec->function.args[i], ""));
                }
            }
            if (typespec->function.has_varargs) {
                old_std_buf_printf(&(result), ", ...");
            }
            old_std_buf_printf(&(result), ")");
            return src_pink_typespec_to_cdecl(typespec->function.ret, result);
        }
        break;
    }
    default: {
        return NULL;
        break;
    }
    }
}

void src_pink_gen_func_decl(src_pink_Decl (*decl)) {
    char (*result) = NULL;
    old_std_buf_printf(&(result), "%s(", src_pink_get_gen_name(decl));
    if ((decl->function.num_params) == (0)) {
        old_std_buf_printf(&(result), "void");
    } else {
        for (size_t i = 0; (i) < (decl->function.num_params); (i)++) {
            src_pink_FuncParam param = decl->function.params[i];
            if ((i) != (0)) {
                old_std_buf_printf(&(result), ", ");
            }
            old_std_buf_printf(&(result), "%s", src_pink_typespec_to_cdecl(param.type, param.name));
        }
    }
    if (decl->function.has_varargs) {
        old_std_buf_printf(&(result), ", ...");
    }
    old_std_buf_printf(&(result), ")");
    src_pink_gen_sync_pos(decl->pos);
    if (decl->function.ret_type) {
        src_pink_genln();
        old_std_buf_printf(&(src_pink_gen_buf), "%s", src_pink_typespec_to_cdecl(decl->function.ret_type, result));
    } else {
        src_pink_genln();
        old_std_buf_printf(&(src_pink_gen_buf), "void %s", result);
    }
}

bool src_pink_gen_reachable(src_pink_Sym (*sym)) {
    return (src_pink_flag_fullgen) || ((sym->reachable) == (SRC_PINK_REACHABLE_NATURAL));
}

void src_pink_gen_forward_decls(void) {
    for (src_pink_Sym (*(*it)) = src_pink_sorted_syms; (it) != (old_std_buf_end(src_pink_sorted_syms, sizeof(*(src_pink_sorted_syms)))); (it)++) {
        src_pink_Sym (*sym) = *(it);
        src_pink_Decl (*decl) = sym->decl;
        if ((!(decl)) || (!(src_pink_gen_reachable(sym)))) {
            continue;
        }
        if (src_pink_is_decl_foreign(decl)) {
            continue;
        }
        switch (decl->kind) {
        case SRC_PINK_DECL_STRUCT:
        case SRC_PINK_DECL_UNION: {
            {
                char const ((*name)) = src_pink_get_gen_name(sym);
                src_pink_genln();
                old_std_buf_printf(&(src_pink_gen_buf), "typedef %s %s %s;", ((decl->kind) == (SRC_PINK_DECL_STRUCT) ? "struct" : "union"), name, name);
                break;
            }
            break;
        }
        default: {
            break;
            break;
        }
        }
    }
}

void src_pink_gen_aggregate_items(src_pink_Aggregate (*aggregate)) {
    (src_pink_gen_indent)++;
    for (size_t i = 0; (i) < (aggregate->num_items); (i)++) {
        src_pink_AggregateItem item = aggregate->items[i];
        if ((item.kind) == (SRC_PINK_AGGREGATE_ITEM_FIELD)) {
            for (size_t j = 0; (j) < (item.num_names); (j)++) {
                src_pink_gen_sync_pos(item.pos);
                src_pink_genln();
                old_std_buf_printf(&(src_pink_gen_buf), "%s;", src_pink_typespec_to_cdecl(item.type, item.names[j]));
            }
        } else if ((item.kind) == (SRC_PINK_AGGREGATE_ITEM_SUBAGGREGATE)) {
            src_pink_genln();
            old_std_buf_printf(&(src_pink_gen_buf), "%s {", ((item.subaggregate->kind) == (SRC_PINK_AGGREGATE_STRUCT) ? "struct" : "union"));
            src_pink_gen_aggregate_items(item.subaggregate);
            src_pink_genln();
            old_std_buf_printf(&(src_pink_gen_buf), "};");
        }
    }
    (src_pink_gen_indent)--;
}

void src_pink_gen_aggregate(src_pink_Decl (*decl)) {
    if (decl->is_incomplete) {
        return;
    }
    src_pink_genln();
    old_std_buf_printf(&(src_pink_gen_buf), "%s %s {", ((decl->kind) == (SRC_PINK_DECL_STRUCT) ? "struct" : "union"), src_pink_get_gen_name(decl));
    src_pink_gen_aggregate_items(decl->aggregate);
    src_pink_genln();
    old_std_buf_printf(&(src_pink_gen_buf), "};");
}

void src_pink_gen_paren_expr(src_pink_Expr (*expr)) {
    old_std_buf_printf(&(src_pink_gen_buf), "(");
    src_pink_gen_expr(expr);
    old_std_buf_printf(&(src_pink_gen_buf), ")");
}

void src_pink_gen_expr_compound(src_pink_Expr (*expr)) {
    src_pink_Type (*expected_type) = src_pink_get_resolved_expected_type(expr);
    if ((expected_type) && (!(src_pink_is_ptr_type(expected_type)))) {
        old_std_buf_printf(&(src_pink_gen_buf), "{");
    } else if (expr->compound.type) {
        old_std_buf_printf(&(src_pink_gen_buf), "(%s){", src_pink_typespec_to_cdecl(expr->compound.type, ""));
    } else {
        old_std_buf_printf(&(src_pink_gen_buf), "(%s){", src_pink_type_to_cdecl(src_pink_get_resolved_type(expr), ""));
    }
    for (size_t i = 0; (i) < (expr->compound.num_fields); (i)++) {
        if ((i) != (0)) {
            old_std_buf_printf(&(src_pink_gen_buf), ", ");
        }
        src_pink_CompoundField field = expr->compound.fields[i];
        if ((field.kind) == (SRC_PINK_FIELD_NAME)) {
            old_std_buf_printf(&(src_pink_gen_buf), ".%s = ", field.name);
        } else if ((field.kind) == (SRC_PINK_FIELD_INDEX)) {
            old_std_buf_printf(&(src_pink_gen_buf), "[");
            src_pink_gen_expr(field.index);
            old_std_buf_printf(&(src_pink_gen_buf), "] = ");
        }
        src_pink_gen_expr(field.init);
    }
    if ((expr->compound.num_fields) == (0)) {
        old_std_buf_printf(&(src_pink_gen_buf), "0");
    }
    old_std_buf_printf(&(src_pink_gen_buf), "}");
}

char const ((*(src_pink_typeid_kind_names[SRC_PINK_NUM_CMPL_TYPE_KINDS]))) = {[SRC_PINK_CMPL_TYPE_NONE] = "TYPE_NONE", [SRC_PINK_CMPL_TYPE_VOID] = "TYPE_VOID", [SRC_PINK_CMPL_TYPE_BOOL] = "TYPE_BOOL", [SRC_PINK_CMPL_TYPE_CHAR] = "TYPE_CHAR", [SRC_PINK_CMPL_TYPE_UCHAR] = "TYPE_UCHAR", [SRC_PINK_CMPL_TYPE_SCHAR] = "TYPE_SCHAR", [SRC_PINK_CMPL_TYPE_SHORT] = "TYPE_SHORT", [SRC_PINK_CMPL_TYPE_USHORT] = "TYPE_USHORT", [SRC_PINK_CMPL_TYPE_INT] = "TYPE_INT", [SRC_PINK_CMPL_TYPE_UINT] = "TYPE_UINT", [SRC_PINK_CMPL_TYPE_LONG] = "TYPE_LONG", [SRC_PINK_CMPL_TYPE_ULONG] = "TYPE_ULONG", [SRC_PINK_CMPL_TYPE_LLONG] = "TYPE_LLONG", [SRC_PINK_CMPL_TYPE_ULLONG] = "TYPE_ULLONG", [SRC_PINK_CMPL_TYPE_FLOAT] = "TYPE_FLOAT", [SRC_PINK_CMPL_TYPE_DOUBLE] = "TYPE_DOUBLE", [SRC_PINK_CMPL_TYPE_CONST] = "TYPE_CONST", [SRC_PINK_CMPL_TYPE_PTR] = "TYPE_PTR", [SRC_PINK_CMPL_TYPE_ARRAY] = "TYPE_ARRAY", [SRC_PINK_CMPL_TYPE_STRUCT] = "TYPE_STRUCT", [SRC_PINK_CMPL_TYPE_UNION] = "TYPE_UNION", [SRC_PINK_CMPL_TYPE_FUNC] = "TYPE_FUNC"};
char const ((*src_pink_typeid_kind_name(src_pink_Type (*type)))) {
    if ((type->kind) < (SRC_PINK_NUM_CMPL_TYPE_KINDS)) {
        char const ((*name)) = src_pink_typeid_kind_names[type->kind];
        if (name) {
            return name;
        }
    }
    return "TYPE_NONE";
}

bool src_pink_is_excluded_typeinfo(src_pink_Type (*type)) {
    while ((((type->kind) == (SRC_PINK_CMPL_TYPE_ARRAY)) || ((type->kind) == (SRC_PINK_CMPL_TYPE_CONST))) || ((type->kind) == (SRC_PINK_CMPL_TYPE_PTR))) {
        type = type->base;
    }
    if (type->sym) {
        return !(src_pink_gen_reachable(type->sym));
    } else {
        return (!(type->sym)) && ((((type->kind) == (SRC_PINK_CMPL_TYPE_STRUCT)) || ((type->kind) == (SRC_PINK_CMPL_TYPE_UNION))));
    }
}

void src_pink_gen_typeid(src_pink_Type (*type)) {
    if (((type->size) == (0)) || (src_pink_is_excluded_typeinfo(type))) {
        old_std_buf_printf(&(src_pink_gen_buf), "TYPEID0(%d, %s)", type->typeid, src_pink_typeid_kind_name(type));
    } else {
        old_std_buf_printf(&(src_pink_gen_buf), "TYPEID(%d, %s, %s)", type->typeid, src_pink_typeid_kind_name(type), src_pink_type_to_cdecl(type, ""));
    }
}

void src_pink_gen_expr(src_pink_Expr (*expr)) {
    switch (expr->kind) {
    case SRC_PINK_EXPR_PAREN: {
        old_std_buf_printf(&(src_pink_gen_buf), "(");
        src_pink_gen_expr(expr->paren.expr);
        old_std_buf_printf(&(src_pink_gen_buf), ")");
        break;
    }
    case SRC_PINK_EXPR_INT: {
        {
            char const ((*suffix_name)) = src_pink_token_suffix_names[expr->int_lit.suffix];
            switch (expr->int_lit.mod) {
            case SRC_PINK_MOD_BIN:
            case SRC_PINK_MOD_HEX: {
                old_std_buf_printf(&(src_pink_gen_buf), "0x%llx%s", expr->int_lit.val, suffix_name);
                break;
            }
            case SRC_PINK_MOD_OCT: {
                old_std_buf_printf(&(src_pink_gen_buf), "0%llo%s", expr->int_lit.val, suffix_name);
                break;
            }
            case SRC_PINK_MOD_CHAR: {
                src_pink_gen_char((char)(expr->int_lit.val));
                break;
            }
            default: {
                old_std_buf_printf(&(src_pink_gen_buf), "%llu%s", expr->int_lit.val, suffix_name);
                break;
            }
            }
        }
        break;
    }
    case SRC_PINK_EXPR_FLOAT: {
        {
            int is_double = (expr->float_lit.suffix) == (SRC_PINK_SUFFIX_D);
            size_t len = (expr->float_lit.end) - (expr->float_lit.start);
            old_std_buf_printf(&(src_pink_gen_buf), "%.*s%s", (is_double ? (len) - (1) : len), expr->float_lit.start, (is_double ? "" : "f"));
        }
        break;
    }
    case SRC_PINK_EXPR_STR: {
        src_pink_gen_str(expr->str_lit.val, (expr->str_lit.mod) == (SRC_PINK_MOD_MULTILINE));
        break;
    }
    case SRC_PINK_EXPR_NAME: {
        old_std_buf_printf(&(src_pink_gen_buf), "%s", src_pink_get_gen_name_or_default(expr, expr->name));
        break;
    }
    case SRC_PINK_EXPR_CAST: {
        old_std_buf_printf(&(src_pink_gen_buf), "(%s)(", src_pink_typespec_to_cdecl(expr->cast.type, ""));
        src_pink_gen_expr(expr->cast.expr);
        old_std_buf_printf(&(src_pink_gen_buf), ")");
        break;
    }
    case SRC_PINK_EXPR_CALL: {
        {
            src_pink_Sym (*sym) = src_pink_get_resolved_sym(expr->call.expr);
            if ((sym) && ((sym->kind) == (SRC_PINK_SYM_TYPE))) {
                old_std_buf_printf(&(src_pink_gen_buf), "(%s)", src_pink_get_gen_name(sym));
            } else {
                src_pink_gen_expr(expr->call.expr);
            }
            old_std_buf_printf(&(src_pink_gen_buf), "(");
            for (size_t i = 0; (i) < (expr->call.num_args); (i)++) {
                if ((i) != (0)) {
                    old_std_buf_printf(&(src_pink_gen_buf), ", ");
                }
                src_pink_gen_expr(expr->call.args[i]);
            }
            old_std_buf_printf(&(src_pink_gen_buf), ")");
        }
        break;
    }
    case SRC_PINK_EXPR_INDEX: {
        src_pink_gen_expr(expr->index.expr);
        old_std_buf_printf(&(src_pink_gen_buf), "[");
        src_pink_gen_expr(expr->index.index);
        old_std_buf_printf(&(src_pink_gen_buf), "]");
        break;
    }
    case SRC_PINK_EXPR_FIELD: {
        {
            src_pink_Sym (*sym) = src_pink_get_resolved_sym(expr);
            if (sym) {
                old_std_buf_printf(&(src_pink_gen_buf), "(%s)", src_pink_get_gen_name(sym));
            } else {
                src_pink_gen_expr(expr->field.expr);
                src_pink_Type (*type) = src_pink_unqualify_type(src_pink_get_resolved_type(expr->field.expr));
                old_std_buf_printf(&(src_pink_gen_buf), "%s%s", ((type->kind) == (SRC_PINK_CMPL_TYPE_PTR) ? "->" : "."), expr->field.name);
            }
        }
        break;
    }
    case SRC_PINK_EXPR_COMPOUND: {
        src_pink_gen_expr_compound(expr);
        break;
    }
    case SRC_PINK_EXPR_UNARY: {
        old_std_buf_printf(&(src_pink_gen_buf), "%s(", src_pink_token_kind_name(expr->unary.op));
        src_pink_gen_expr(expr->unary.expr);
        old_std_buf_printf(&(src_pink_gen_buf), ")");
        break;
    }
    case SRC_PINK_EXPR_BINARY: {
        old_std_buf_printf(&(src_pink_gen_buf), "(");
        src_pink_gen_expr(expr->binary.left);
        old_std_buf_printf(&(src_pink_gen_buf), ") %s (", src_pink_token_kind_name(expr->binary.op));
        src_pink_gen_expr(expr->binary.right);
        old_std_buf_printf(&(src_pink_gen_buf), ")");
        break;
    }
    case SRC_PINK_EXPR_TERNARY: {
        old_std_buf_printf(&(src_pink_gen_buf), "(");
        src_pink_gen_expr(expr->ternary.cond);
        old_std_buf_printf(&(src_pink_gen_buf), " ? ");
        src_pink_gen_expr(expr->ternary.then_expr);
        old_std_buf_printf(&(src_pink_gen_buf), " : ");
        src_pink_gen_expr(expr->ternary.else_expr);
        old_std_buf_printf(&(src_pink_gen_buf), ")");
        break;
    }
    case SRC_PINK_EXPR_SIZEOF_EXPR: {
        old_std_buf_printf(&(src_pink_gen_buf), "sizeof(");
        src_pink_gen_expr(expr->sizeof_expr);
        old_std_buf_printf(&(src_pink_gen_buf), ")");
        break;
    }
    case SRC_PINK_EXPR_SIZEOF_TYPE: {
        old_std_buf_printf(&(src_pink_gen_buf), "sizeof(%s)", src_pink_typespec_to_cdecl(expr->sizeof_type, ""));
        break;
    }
    case SRC_PINK_EXPR_ALIGNOF_EXPR: {
        old_std_buf_printf(&(src_pink_gen_buf), "alignof(%s)", src_pink_type_to_cdecl(src_pink_get_resolved_type(expr->alignof_expr), ""));
        break;
    }
    case SRC_PINK_EXPR_ALIGNOF_TYPE: {
        old_std_buf_printf(&(src_pink_gen_buf), "alignof(%s)", src_pink_typespec_to_cdecl(expr->alignof_type, ""));
        break;
    }
    case SRC_PINK_EXPR_TYPEOF_EXPR: {
        {
            src_pink_Type (*type) = src_pink_get_resolved_type(expr->typeof_expr);
            src_pink_gen_typeid(type);
        }
        break;
    }
    case SRC_PINK_EXPR_TYPEOF_TYPE: {
        {
            src_pink_Type (*type) = src_pink_get_resolved_type(expr->typeof_type);
            src_pink_gen_typeid(type);
        }
        break;
    }
    case SRC_PINK_EXPR_OFFSETOF: {
        old_std_buf_printf(&(src_pink_gen_buf), "offsetof(%s, %s)", src_pink_typespec_to_cdecl(expr->offsetof_field.type, ""), expr->offsetof_field.name);
        break;
    }
    case SRC_PINK_EXPR_MODIFY: {
        if (!(expr->modify.post)) {
            old_std_buf_printf(&(src_pink_gen_buf), "%s", src_pink_token_kind_name(expr->modify.op));
        }
        src_pink_gen_paren_expr(expr->modify.expr);
        if (expr->modify.post) {
            old_std_buf_printf(&(src_pink_gen_buf), "%s", src_pink_token_kind_name(expr->modify.op));
        }
        break;
    }
    default: {
        break;
        break;
    }
    }
}

void src_pink_gen_stmt_block(src_pink_StmtList block) {
    old_std_buf_printf(&(src_pink_gen_buf), "{");
    (src_pink_gen_indent)++;
    for (size_t i = 0; (i) < (block.num_stmts); (i)++) {
        src_pink_gen_stmt(block.stmts[i]);
    }
    (src_pink_gen_indent)--;
    src_pink_genln();
    old_std_buf_printf(&(src_pink_gen_buf), "}");
}

void src_pink_gen_simple_stmt(src_pink_Stmt (*stmt)) {
    switch (stmt->kind) {
    case SRC_PINK_STMT_EXPR: {
        src_pink_gen_expr(stmt->expr);
        break;
    }
    case SRC_PINK_STMT_INIT: {
        if (stmt->init.type) {
            src_pink_Typespec (*init_typespec) = stmt->init.type;
            if (src_pink_is_incomplete_array_typespec(stmt->init.type)) {
                src_pink_Expr (*size) = src_pink_new_expr_int(init_typespec->pos, src_pink_get_resolved_type(stmt->init.expr)->num_elems, 0, 0);
                init_typespec = src_pink_new_typespec_array(init_typespec->pos, init_typespec->base, size);
            }
            old_std_buf_printf(&(src_pink_gen_buf), "%s = ", src_pink_typespec_to_cdecl(stmt->init.type, stmt->init.name));
            if (stmt->init.expr) {
                src_pink_gen_expr(stmt->init.expr);
            } else {
                old_std_buf_printf(&(src_pink_gen_buf), "{0}");
            }
        } else {
            old_std_buf_printf(&(src_pink_gen_buf), "%s = ", src_pink_type_to_cdecl(src_pink_unqualify_type(src_pink_get_resolved_type(stmt->init.expr)), stmt->init.name));
            src_pink_gen_expr(stmt->init.expr);
        }
        break;
    }
    case SRC_PINK_STMT_ASSIGN: {
        src_pink_gen_expr(stmt->assign.left);
        old_std_buf_printf(&(src_pink_gen_buf), " %s ", src_pink_token_kind_name(stmt->assign.op));
        src_pink_gen_expr(stmt->assign.right);
        break;
    }
    default: {
        break;
        break;
    }
    }
}

bool src_pink_is_char_lit(src_pink_Expr (*expr)) {
    return ((expr->kind) == (SRC_PINK_EXPR_INT)) && ((expr->int_lit.mod) == (SRC_PINK_MOD_CHAR));
}

void src_pink_gen_stmt(src_pink_Stmt (*stmt)) {
    src_pink_gen_sync_pos(stmt->pos);
    switch (stmt->kind) {
    case SRC_PINK_STMT_RETURN: {
        src_pink_genln();
        old_std_buf_printf(&(src_pink_gen_buf), "return");
        if (stmt->expr) {
            old_std_buf_printf(&(src_pink_gen_buf), " ");
            src_pink_gen_expr(stmt->expr);
        }
        old_std_buf_printf(&(src_pink_gen_buf), ";");
        break;
    }
    case SRC_PINK_STMT_BREAK: {
        src_pink_genln();
        old_std_buf_printf(&(src_pink_gen_buf), "break;");
        break;
    }
    case SRC_PINK_STMT_CONTINUE: {
        src_pink_genln();
        old_std_buf_printf(&(src_pink_gen_buf), "continue;");
        break;
    }
    case SRC_PINK_STMT_BLOCK: {
        src_pink_genln();
        src_pink_gen_stmt_block(stmt->block);
        break;
    }
    case SRC_PINK_STMT_NOTE: {
        if ((stmt->note.name) == (src_pink_assert_name)) {
            src_pink_genln();
            old_std_buf_printf(&(src_pink_gen_buf), "assert(");
            src_pink_gen_expr(stmt->note.args[0].expr);
            old_std_buf_printf(&(src_pink_gen_buf), ");");
        }
        break;
    }
    case SRC_PINK_STMT_IF: {
        if (stmt->if_stmt.init) {
            src_pink_genln();
            old_std_buf_printf(&(src_pink_gen_buf), "{");
            (src_pink_gen_indent)++;
            src_pink_gen_stmt(stmt->if_stmt.init);
        }
        src_pink_gen_sync_pos(stmt->pos);
        src_pink_genln();
        old_std_buf_printf(&(src_pink_gen_buf), "if (");
        if (stmt->if_stmt.cond) {
            src_pink_gen_expr(stmt->if_stmt.cond);
        } else {
            old_std_buf_printf(&(src_pink_gen_buf), "%s", stmt->if_stmt.init->init.name);
        }
        old_std_buf_printf(&(src_pink_gen_buf), ") ");
        src_pink_gen_stmt_block(stmt->if_stmt.then_block);
        for (size_t i = 0; (i) < (stmt->if_stmt.num_elseifs); (i)++) {
            src_pink_ElseIf elseif = stmt->if_stmt.elseifs[i];
            old_std_buf_printf(&(src_pink_gen_buf), " else if (");
            src_pink_gen_expr(elseif.cond);
            old_std_buf_printf(&(src_pink_gen_buf), ") ");
            src_pink_gen_stmt_block(elseif.block);
        }
        if (stmt->if_stmt.else_block.stmts) {
            old_std_buf_printf(&(src_pink_gen_buf), " else ");
            src_pink_gen_stmt_block(stmt->if_stmt.else_block);
        } else {
            src_pink_Note (*complete_note) = src_pink_get_stmt_note(stmt, src_pink_complete_name);
            if (complete_note) {
                old_std_buf_printf(&(src_pink_gen_buf), " else {");
                (src_pink_gen_indent)++;
                src_pink_gen_sync_pos(complete_note->pos);
                src_pink_genln();
                old_std_buf_printf(&(src_pink_gen_buf), "assert(\"@complete if/elseif chain failed to handle case\" && 0);");
                (src_pink_gen_indent)--;
                src_pink_genln();
                old_std_buf_printf(&(src_pink_gen_buf), "}");
            }
        }
        if (stmt->if_stmt.init) {
            (src_pink_gen_indent)--;
            src_pink_genln();
            old_std_buf_printf(&(src_pink_gen_buf), "}");
        }
        break;
    }
    case SRC_PINK_STMT_WHILE: {
        src_pink_genln();
        old_std_buf_printf(&(src_pink_gen_buf), "while (");
        src_pink_gen_expr(stmt->while_stmt.cond);
        old_std_buf_printf(&(src_pink_gen_buf), ") ");
        src_pink_gen_stmt_block(stmt->while_stmt.block);
        break;
    }
    case SRC_PINK_STMT_DO_WHILE: {
        src_pink_genln();
        old_std_buf_printf(&(src_pink_gen_buf), "do ");
        src_pink_gen_stmt_block(stmt->while_stmt.block);
        old_std_buf_printf(&(src_pink_gen_buf), " while (");
        src_pink_gen_expr(stmt->while_stmt.cond);
        old_std_buf_printf(&(src_pink_gen_buf), ");");
        break;
    }
    case SRC_PINK_STMT_FOR: {
        src_pink_genln();
        old_std_buf_printf(&(src_pink_gen_buf), "for (");
        if (stmt->for_stmt.init) {
            src_pink_gen_simple_stmt(stmt->for_stmt.init);
        }
        old_std_buf_printf(&(src_pink_gen_buf), ";");
        if (stmt->for_stmt.cond) {
            old_std_buf_printf(&(src_pink_gen_buf), " ");
            src_pink_gen_expr(stmt->for_stmt.cond);
        }
        old_std_buf_printf(&(src_pink_gen_buf), ";");
        if (stmt->for_stmt.next) {
            old_std_buf_printf(&(src_pink_gen_buf), " ");
            src_pink_gen_simple_stmt(stmt->for_stmt.next);
        }
        old_std_buf_printf(&(src_pink_gen_buf), ") ");
        src_pink_gen_stmt_block(stmt->for_stmt.block);
        break;
    }
    case SRC_PINK_STMT_SWITCH: {
        {
            src_pink_genln();
            old_std_buf_printf(&(src_pink_gen_buf), "switch (");
            src_pink_gen_expr(stmt->switch_stmt.expr);
            old_std_buf_printf(&(src_pink_gen_buf), ") {");
            bool has_default = false;
            for (size_t i = 0; (i) < (stmt->switch_stmt.num_cases); (i)++) {
                src_pink_SwitchCase switch_case = stmt->switch_stmt.cases[i];
                for (size_t j = 0; (j) < (switch_case.num_patterns); (j)++) {
                    src_pink_SwitchCasePattern pattern = switch_case.patterns[j];
                    if (pattern.end) {
                        old_std_Val start_val = src_pink_get_resolved_val(pattern.start);
                        old_std_Val end_val = src_pink_get_resolved_val(pattern.end);
                        if ((src_pink_is_char_lit(pattern.start)) && (src_pink_is_char_lit(pattern.end))) {
                            src_pink_genln();
                            for (int c = (int)(start_val.ll); (c) <= ((int)(end_val.ll)); (c)++) {
                                old_std_buf_printf(&(src_pink_gen_buf), "case ");
                                src_pink_gen_char(c);
                                old_std_buf_printf(&(src_pink_gen_buf), ": ");
                            }
                        } else {
                            src_pink_genln();
                            old_std_buf_printf(&(src_pink_gen_buf), "// ");
                            src_pink_gen_expr(pattern.start);
                            old_std_buf_printf(&(src_pink_gen_buf), "...");
                            src_pink_gen_expr(pattern.end);
                            src_pink_genln();
                            for (llong ll = start_val.ll; (ll) <= (end_val.ll); (ll)++) {
                                old_std_buf_printf(&(src_pink_gen_buf), "case %lld: ", ll);
                            }
                        }
                    } else {
                        src_pink_genln();
                        old_std_buf_printf(&(src_pink_gen_buf), "case ");
                        src_pink_gen_expr(pattern.start);
                        old_std_buf_printf(&(src_pink_gen_buf), ":");
                    }
                }
                if (switch_case.is_default) {
                    has_default = true;
                    src_pink_genln();
                    old_std_buf_printf(&(src_pink_gen_buf), "default:");
                }
                old_std_buf_printf(&(src_pink_gen_buf), " ");
                old_std_buf_printf(&(src_pink_gen_buf), "{");
                (src_pink_gen_indent)++;
                src_pink_StmtList block = switch_case.block;
                for (size_t j = 0; (j) < (block.num_stmts); (j)++) {
                    src_pink_gen_stmt(block.stmts[j]);
                }
                src_pink_genln();
                old_std_buf_printf(&(src_pink_gen_buf), "break;");
                (src_pink_gen_indent)--;
                src_pink_genln();
                old_std_buf_printf(&(src_pink_gen_buf), "}");
            }
            if (!(has_default)) {
                src_pink_Note (*note) = src_pink_get_stmt_note(stmt, src_pink_complete_name);
                if (note) {
                    src_pink_genln();
                    old_std_buf_printf(&(src_pink_gen_buf), "default:");
                    (src_pink_gen_indent)++;
                    src_pink_genln();
                    old_std_buf_printf(&(src_pink_gen_buf), "assert(\"@complete switch failed to handle case\" && 0);");
                    src_pink_genln();
                    old_std_buf_printf(&(src_pink_gen_buf), "break;");
                    (src_pink_gen_indent)--;
                }
            }
            src_pink_genln();
            old_std_buf_printf(&(src_pink_gen_buf), "}");
        }
        break;
    }
    case SRC_PINK_STMT_LABEL: {
        src_pink_genln();
        old_std_buf_printf(&(src_pink_gen_buf), "%s: ;", stmt->label);
        break;
    }
    case SRC_PINK_STMT_GOTO: {
        src_pink_genln();
        old_std_buf_printf(&(src_pink_gen_buf), "goto %s;", stmt->label);
        break;
    }
    default: {
        src_pink_genln();
        src_pink_gen_simple_stmt(stmt);
        old_std_buf_printf(&(src_pink_gen_buf), ";");
        break;
    }
    }
}

void src_pink_gen_decl(src_pink_Sym (*sym)) {
    src_pink_Decl (*decl) = sym->decl;
    if ((!(decl)) || (src_pink_is_decl_foreign(decl))) {
        return;
    }
    src_pink_gen_sync_pos(decl->pos);
    switch (decl->kind) {
    case SRC_PINK_DECL_CONST: {
        src_pink_genln();
        old_std_buf_printf(&(src_pink_gen_buf), "#define %s (", src_pink_get_gen_name(sym));
        if (decl->const_decl.type) {
            old_std_buf_printf(&(src_pink_gen_buf), "(%s)(", src_pink_typespec_to_cdecl(decl->const_decl.type, ""));
        }
        src_pink_gen_expr(decl->const_decl.expr);
        if (decl->const_decl.type) {
            old_std_buf_printf(&(src_pink_gen_buf), ")");
        }
        old_std_buf_printf(&(src_pink_gen_buf), ")");
        break;
    }
    case SRC_PINK_DECL_VAR: {
        src_pink_genln();
        old_std_buf_printf(&(src_pink_gen_buf), "extern ");
        if ((decl->var_decl.type) && (!(src_pink_is_incomplete_array_typespec(decl->var_decl.type)))) {
            old_std_buf_printf(&(src_pink_gen_buf), "%s", src_pink_typespec_to_cdecl(decl->var_decl.type, src_pink_get_gen_name(sym)));
        } else {
            old_std_buf_printf(&(src_pink_gen_buf), "%s", src_pink_type_to_cdecl(sym->type, src_pink_get_gen_name(sym)));
        }
        old_std_buf_printf(&(src_pink_gen_buf), ";");
        break;
    }
    case SRC_PINK_DECL_FUNC: {
        src_pink_gen_func_decl(decl);
        old_std_buf_printf(&(src_pink_gen_buf), ";");
        break;
    }
    case SRC_PINK_DECL_STRUCT:
    case SRC_PINK_DECL_UNION: {
        src_pink_gen_aggregate(decl);
        break;
    }
    case SRC_PINK_DECL_TYPEDEF: {
        src_pink_genln();
        old_std_buf_printf(&(src_pink_gen_buf), "typedef %s;", src_pink_typespec_to_cdecl(decl->typedef_decl.type, src_pink_get_gen_name(sym)));
        break;
    }
    case SRC_PINK_DECL_ENUM: {
        if (decl->enum_decl.type) {
            src_pink_genln();
            old_std_buf_printf(&(src_pink_gen_buf), "typedef %s;", src_pink_typespec_to_cdecl(decl->enum_decl.type, src_pink_get_gen_name(decl)));
        } else {
            src_pink_genln();
            old_std_buf_printf(&(src_pink_gen_buf), "typedef int %s;", src_pink_get_gen_name(decl));
        }
        break;
    }
    case SRC_PINK_DECL_IMPORT: {
        break;
        break;
    }
    default: {
        break;
        break;
    }
    }
    src_pink_genln();
}

void src_pink_gen_sorted_decls(void) {
    for (size_t i = 0; (i) < (old_std_buf_len(src_pink_sorted_syms)); (i)++) {
        if ((src_pink_sorted_syms[i]->reachable) == (SRC_PINK_REACHABLE_NATURAL)) {
            src_pink_gen_decl(src_pink_sorted_syms[i]);
        }
    }
}

void src_pink_gen_defs(void) {
    for (src_pink_Sym (*(*it)) = src_pink_sorted_syms; (it) != (old_std_buf_end(src_pink_sorted_syms, sizeof(*(src_pink_sorted_syms)))); (it)++) {
        src_pink_Sym (*sym) = *(it);
        src_pink_Decl (*decl) = sym->decl;
        if ((((((sym->state) != (SRC_PINK_SYM_RESOLVED)) || (!(decl))) || (src_pink_is_decl_foreign(decl))) || (decl->is_incomplete)) || ((sym->reachable) != (SRC_PINK_REACHABLE_NATURAL))) {
            continue;
        }
        if ((decl->kind) == (SRC_PINK_DECL_FUNC)) {
            src_pink_gen_func_decl(decl);
            old_std_buf_printf(&(src_pink_gen_buf), " ");
            src_pink_gen_stmt_block(decl->function.block);
            src_pink_genln();
        } else if ((decl->kind) == (SRC_PINK_DECL_VAR)) {
            if ((decl->var_decl.type) && (!(src_pink_is_incomplete_array_typespec(decl->var_decl.type)))) {
                src_pink_genln();
                old_std_buf_printf(&(src_pink_gen_buf), "%s", src_pink_typespec_to_cdecl(decl->var_decl.type, src_pink_get_gen_name(sym)));
            } else {
                src_pink_genln();
                old_std_buf_printf(&(src_pink_gen_buf), "%s", src_pink_type_to_cdecl(sym->type, src_pink_get_gen_name(sym)));
            }
            if (decl->var_decl.expr) {
                old_std_buf_printf(&(src_pink_gen_buf), " = ");
                src_pink_gen_expr(decl->var_decl.expr);
            }
            old_std_buf_printf(&(src_pink_gen_buf), ";");
        }
    }
}

old_std_Map src_pink_gen_foreign_headers_map;
char const ((*(*src_pink_gen_foreign_headers_buf)));
void src_pink_add_foreign_header(char const ((*name))) {
    name = old_std_str_intern(name);
    if (!(old_std_map_get(&(src_pink_gen_foreign_headers_map), name))) {
        old_std_map_put(&(src_pink_gen_foreign_headers_map), name, (void *)(1));
        old_std_buf_push((void (**))(&(src_pink_gen_foreign_headers_buf)), &(name), sizeof(name));
    }
}

char const ((*(*src_pink_gen_foreign_sources_buf)));
void src_pink_add_foreign_source(char const ((*name))) {
    char const ((*interned)) = old_std_str_intern(name);
    old_std_buf_push((void (**))(&(src_pink_gen_foreign_sources_buf)), &(interned), sizeof(interned));
}

void src_pink_gen_include(char const ((*path))) {
    src_pink_genln();
    old_std_buf_printf(&(src_pink_gen_buf), "#include ");
    if ((*(path)) == ('<')) {
        old_std_buf_printf(&(src_pink_gen_buf), "%s", path);
    } else {
        src_pink_gen_str(path, false);
    }
}

void src_pink_gen_foreign_headers(void) {
    if (src_pink_gen_foreign_headers_buf) {
        src_pink_genln();
        old_std_buf_printf(&(src_pink_gen_buf), "// Foreign header files");
        for (size_t i = 0; (i) < (old_std_buf_len(src_pink_gen_foreign_headers_buf)); (i)++) {
            src_pink_gen_include(src_pink_gen_foreign_headers_buf[i]);
        }
    }
}

void src_pink_gen_foreign_sources(void) {
    for (size_t i = 0; (i) < (old_std_buf_len(src_pink_gen_foreign_sources_buf)); (i)++) {
        src_pink_gen_include(src_pink_gen_foreign_sources_buf[i]);
    }
}

char const ((*(*src_pink_gen_sources_buf)));
void src_pink_put_include_path(char (path[MAX_PATH]), src_pink_Package (*package), char const ((*filename))) {
    if ((*(filename)) == ('<')) {
        old_std_os_path_copy(path, filename);
    } else {
        old_std_os_path_copy(path, package->full_path);
        old_std_os_path_join(path, filename);
        old_std_os_path_absolute(path);
    }
}

char (*src_pink_gen_preamble_buf);
char (*src_pink_gen_postamble_buf);
void src_pink_preprocess_package(src_pink_Package (*package)) {
    if (!(package->external_name)) {
        char (*external_name) = NULL;
        for (char const ((*ptr)) = package->path; *(ptr); (ptr)++) {
            old_std_buf_printf(&(external_name), "%c", ((*(ptr)) == ('/') ? '_' : *(ptr)));
        }
        old_std_buf_printf(&(external_name), "_");
        package->external_name = old_std_str_intern(external_name);
    }
    char const ((*header_name)) = old_std_str_intern("header");
    char const ((*source_name)) = old_std_str_intern("source");
    char const ((*preamble_name)) = old_std_str_intern("preamble");
    char const ((*postamble_name)) = old_std_str_intern("postamble");
    for (size_t i = 0; (i) < (package->num_decls); (i)++) {
        src_pink_Decl (*decl) = package->decls[i];
        if ((decl->kind) != (SRC_PINK_DECL_NOTE)) {
            continue;
        }
        src_pink_Note note = decl->note;
        if ((note.name) == (src_pink_foreign_name)) {
            for (size_t k = 0; (k) < (note.num_args); (k)++) {
                src_pink_NoteArg arg = note.args[k];
                src_pink_Expr (*expr) = note.args[k].expr;
                if ((expr->kind) != (SRC_PINK_EXPR_STR)) {
                    src_pink_fatal_error(decl->pos, "#foreign argument must be a string");
                }
                char const ((*str)) = expr->str_lit.val;
                if ((arg.name) == (header_name)) {
                    char (path[MAX_PATH]) = {0};
                    src_pink_put_include_path(path, package, str);
                    src_pink_add_foreign_header(path);
                } else if ((arg.name) == (source_name)) {
                    char (path[MAX_PATH]) = {0};
                    src_pink_put_include_path(path, package, str);
                    src_pink_add_foreign_source(path);
                } else if ((arg.name) == (preamble_name)) {
                    old_std_buf_printf(&(src_pink_gen_preamble_buf), "%s\n", str);
                } else if ((arg.name) == (postamble_name)) {
                    old_std_buf_printf(&(src_pink_gen_postamble_buf), "%s\n", str);
                } else {
                    src_pink_fatal_error(decl->pos, "Unknown #foreign named argument \'%s\'", arg.name);
                }
            }
        }
    }
}

void src_pink_preprocess_packages(void) {
    for (size_t i = 0; (i) < (old_std_buf_len(src_pink_package_list)); (i)++) {
        src_pink_preprocess_package(src_pink_package_list[i]);
    }
}

void src_pink_gen_typeinfo_header(char const ((*kind)), src_pink_Type (*type)) {
    if ((src_pink_type_sizeof(type)) == (0)) {
        old_std_buf_printf(&(src_pink_gen_buf), "&(TypeInfo){%s, .size = 0, .align = 0", kind);
    } else {
        char (*ctype) = src_pink_type_to_cdecl(type, "");
        old_std_buf_printf(&(src_pink_gen_buf), "&(TypeInfo){%s, .size = sizeof(%s), .align = alignof(%s)", kind, ctype, ctype);
    }
}

void src_pink_gen_typeinfo_fields(src_pink_Type (*type)) {
    (src_pink_gen_indent)++;
    for (size_t i = 0; (i) < (type->aggregate.num_fields); (i)++) {
        src_pink_TypeField field = type->aggregate.fields[i];
        src_pink_genln();
        old_std_buf_printf(&(src_pink_gen_buf), "{");
        src_pink_gen_str(field.name, false);
        old_std_buf_printf(&(src_pink_gen_buf), ", .type = ");
        src_pink_gen_typeid(field.type);
        old_std_buf_printf(&(src_pink_gen_buf), ", .offset = offsetof(%s, %s)},", src_pink_get_gen_name(type->sym), field.name);
    }
    (src_pink_gen_indent)--;
}

void src_pink_gen_typeinfo(src_pink_Type (*type)) {
    switch (type->kind) {
    case SRC_PINK_CMPL_TYPE_BOOL: {
        old_std_buf_printf(&(src_pink_gen_buf), "&(TypeInfo){TYPE_BOOL, .size = sizeof(bool), .align = sizeof(bool), .name = ");
        src_pink_gen_str("bool", false);
        old_std_buf_printf(&(src_pink_gen_buf), "},");
        break;
    }
    case SRC_PINK_CMPL_TYPE_CHAR: {
        old_std_buf_printf(&(src_pink_gen_buf), "&(TypeInfo){TYPE_CHAR, .size = sizeof(char), .align = sizeof(char), .name = ");
        src_pink_gen_str("char", false);
        old_std_buf_printf(&(src_pink_gen_buf), "},");
        break;
    }
    case SRC_PINK_CMPL_TYPE_UCHAR: {
        old_std_buf_printf(&(src_pink_gen_buf), "&(TypeInfo){TYPE_UCHAR, .size = sizeof(uchar), .align = sizeof(uchar), .name = ");
        src_pink_gen_str("uchar", false);
        old_std_buf_printf(&(src_pink_gen_buf), "},");
        break;
    }
    case SRC_PINK_CMPL_TYPE_SCHAR: {
        old_std_buf_printf(&(src_pink_gen_buf), "&(TypeInfo){TYPE_SCHAR, .size = sizeof(schar), .align = sizeof(schar), .name = ");
        src_pink_gen_str("schar", false);
        old_std_buf_printf(&(src_pink_gen_buf), "},");
        break;
    }
    case SRC_PINK_CMPL_TYPE_SHORT: {
        old_std_buf_printf(&(src_pink_gen_buf), "&(TypeInfo){TYPE_SHORT, .size = sizeof(short), .align = sizeof(short), .name = ");
        src_pink_gen_str("short", false);
        old_std_buf_printf(&(src_pink_gen_buf), "},");
        break;
    }
    case SRC_PINK_CMPL_TYPE_USHORT: {
        old_std_buf_printf(&(src_pink_gen_buf), "&(TypeInfo){TYPE_USHORT, .size = sizeof(ushort), .align = sizeof(ushort), .name = ");
        src_pink_gen_str("ushort", false);
        old_std_buf_printf(&(src_pink_gen_buf), "},");
        break;
    }
    case SRC_PINK_CMPL_TYPE_INT: {
        old_std_buf_printf(&(src_pink_gen_buf), "&(TypeInfo){TYPE_INT, .size = sizeof(int), .align = sizeof(int), .name = ");
        src_pink_gen_str("int", false);
        old_std_buf_printf(&(src_pink_gen_buf), "},");
        break;
    }
    case SRC_PINK_CMPL_TYPE_UINT: {
        old_std_buf_printf(&(src_pink_gen_buf), "&(TypeInfo){TYPE_UINT, .size = sizeof(uint), .align = sizeof(uint), .name = ");
        src_pink_gen_str("uint", false);
        old_std_buf_printf(&(src_pink_gen_buf), "},");
        break;
    }
    case SRC_PINK_CMPL_TYPE_LONG: {
        old_std_buf_printf(&(src_pink_gen_buf), "&(TypeInfo){TYPE_LONG, .size = sizeof(long), .align = sizeof(long), .name = ");
        src_pink_gen_str("long", false);
        old_std_buf_printf(&(src_pink_gen_buf), "},");
        break;
    }
    case SRC_PINK_CMPL_TYPE_ULONG: {
        old_std_buf_printf(&(src_pink_gen_buf), "&(TypeInfo){TYPE_ULONG, .size = sizeof(ulong), .align = sizeof(ulong), .name = ");
        src_pink_gen_str("ulong", false);
        old_std_buf_printf(&(src_pink_gen_buf), "},");
        break;
    }
    case SRC_PINK_CMPL_TYPE_LLONG: {
        old_std_buf_printf(&(src_pink_gen_buf), "&(TypeInfo){TYPE_LLONG, .size = sizeof(llong), .align = sizeof(llong), .name = ");
        src_pink_gen_str("llong", false);
        old_std_buf_printf(&(src_pink_gen_buf), "},");
        break;
    }
    case SRC_PINK_CMPL_TYPE_ULLONG: {
        old_std_buf_printf(&(src_pink_gen_buf), "&(TypeInfo){TYPE_ULLONG, .size = sizeof(ullong), .align = sizeof(ullong), .name = ");
        src_pink_gen_str("ullong", false);
        old_std_buf_printf(&(src_pink_gen_buf), "},");
        break;
    }
    case SRC_PINK_CMPL_TYPE_FLOAT: {
        old_std_buf_printf(&(src_pink_gen_buf), "&(TypeInfo){TYPE_FLOAT, .size = sizeof(float), .align = sizeof(float), .name = ");
        src_pink_gen_str("float", false);
        old_std_buf_printf(&(src_pink_gen_buf), "},");
        break;
    }
    case SRC_PINK_CMPL_TYPE_DOUBLE: {
        old_std_buf_printf(&(src_pink_gen_buf), "&(TypeInfo){TYPE_DOUBLE, .size = sizeof(double), .align = sizeof(double), .name = ");
        src_pink_gen_str("double", false);
        old_std_buf_printf(&(src_pink_gen_buf), "},");
        break;
    }
    case SRC_PINK_CMPL_TYPE_VOID: {
        old_std_buf_printf(&(src_pink_gen_buf), "&(TypeInfo){TYPE_VOID, .name = \"void\", .size = 0, .align = 0},");
        break;
    }
    case SRC_PINK_CMPL_TYPE_PTR: {
        old_std_buf_printf(&(src_pink_gen_buf), "&(TypeInfo){TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = ");
        src_pink_gen_typeid(type->base);
        old_std_buf_printf(&(src_pink_gen_buf), "},");
        break;
    }
    case SRC_PINK_CMPL_TYPE_CONST: {
        src_pink_gen_typeinfo_header("TYPE_CONST", type);
        old_std_buf_printf(&(src_pink_gen_buf), ", .base = ");
        src_pink_gen_typeid(type->base);
        old_std_buf_printf(&(src_pink_gen_buf), "},");
        break;
    }
    case SRC_PINK_CMPL_TYPE_ARRAY: {
        if (src_pink_is_incomplete_array_type(type)) {
            old_std_buf_printf(&(src_pink_gen_buf), "NULL, // Incomplete array type");
        } else {
            src_pink_gen_typeinfo_header("TYPE_ARRAY", type);
            old_std_buf_printf(&(src_pink_gen_buf), ", .base = ");
            src_pink_gen_typeid(type->base);
            old_std_buf_printf(&(src_pink_gen_buf), ", .count = %d},", type->num_elems);
        }
        break;
    }
    case SRC_PINK_CMPL_TYPE_STRUCT:
    case SRC_PINK_CMPL_TYPE_UNION: {
        src_pink_gen_typeinfo_header(((type->kind) == (SRC_PINK_CMPL_TYPE_STRUCT) ? "TYPE_STRUCT" : "TYPE_UNION"), type);
        old_std_buf_printf(&(src_pink_gen_buf), ", .name = ");
        src_pink_gen_str(src_pink_get_gen_name(type->sym), false);
        old_std_buf_printf(&(src_pink_gen_buf), ", .num_fields = %d, .fields = (TypeFieldInfo[]) {", type->aggregate.num_fields);
        src_pink_gen_typeinfo_fields(type);
        src_pink_genln();
        old_std_buf_printf(&(src_pink_gen_buf), "}},");
        break;
    }
    case SRC_PINK_CMPL_TYPE_FUNC: {
        old_std_buf_printf(&(src_pink_gen_buf), "NULL, // Func");
        break;
    }
    case SRC_PINK_CMPL_TYPE_ENUM: {
        old_std_buf_printf(&(src_pink_gen_buf), "NULL, // Enum");
        break;
    }
    case SRC_PINK_CMPL_TYPE_INCOMPLETE: {
        old_std_buf_printf(&(src_pink_gen_buf), "NULL, // Incomplete: %s", src_pink_get_gen_name(type->sym));
        break;
    }
    default: {
        old_std_buf_printf(&(src_pink_gen_buf), "NULL, // Unhandled");
        break;
    }
    }
}

void src_pink_gen_typeinfos(void) {
    src_pink_genln();
    old_std_buf_printf(&(src_pink_gen_buf), "#define TYPEID0(index, kind) ((ullong)(index) | ((ullong)(kind) << 24))");
    src_pink_genln();
    old_std_buf_printf(&(src_pink_gen_buf), "#define TYPEID(index, kind, ...) ((ullong)(index) | ((ullong)sizeof(__VA_ARGS__) << 32) | ((ullong)(kind) << 24))");
    src_pink_genln();
    if (src_pink_flag_notypeinfo) {
        src_pink_genln();
        old_std_buf_printf(&(src_pink_gen_buf), "int num_typeinfos;");
        src_pink_genln();
        old_std_buf_printf(&(src_pink_gen_buf), "const TypeInfo **typeinfos;");
    } else {
        int num_typeinfos = src_pink_next_typeid;
        src_pink_genln();
        old_std_buf_printf(&(src_pink_gen_buf), "const TypeInfo *typeinfo_table[%d] = {", num_typeinfos);
        (src_pink_gen_indent)++;
        for (int typeid = 0; (typeid) < (num_typeinfos); (typeid)++) {
            src_pink_genln();
            old_std_buf_printf(&(src_pink_gen_buf), "[%d] = ", typeid);
            src_pink_Type (*type) = src_pink_get_type_from_typeid(typeid);
            if ((type) && (!(src_pink_is_excluded_typeinfo(type)))) {
                src_pink_gen_typeinfo(type);
            } else {
                old_std_buf_printf(&(src_pink_gen_buf), "NULL, // No associated type");
            }
        }
        (src_pink_gen_indent)--;
        src_pink_genln();
        old_std_buf_printf(&(src_pink_gen_buf), "};");
        src_pink_genln();
        src_pink_genln();
        old_std_buf_printf(&(src_pink_gen_buf), "int num_typeinfos = %d;", num_typeinfos);
        src_pink_genln();
        old_std_buf_printf(&(src_pink_gen_buf), "const TypeInfo **typeinfos = (const TypeInfo **)typeinfo_table;");
    }
}

void src_pink_gen_package_external_names(void) {
    for (size_t i = 0; (i) < (old_std_buf_len(src_pink_package_list)); (i)++) {
    }
}

void src_pink_gen_preamble(void) {
    old_std_buf_printf(&(src_pink_gen_buf), "%s", src_pink_gen_preamble_str);
    if (src_pink_gen_preamble_buf) {
        src_pink_genln();
        src_pink_genln();
        old_std_buf_printf(&(src_pink_gen_buf), "// Foreign preamble");
        src_pink_genln();
        old_std_buf_printf(&(src_pink_gen_buf), "%s", src_pink_gen_preamble_buf);
    }
}

void src_pink_gen_postamble(void) {
    old_std_buf_printf(&(src_pink_gen_buf), "%s", src_pink_gen_postamble_str);
    if (src_pink_gen_postamble_buf) {
        src_pink_genln();
        src_pink_genln();
        old_std_buf_printf(&(src_pink_gen_buf), "// Foreign postamble");
        src_pink_genln();
        old_std_buf_printf(&(src_pink_gen_buf), "%s", src_pink_gen_postamble_buf);
    }
}

void src_pink_gen_all(void) {
    src_pink_preprocess_packages();
    src_pink_gen_buf = NULL;
    src_pink_gen_preamble();
    src_pink_gen_foreign_headers();
    src_pink_genln();
    src_pink_genln();
    old_std_buf_printf(&(src_pink_gen_buf), "// Forward declarations");
    src_pink_gen_forward_decls();
    src_pink_genln();
    src_pink_genln();
    old_std_buf_printf(&(src_pink_gen_buf), "// Sorted declarations");
    src_pink_gen_sorted_decls();
    src_pink_genln();
    old_std_buf_printf(&(src_pink_gen_buf), "// Typeinfo");
    src_pink_gen_typeinfos();
    src_pink_genln();
    src_pink_genln();
    old_std_buf_printf(&(src_pink_gen_buf), "// Definitions");
    src_pink_gen_defs();
    src_pink_genln();
    old_std_buf_printf(&(src_pink_gen_buf), "// Foreign source files");
    src_pink_gen_foreign_sources();
    src_pink_genln();
    src_pink_gen_postamble();
}

char const ((*src_pink_typedef_keyword));
char const ((*src_pink_enum_keyword));
char const ((*src_pink_struct_keyword));
char const ((*src_pink_union_keyword));
char const ((*src_pink_var_keyword));
char const ((*src_pink_const_keyword));
char const ((*src_pink_func_keyword));
char const ((*src_pink_sizeof_keyword));
char const ((*src_pink_alignof_keyword));
char const ((*src_pink_typeof_keyword));
char const ((*src_pink_offsetof_keyword));
char const ((*src_pink_break_keyword));
char const ((*src_pink_continue_keyword));
char const ((*src_pink_return_keyword));
char const ((*src_pink_if_keyword));
char const ((*src_pink_else_keyword));
char const ((*src_pink_while_keyword));
char const ((*src_pink_do_keyword));
char const ((*src_pink_for_keyword));
char const ((*src_pink_switch_keyword));
char const ((*src_pink_case_keyword));
char const ((*src_pink_default_keyword));
char const ((*src_pink_import_keyword));
char const ((*src_pink_goto_keyword));
char const ((*src_pink_first_keyword));
char const ((*src_pink_last_keyword));
char const ((*(*src_pink_keywords)));
char const ((*src_pink_always_name));
char const ((*src_pink_foreign_name));
char const ((*src_pink_complete_name));
char const ((*src_pink_assert_name));
char const ((*src_pink_declare_note_name));
char const ((*src_pink_static_assert_name));
char const ((*src_pink_init_keyword(char const ((*keyword))))) {
    keyword = old_std_str_intern(keyword);
    old_std_buf_push((void (**))(&(src_pink_keywords)), (void *)(&(keyword)), sizeof(keyword));
    return keyword;
}

bool src_pink_keywords_inited = false;
void src_pink_init_keywords(void) {
    if (src_pink_keywords_inited) {
        return;
    }
    src_pink_typedef_keyword = src_pink_init_keyword("typedef");
    char (*arena_end) = old_std_intern_arena.end;
    src_pink_enum_keyword = src_pink_init_keyword("enum");
    src_pink_struct_keyword = src_pink_init_keyword("struct");
    src_pink_union_keyword = src_pink_init_keyword("union");
    src_pink_const_keyword = src_pink_init_keyword("const");
    src_pink_var_keyword = src_pink_init_keyword("var");
    src_pink_func_keyword = src_pink_init_keyword("fun");
    src_pink_import_keyword = src_pink_init_keyword("import");
    src_pink_goto_keyword = src_pink_init_keyword("goto");
    src_pink_sizeof_keyword = src_pink_init_keyword("sizeof");
    src_pink_alignof_keyword = src_pink_init_keyword("alignof");
    src_pink_typeof_keyword = src_pink_init_keyword("typeof");
    src_pink_offsetof_keyword = src_pink_init_keyword("offsetof");
    src_pink_break_keyword = src_pink_init_keyword("break");
    src_pink_continue_keyword = src_pink_init_keyword("continue");
    src_pink_return_keyword = src_pink_init_keyword("return");
    src_pink_if_keyword = src_pink_init_keyword("if");
    src_pink_else_keyword = src_pink_init_keyword("else");
    src_pink_while_keyword = src_pink_init_keyword("while");
    src_pink_do_keyword = src_pink_init_keyword("do");
    src_pink_for_keyword = src_pink_init_keyword("for");
    src_pink_switch_keyword = src_pink_init_keyword("switch");
    src_pink_case_keyword = src_pink_init_keyword("case");
    src_pink_default_keyword = src_pink_init_keyword("default");
    src_pink_first_keyword = src_pink_typedef_keyword;
    src_pink_last_keyword = src_pink_default_keyword;
    src_pink_always_name = old_std_str_intern("always");
    src_pink_foreign_name = old_std_str_intern("foreign");
    src_pink_complete_name = old_std_str_intern("complete");
    src_pink_assert_name = old_std_str_intern("assert");
    src_pink_declare_note_name = old_std_str_intern("declare_note");
    src_pink_static_assert_name = old_std_str_intern("static_assert");
    src_pink_keywords_inited = true;
}

bool src_pink_is_keyword_name(char const ((*name))) {
    return ((src_pink_first_keyword) <= (name)) && ((name) <= (src_pink_last_keyword));
}

char const ((*(src_pink_token_suffix_names[7]))) = {[SRC_PINK_SUFFIX_NONE] = "", [SRC_PINK_SUFFIX_D] = "d", [SRC_PINK_SUFFIX_U] = "u", [SRC_PINK_SUFFIX_L] = "l", [SRC_PINK_SUFFIX_UL] = "ul", [SRC_PINK_SUFFIX_LL] = "ll", [SRC_PINK_SUFFIX_ULL] = "ull"};
char const ((*(src_pink_token_kind_names[54]))) = {[SRC_PINK_TOKEN_EOF] = "EOF", [SRC_PINK_TOKEN_COLON] = ":", [SRC_PINK_TOKEN_LPAREN] = "(", [SRC_PINK_TOKEN_RPAREN] = ")", [SRC_PINK_TOKEN_LBRACE] = "{", [SRC_PINK_TOKEN_RBRACE] = "}", [SRC_PINK_TOKEN_LBRACKET] = "[", [SRC_PINK_TOKEN_RBRACKET] = "]", [SRC_PINK_TOKEN_COMMA] = ",", [SRC_PINK_TOKEN_DOT] = ".", [SRC_PINK_TOKEN_AT] = "@", [SRC_PINK_TOKEN_POUND] = "#", [SRC_PINK_TOKEN_ELLIPSIS] = "...", [SRC_PINK_TOKEN_QUESTION] = "?", [SRC_PINK_TOKEN_SEMICOLON] = ";", [SRC_PINK_TOKEN_KEYWORD] = "keyword", [SRC_PINK_TOKEN_INT] = "int", [SRC_PINK_TOKEN_FLOAT] = "float", [SRC_PINK_TOKEN_STR] = "string", [SRC_PINK_TOKEN_NAME] = "name", [SRC_PINK_TOKEN_NEG] = "~", [SRC_PINK_TOKEN_NOT] = "!", [SRC_PINK_TOKEN_MUL] = "*", [SRC_PINK_TOKEN_DIV] = "/", [SRC_PINK_TOKEN_MOD] = "%", [SRC_PINK_TOKEN_AND] = "&", [SRC_PINK_TOKEN_LSHIFT] = "<<", [SRC_PINK_TOKEN_RSHIFT] = ">>", [SRC_PINK_TOKEN_ADD] = "+", [SRC_PINK_TOKEN_SUB] = "-", [SRC_PINK_TOKEN_OR] = "|", [SRC_PINK_TOKEN_XOR] = "^", [SRC_PINK_TOKEN_EQ] = "==", [SRC_PINK_TOKEN_NOTEQ] = "!=", [SRC_PINK_TOKEN_LT] = "<", [SRC_PINK_TOKEN_GT] = ">", [SRC_PINK_TOKEN_LTEQ] = "<=", [SRC_PINK_TOKEN_GTEQ] = ">=", [SRC_PINK_TOKEN_AND_AND] = "&&", [SRC_PINK_TOKEN_OR_OR] = "||", [SRC_PINK_TOKEN_ASSIGN] = "=", [SRC_PINK_TOKEN_ADD_ASSIGN] = "+=", [SRC_PINK_TOKEN_SUB_ASSIGN] = "-=", [SRC_PINK_TOKEN_OR_ASSIGN] = "|=", [SRC_PINK_TOKEN_AND_ASSIGN] = "&=", [SRC_PINK_TOKEN_XOR_ASSIGN] = "^=", [SRC_PINK_TOKEN_MUL_ASSIGN] = "*=", [SRC_PINK_TOKEN_DIV_ASSIGN] = "/=", [SRC_PINK_TOKEN_MOD_ASSIGN] = "%=", [SRC_PINK_TOKEN_LSHIFT_ASSIGN] = "<<=", [SRC_PINK_TOKEN_RSHIFT_ASSIGN] = ">>=", [SRC_PINK_TOKEN_INC] = "++", [SRC_PINK_TOKEN_DEC] = "--", [SRC_PINK_TOKEN_COLON_ASSIGN] = ":="};
char const ((*src_pink_token_kind_name(src_pink_TokenKind kind))) {
    if ((kind) < ((sizeof(src_pink_token_kind_names)) / (sizeof(*(src_pink_token_kind_names))))) {
        return src_pink_token_kind_names[kind];
    } else {
        return "<unknown>";
    }
}

src_pink_TokenKind (src_pink_assign_token_to_binary_token[SRC_PINK_NUM_TOKEN_KINDS]) = {[SRC_PINK_TOKEN_ADD_ASSIGN] = SRC_PINK_TOKEN_ADD, [SRC_PINK_TOKEN_SUB_ASSIGN] = SRC_PINK_TOKEN_SUB, [SRC_PINK_TOKEN_OR_ASSIGN] = SRC_PINK_TOKEN_OR, [SRC_PINK_TOKEN_AND_ASSIGN] = SRC_PINK_TOKEN_AND, [SRC_PINK_TOKEN_XOR_ASSIGN] = SRC_PINK_TOKEN_XOR, [SRC_PINK_TOKEN_LSHIFT_ASSIGN] = SRC_PINK_TOKEN_LSHIFT, [SRC_PINK_TOKEN_RSHIFT_ASSIGN] = SRC_PINK_TOKEN_RSHIFT, [SRC_PINK_TOKEN_MUL_ASSIGN] = SRC_PINK_TOKEN_MUL, [SRC_PINK_TOKEN_DIV_ASSIGN] = SRC_PINK_TOKEN_DIV, [SRC_PINK_TOKEN_MOD_ASSIGN] = SRC_PINK_TOKEN_MOD};
src_pink_SrcPos src_pink_pos_builtin = {.name = "<builtin>"};
src_pink_Token src_pink_token;
char const ((*src_pink_stream));
char const ((*src_pink_line_start));
void src_pink_vnotice(char const ((*level)), src_pink_SrcPos pos, char const ((*fmt)), va_list args) {
    if ((pos.name) == (NULL)) {
        pos = src_pink_pos_builtin;
    }
    printf("%s(%d): %s: ", pos.name, pos.line, level);
    vprintf(fmt, args);
    printf("\n");
}

void src_pink_warning(src_pink_SrcPos pos, char const ((*fmt)), ...) {
    va_list args = {0};
    va_start_ptr(&(args), &(fmt));
    src_pink_vnotice("warning", pos, fmt, args);
    va_end_ptr(&(args));
}

void src_pink_verror(src_pink_SrcPos pos, char const ((*fmt)), va_list args) {
    src_pink_vnotice("error", pos, fmt, args);
}

void src_pink_error(src_pink_SrcPos pos, char const ((*fmt)), ...) {
    va_list args = {0};
    va_start_ptr(&(args), &(fmt));
    src_pink_verror(pos, fmt, args);
    va_end_ptr(&(args));
}

void src_pink_fatal_error(src_pink_SrcPos pos, char const ((*fmt)), ...) {
    va_list args = {0};
    va_start_ptr(&(args), &(fmt));
    src_pink_verror(pos, fmt, args);
    va_end_ptr(&(args));
    exit(1);
}

char const ((*src_pink_token_info(void))) {
    if (((src_pink_token.kind) == (SRC_PINK_TOKEN_NAME)) || ((src_pink_token.kind) == (SRC_PINK_TOKEN_KEYWORD))) {
        return src_pink_token.name;
    } else {
        return src_pink_token_kind_name(src_pink_token.kind);
    }
}

uint8_t (src_pink_char_to_digit[256]) = {['0'] = 0, ['1'] = 1, ['2'] = 2, ['3'] = 3, ['4'] = 4, ['5'] = 5, ['6'] = 6, ['7'] = 7, ['8'] = 8, ['9'] = 9, ['a'] = 10, ['A'] = 10, ['b'] = 11, ['B'] = 11, ['c'] = 12, ['C'] = 12, ['d'] = 13, ['D'] = 13, ['e'] = 14, ['E'] = 14, ['f'] = 15, ['F'] = 15};
void src_pink_scan_int(void) {
    int base = 10;
    char const ((*start_digits)) = src_pink_stream;
    if ((*(src_pink_stream)) == ('0')) {
        (src_pink_stream)++;
        if ((tolower(*(src_pink_stream))) == ('x')) {
            (src_pink_stream)++;
            src_pink_token.mod = SRC_PINK_MOD_HEX;
            base = 16;
            start_digits = src_pink_stream;
        } else if ((tolower(*(src_pink_stream))) == ('b')) {
            (src_pink_stream)++;
            src_pink_token.mod = SRC_PINK_MOD_BIN;
            base = 2;
            start_digits = src_pink_stream;
        } else if (isdigit(*(src_pink_stream))) {
            src_pink_token.mod = SRC_PINK_MOD_OCT;
            base = 8;
            start_digits = src_pink_stream;
        }
    }
    ullong val = 0;
    for (;;) {
        if ((*(src_pink_stream)) == ('_')) {
            (src_pink_stream)++;
            continue;
        }
        uchar digit = src_pink_char_to_digit[(uchar)(*(src_pink_stream))];
        if (((digit) == (0)) && ((*(src_pink_stream)) != ('0'))) {
            break;
        }
        if ((digit) >= (base)) {
            src_pink_error(src_pink_token.pos, "Digit \'%c\' out of range for base %d", *(src_pink_stream), base);
            digit = 0;
        }
        if ((val) > ((((ULLONG_MAX) - (digit))) / (base))) {
            src_pink_error(src_pink_token.pos, "Integer literal overflow");
            while (isdigit(*(src_pink_stream))) {
                (src_pink_stream)++;
            }
            val = 0;
            break;
        }
        val = ((val) * (base)) + (digit);
        (src_pink_stream)++;
    }
    if ((src_pink_stream) == (start_digits)) {
        src_pink_error(src_pink_token.pos, "Expected base %d digit, got \'%c\'", base, *(src_pink_stream));
    }
    src_pink_token.kind = SRC_PINK_TOKEN_INT;
    src_pink_token.int_val = val;
    if ((tolower(*(src_pink_stream))) == ('u')) {
        src_pink_token.suffix = SRC_PINK_SUFFIX_U;
        (src_pink_stream)++;
        if ((tolower(*(src_pink_stream))) == ('l')) {
            src_pink_token.suffix = SRC_PINK_SUFFIX_UL;
            (src_pink_stream)++;
            if ((tolower(*(src_pink_stream))) == ('l')) {
                src_pink_token.suffix = SRC_PINK_SUFFIX_ULL;
                (src_pink_stream)++;
            }
        }
    } else if ((tolower(*(src_pink_stream))) == ('l')) {
        src_pink_token.suffix = SRC_PINK_SUFFIX_L;
        (src_pink_stream)++;
        if ((tolower(*(src_pink_stream))) == ('l')) {
            src_pink_token.suffix = SRC_PINK_SUFFIX_LL;
            (src_pink_stream)++;
        }
    }
}

void src_pink_scan_float(void) {
    char const ((*start)) = src_pink_stream;
    while (isdigit(*(src_pink_stream))) {
        (src_pink_stream)++;
    }
    if ((*(src_pink_stream)) == ('.')) {
        (src_pink_stream)++;
    }
    while (isdigit(*(src_pink_stream))) {
        (src_pink_stream)++;
    }
    if ((tolower(*(src_pink_stream))) == ('e')) {
        (src_pink_stream)++;
        if (((*(src_pink_stream)) == ('+')) || ((*(src_pink_stream)) == ('-'))) {
            (src_pink_stream)++;
        }
        if (!(isdigit(*(src_pink_stream)))) {
            src_pink_error(src_pink_token.pos, "Expected digit after float literal exponent, found \'%c\'.", *(src_pink_stream));
        }
        while (isdigit(*(src_pink_stream))) {
            (src_pink_stream)++;
        }
    }
    double val = strtod(start, NULL);
    if ((val) == (HUGE_VAL)) {
        src_pink_error(src_pink_token.pos, "Float literal overflow");
    }
    src_pink_token.kind = SRC_PINK_TOKEN_FLOAT;
    src_pink_token.float_val = val;
    if ((tolower(*(src_pink_stream))) == ('d')) {
        src_pink_token.suffix = SRC_PINK_SUFFIX_D;
        (src_pink_stream)++;
    }
}

char (src_pink_escape_to_char[256]) = {['0'] = '\0', ['\''] = '\'', ['\"'] = '\"', ['\\'] = '\\', ['n'] = '\n', ['r'] = '\r', ['t'] = '\t', ['v'] = '\v', ['b'] = '\b', ['a'] = '\a'};
int src_pink_scan_hex_escape(void) {
    (src_pink_stream)++;
    uchar val = src_pink_char_to_digit[(uchar)(*(src_pink_stream))];
    if ((!(val)) && ((*(src_pink_stream)) != ('0'))) {
        src_pink_error(src_pink_token.pos, "\\x needs at least 1 hex digit");
    }
    (src_pink_stream)++;
    uchar digit = src_pink_char_to_digit[(uchar)(*(src_pink_stream))];
    if ((digit) || ((*(src_pink_stream)) == ('0'))) {
        val *= 16;
        val += digit;
        if ((val) > (0xff)) {
            src_pink_error(src_pink_token.pos, "\\x argument out of range");
            val = 0xff;
        }
        (src_pink_stream)++;
    }
    return val;
}

void src_pink_scan_char(void) {
    (src_pink_stream)++;
    int val = 0;
    if ((*(src_pink_stream)) == ('\'')) {
        src_pink_error(src_pink_token.pos, "Char literal cannot be empty");
        (src_pink_stream)++;
    } else if ((*(src_pink_stream)) == ('\n')) {
        src_pink_error(src_pink_token.pos, "Char literal cannot contain newline");
    } else if ((*(src_pink_stream)) == ('\\')) {
        (src_pink_stream)++;
        if ((*(src_pink_stream)) == ('x')) {
            val = src_pink_scan_hex_escape();
        } else {
            val = src_pink_escape_to_char[(uchar)(*(src_pink_stream))];
            if (((val) == (0)) && ((*(src_pink_stream)) != ('0'))) {
                src_pink_error(src_pink_token.pos, "Invalid char literal escape \'\\%c\'", *(src_pink_stream));
            }
            (src_pink_stream)++;
        }
    } else {
        val = *(src_pink_stream);
        (src_pink_stream)++;
    }
    if ((*(src_pink_stream)) != ('\'')) {
        src_pink_error(src_pink_token.pos, "Expected closing char quote, got \'%c\'", *(src_pink_stream));
    } else {
        (src_pink_stream)++;
    }
    src_pink_token.kind = SRC_PINK_TOKEN_INT;
    src_pink_token.int_val = val;
    src_pink_token.mod = SRC_PINK_MOD_CHAR;
}

void src_pink_scan_str(void) {
    (src_pink_stream)++;
    char (*str) = NULL;
    if (((src_pink_stream[0]) == ('\"')) && ((src_pink_stream[1]) == ('\"'))) {
        src_pink_stream += 2;
        while (*(src_pink_stream)) {
            if ((((src_pink_stream[0]) == ('\"')) && ((src_pink_stream[1]) == ('\"'))) && ((src_pink_stream[2]) == ('\"'))) {
                src_pink_stream += 3;
                break;
            }
            if ((*(src_pink_stream)) != ('\r')) {
                old_std_buf_push((void (**))(&(str)), (void *)(src_pink_stream), 1);
            }
            if ((*(src_pink_stream)) == ('\n')) {
                (src_pink_token.pos.line)++;
            }
            (src_pink_stream)++;
        }
        if (!(*(src_pink_stream))) {
            src_pink_error(src_pink_token.pos, "Unexpected end of file within multi-line string literal");
        }
        src_pink_token.mod = SRC_PINK_MOD_MULTILINE;
    } else {
        while ((*(src_pink_stream)) && ((*(src_pink_stream)) != ('\"'))) {
            char val = *(src_pink_stream);
            if ((val) == ('\n')) {
                src_pink_error(src_pink_token.pos, "String literal cannot contain newline");
                break;
            } else if ((val) == ('\\')) {
                (src_pink_stream)++;
                if ((*(src_pink_stream)) == ('x')) {
                    val = src_pink_scan_hex_escape();
                } else {
                    val = src_pink_escape_to_char[(uchar)(*(src_pink_stream))];
                    if (((val) == (0)) && ((*(src_pink_stream)) != ('0'))) {
                        src_pink_error(src_pink_token.pos, "Invalid string literal escape \'\\%c\'", *(src_pink_stream));
                    }
                    (src_pink_stream)++;
                }
            } else {
                (src_pink_stream)++;
            }
            old_std_buf_push((void (**))(&(str)), &(val), 1);
        }
        if (*(src_pink_stream)) {
            (src_pink_stream)++;
        } else {
            src_pink_error(src_pink_token.pos, "Unexpected end of file within string literal");
        }
    }
    int nul = '\0';
    old_std_buf_push((void (**))(&(str)), &(nul), 1);
    src_pink_token.kind = SRC_PINK_TOKEN_STR;
    src_pink_token.str_val = str;
}

void src_pink_next_token(void) {
    repeat: ;
    src_pink_token.start = src_pink_stream;
    src_pink_token.mod = 0;
    src_pink_token.suffix = 0;
    switch (*(src_pink_stream)) {
    case ' ':
    case '\n':
    case '\r':
    case '\t':
    case '\v': {
        while (isspace(*(src_pink_stream))) {
            if ((*((src_pink_stream)++)) == ('\n')) {
                src_pink_line_start = src_pink_stream;
                (src_pink_token.pos.line)++;
            }
        }
        goto repeat;
        break;
    }
    case '\'': {
        src_pink_scan_char();
        break;
    }
    case '\"': {
        src_pink_scan_str();
        break;
    }
    case '.': {
        if (isdigit(src_pink_stream[1])) {
            src_pink_scan_float();
        } else if (((src_pink_stream[1]) == ('.')) && ((src_pink_stream[2]) == ('.'))) {
            src_pink_token.kind = SRC_PINK_TOKEN_ELLIPSIS;
            src_pink_stream += 3;
        } else {
            src_pink_token.kind = SRC_PINK_TOKEN_DOT;
            (src_pink_stream)++;
        }
        break;
    }
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9': {
        {
            while (isdigit(*(src_pink_stream))) {
                (src_pink_stream)++;
            }
            char c = *(src_pink_stream);
            src_pink_stream = src_pink_token.start;
            if (((c) == ('.')) || ((tolower(c)) == ('e'))) {
                src_pink_scan_float();
            } else {
                src_pink_scan_int();
            }
        }
        break;
    }
    case 'a':
    case 'b':
    case 'c':
    case 'd':
    case 'e':
    case 'f':
    case 'g':
    case 'h':
    case 'i':
    case 'j':
    case 'k':
    case 'l':
    case 'm':
    case 'n':
    case 'o':
    case 'p':
    case 'q':
    case 'r':
    case 's':
    case 't':
    case 'u':
    case 'v':
    case 'w':
    case 'x':
    case 'y':
    case 'z':
    case 'A':
    case 'B':
    case 'C':
    case 'D':
    case 'E':
    case 'F':
    case 'G':
    case 'H':
    case 'I':
    case 'J':
    case 'K':
    case 'L':
    case 'M':
    case 'N':
    case 'O':
    case 'P':
    case 'Q':
    case 'R':
    case 'S':
    case 'T':
    case 'U':
    case 'V':
    case 'W':
    case 'X':
    case 'Y':
    case 'Z':
    case '_': {
        while ((isalnum(*(src_pink_stream))) || ((*(src_pink_stream)) == ('_'))) {
            (src_pink_stream)++;
        }
        src_pink_token.name = old_std_str_intern_range(src_pink_token.start, src_pink_stream);
        src_pink_token.kind = (src_pink_is_keyword_name(src_pink_token.name) ? SRC_PINK_TOKEN_KEYWORD : SRC_PINK_TOKEN_NAME);
        break;
    }
    case '<': {
        src_pink_token.kind = SRC_PINK_TOKEN_LT;
        (src_pink_stream)++;
        if ((*(src_pink_stream)) == ('<')) {
            src_pink_token.kind = SRC_PINK_TOKEN_LSHIFT;
            (src_pink_stream)++;
            if ((*(src_pink_stream)) == ('=')) {
                src_pink_token.kind = SRC_PINK_TOKEN_LSHIFT_ASSIGN;
                (src_pink_stream)++;
            }
        } else if ((*(src_pink_stream)) == ('=')) {
            src_pink_token.kind = SRC_PINK_TOKEN_LTEQ;
            (src_pink_stream)++;
        }
        break;
    }
    case '>': {
        src_pink_token.kind = SRC_PINK_TOKEN_GT;
        (src_pink_stream)++;
        if ((*(src_pink_stream)) == ('>')) {
            src_pink_token.kind = SRC_PINK_TOKEN_RSHIFT;
            (src_pink_stream)++;
            if ((*(src_pink_stream)) == ('=')) {
                src_pink_token.kind = SRC_PINK_TOKEN_RSHIFT_ASSIGN;
                (src_pink_stream)++;
            }
        } else if ((*(src_pink_stream)) == ('=')) {
            src_pink_token.kind = SRC_PINK_TOKEN_GTEQ;
            (src_pink_stream)++;
        }
        break;
    }
    case '/': {
        src_pink_token.kind = SRC_PINK_TOKEN_DIV;
        (src_pink_stream)++;
        if ((*(src_pink_stream)) == ('=')) {
            src_pink_token.kind = SRC_PINK_TOKEN_DIV_ASSIGN;
            (src_pink_stream)++;
        } else if ((*(src_pink_stream)) == ('/')) {
            (src_pink_stream)++;
            while ((*(src_pink_stream)) && ((*(src_pink_stream)) != ('\n'))) {
                (src_pink_stream)++;
            }
            goto repeat;
        } else if ((*(src_pink_stream)) == ('*')) {
            (src_pink_stream)++;
            int level = 1;
            while ((*(src_pink_stream)) && ((level) > (0))) {
                if (((src_pink_stream[0]) == ('/')) && ((src_pink_stream[1]) == ('*'))) {
                    (level)++;
                    src_pink_stream += 2;
                } else if (((src_pink_stream[0]) == ('*')) && ((src_pink_stream[1]) == ('/'))) {
                    (level)--;
                    src_pink_stream += 2;
                } else {
                    if ((*(src_pink_stream)) == ('\n')) {
                        (src_pink_token.pos.line)++;
                    }
                    (src_pink_stream)++;
                }
            }
            goto repeat;
        }
        break;
    }
    case '\0': {
        src_pink_token.kind = SRC_PINK_TOKEN_EOF;
        (src_pink_stream)++;
        break;
    }
    case '(': {
        src_pink_token.kind = SRC_PINK_TOKEN_LPAREN;
        (src_pink_stream)++;
        break;
    }
    case ')': {
        src_pink_token.kind = SRC_PINK_TOKEN_RPAREN;
        (src_pink_stream)++;
        break;
    }
    case '{': {
        src_pink_token.kind = SRC_PINK_TOKEN_LBRACE;
        (src_pink_stream)++;
        break;
    }
    case '}': {
        src_pink_token.kind = SRC_PINK_TOKEN_RBRACE;
        (src_pink_stream)++;
        break;
    }
    case '[': {
        src_pink_token.kind = SRC_PINK_TOKEN_LBRACKET;
        (src_pink_stream)++;
        break;
    }
    case ']': {
        src_pink_token.kind = SRC_PINK_TOKEN_RBRACKET;
        (src_pink_stream)++;
        break;
    }
    case ',': {
        src_pink_token.kind = SRC_PINK_TOKEN_COMMA;
        (src_pink_stream)++;
        break;
    }
    case '@': {
        src_pink_token.kind = SRC_PINK_TOKEN_AT;
        (src_pink_stream)++;
        break;
    }
    case '#': {
        src_pink_token.kind = SRC_PINK_TOKEN_POUND;
        (src_pink_stream)++;
        break;
    }
    case '?': {
        src_pink_token.kind = SRC_PINK_TOKEN_QUESTION;
        (src_pink_stream)++;
        break;
    }
    case ';': {
        src_pink_token.kind = SRC_PINK_TOKEN_SEMICOLON;
        (src_pink_stream)++;
        break;
    }
    case '~': {
        src_pink_token.kind = SRC_PINK_TOKEN_NEG;
        (src_pink_stream)++;
        break;
    }
    case '!': {
        src_pink_token.kind = SRC_PINK_TOKEN_NOT;
        (src_pink_stream)++;
        if ((*(src_pink_stream)) == ('=')) {
            src_pink_token.kind = SRC_PINK_TOKEN_NOTEQ;
            (src_pink_stream)++;
        }
        break;
    }
    case ':': {
        src_pink_token.kind = SRC_PINK_TOKEN_COLON;
        (src_pink_stream)++;
        if ((*(src_pink_stream)) == ('=')) {
            src_pink_token.kind = SRC_PINK_TOKEN_COLON_ASSIGN;
            (src_pink_stream)++;
        }
        break;
    }
    case '=': {
        src_pink_token.kind = SRC_PINK_TOKEN_ASSIGN;
        (src_pink_stream)++;
        if ((*(src_pink_stream)) == ('=')) {
            src_pink_token.kind = SRC_PINK_TOKEN_EQ;
            (src_pink_stream)++;
        }
        break;
    }
    case '^': {
        src_pink_token.kind = SRC_PINK_TOKEN_XOR;
        (src_pink_stream)++;
        if ((*(src_pink_stream)) == ('=')) {
            src_pink_token.kind = SRC_PINK_TOKEN_XOR_ASSIGN;
            (src_pink_stream)++;
        }
        break;
    }
    case '*': {
        src_pink_token.kind = SRC_PINK_TOKEN_MUL;
        (src_pink_stream)++;
        if ((*(src_pink_stream)) == ('=')) {
            src_pink_token.kind = SRC_PINK_TOKEN_MUL_ASSIGN;
            (src_pink_stream)++;
        }
        break;
    }
    case '%': {
        src_pink_token.kind = SRC_PINK_TOKEN_MOD;
        (src_pink_stream)++;
        if ((*(src_pink_stream)) == ('=')) {
            src_pink_token.kind = SRC_PINK_TOKEN_MOD_ASSIGN;
            (src_pink_stream)++;
        }
        break;
    }
    case '+': {
        src_pink_token.kind = SRC_PINK_TOKEN_ADD;
        (src_pink_stream)++;
        if ((*(src_pink_stream)) == ('=')) {
            src_pink_token.kind = SRC_PINK_TOKEN_ADD_ASSIGN;
            (src_pink_stream)++;
        } else if ((*(src_pink_stream)) == ('+')) {
            src_pink_token.kind = SRC_PINK_TOKEN_INC;
            (src_pink_stream)++;
        }
        break;
    }
    case '-': {
        src_pink_token.kind = SRC_PINK_TOKEN_SUB;
        (src_pink_stream)++;
        if ((*(src_pink_stream)) == ('=')) {
            src_pink_token.kind = SRC_PINK_TOKEN_SUB_ASSIGN;
            (src_pink_stream)++;
        } else if ((*(src_pink_stream)) == ('-')) {
            src_pink_token.kind = SRC_PINK_TOKEN_DEC;
            (src_pink_stream)++;
        }
        break;
    }
    case '&': {
        src_pink_token.kind = SRC_PINK_TOKEN_AND;
        (src_pink_stream)++;
        if ((*(src_pink_stream)) == ('=')) {
            src_pink_token.kind = SRC_PINK_TOKEN_AND_ASSIGN;
            (src_pink_stream)++;
        } else if ((*(src_pink_stream)) == ('&')) {
            src_pink_token.kind = SRC_PINK_TOKEN_AND_AND;
            (src_pink_stream)++;
        }
        break;
    }
    case '|': {
        src_pink_token.kind = SRC_PINK_TOKEN_OR;
        (src_pink_stream)++;
        if ((*(src_pink_stream)) == ('=')) {
            src_pink_token.kind = SRC_PINK_TOKEN_OR_ASSIGN;
            (src_pink_stream)++;
        } else if ((*(src_pink_stream)) == ('|')) {
            src_pink_token.kind = SRC_PINK_TOKEN_OR_OR;
            (src_pink_stream)++;
        }
        break;
    }
    default: {
        src_pink_error(src_pink_token.pos, "Invalid \'%c\' token, skipping", *(src_pink_stream));
        (src_pink_stream)++;
        goto repeat;
        break;
    }
    }
    src_pink_token.end = src_pink_stream;
}

void src_pink_init_stream(char const ((*name)), char const ((*buf))) {
    src_pink_stream = buf;
    src_pink_line_start = src_pink_stream;
    src_pink_token.pos.name = (name ? name : (char const (*))("<string>"));
    src_pink_token.pos.line = 1;
    src_pink_next_token();
}

bool src_pink_is_token(src_pink_TokenKind kind) {
    return (src_pink_token.kind) == (kind);
}

bool src_pink_is_token_eof(void) {
    return (src_pink_token.kind) == (SRC_PINK_TOKEN_EOF);
}

bool src_pink_is_token_name(char const ((*name))) {
    return ((src_pink_token.kind) == (SRC_PINK_TOKEN_NAME)) && ((src_pink_token.name) == (name));
}

bool src_pink_is_keyword(char const ((*name))) {
    return (src_pink_is_token(SRC_PINK_TOKEN_KEYWORD)) && ((src_pink_token.name) == (name));
}

bool src_pink_match_keyword(char const ((*name))) {
    if (src_pink_is_keyword(name)) {
        src_pink_next_token();
        return true;
    } else {
        return false;
    }
}

bool src_pink_match_token(src_pink_TokenKind kind) {
    if (src_pink_is_token(kind)) {
        src_pink_next_token();
        return true;
    } else {
        return false;
    }
}

bool src_pink_expect_token(src_pink_TokenKind kind) {
    if (src_pink_is_token(kind)) {
        src_pink_next_token();
        return true;
    } else {
        src_pink_fatal_error(src_pink_token.pos, "Expected token %s, got %s", src_pink_token_kind_name(kind), src_pink_token_info());
        return false;
    }
}

bool src_pink_flag_verbose;
bool src_pink_flag_lazy;
bool src_pink_flag_nosourcemap;
bool src_pink_flag_notypeinfo;
bool src_pink_flag_fullgen;
src_pink_Typespec (*src_pink_parse_type_func_param(void)) {
    src_pink_Typespec (*type) = src_pink_parse_type();
    if (src_pink_match_token(SRC_PINK_TOKEN_COLON)) {
        if ((type->kind) != (SRC_PINK_TYPESPEC_NAME)) {
            src_pink_error(src_pink_token.pos, "Colons in parameters of fun types must be preceded by names.");
        }
        type = src_pink_parse_type();
    }
    return type;
}

src_pink_Typespec (*src_pink_parse_type_func(void)) {
    src_pink_SrcPos pos = src_pink_token.pos;
    src_pink_Typespec (*(*args)) = NULL;
    bool has_varargs = false;
    src_pink_expect_token(SRC_PINK_TOKEN_LPAREN);
    while (!(src_pink_is_token(SRC_PINK_TOKEN_RPAREN))) {
        if (src_pink_match_token(SRC_PINK_TOKEN_ELLIPSIS)) {
            if (has_varargs) {
                src_pink_error(src_pink_token.pos, "Multiple ellipsis instances in function type");
            }
            has_varargs = true;
        } else {
            if (has_varargs) {
                src_pink_error(src_pink_token.pos, "Ellipsis must be last parameter in function type");
            }
            src_pink_Typespec (*param) = src_pink_parse_type_func_param();
            old_std_buf_push((void (**))(&(args)), &(param), sizeof(param));
        }
        if (!(src_pink_match_token(SRC_PINK_TOKEN_COMMA))) {
            break;
        }
    }
    src_pink_expect_token(SRC_PINK_TOKEN_RPAREN);
    src_pink_Typespec (*ret) = NULL;
    if (src_pink_match_token(SRC_PINK_TOKEN_COLON)) {
        ret = src_pink_parse_type();
    }
    return src_pink_new_typespec_func(pos, args, old_std_buf_len(args), ret, has_varargs);
}

src_pink_Typespec (*src_pink_parse_type_base(void)) {
    if (src_pink_is_token(SRC_PINK_TOKEN_NAME)) {
        src_pink_SrcPos pos = src_pink_token.pos;
        char const ((*name)) = src_pink_token.name;
        src_pink_next_token();
        return src_pink_new_typespec_name(pos, name);
    } else if (src_pink_match_keyword(src_pink_func_keyword)) {
        return src_pink_parse_type_func();
    } else if (src_pink_match_token(SRC_PINK_TOKEN_LPAREN)) {
        src_pink_Typespec (*type) = src_pink_parse_type();
        src_pink_expect_token(SRC_PINK_TOKEN_RPAREN);
        return type;
    } else {
        src_pink_fatal_error(src_pink_token.pos, "Unexpected token %s in type", src_pink_token_info());
        return NULL;
    }
}

src_pink_Typespec (*src_pink_parse_type(void)) {
    src_pink_Typespec (*type) = src_pink_parse_type_base();
    src_pink_SrcPos pos = src_pink_token.pos;
    while (((src_pink_is_token(SRC_PINK_TOKEN_LBRACKET)) || (src_pink_is_token(SRC_PINK_TOKEN_MUL))) || (src_pink_is_keyword(src_pink_const_keyword))) {
        if (src_pink_match_token(SRC_PINK_TOKEN_LBRACKET)) {
            src_pink_Expr (*size) = NULL;
            if (!(src_pink_is_token(SRC_PINK_TOKEN_RBRACKET))) {
                size = src_pink_parse_expr();
            }
            src_pink_expect_token(SRC_PINK_TOKEN_RBRACKET);
            type = src_pink_new_typespec_array(pos, type, size);
        } else if (src_pink_match_keyword(src_pink_const_keyword)) {
            type = src_pink_new_typespec_const(pos, type);
        } else {
            src_pink_next_token();
            type = src_pink_new_typespec_ptr(pos, type);
        }
    }
    return type;
}

src_pink_CompoundField src_pink_parse_expr_compound_field(void) {
    src_pink_SrcPos pos = src_pink_token.pos;
    if (src_pink_match_token(SRC_PINK_TOKEN_LBRACKET)) {
        src_pink_Expr (*index) = src_pink_parse_expr();
        src_pink_expect_token(SRC_PINK_TOKEN_RBRACKET);
        src_pink_expect_token(SRC_PINK_TOKEN_ASSIGN);
        return (src_pink_CompoundField){SRC_PINK_FIELD_INDEX, pos, src_pink_parse_expr(), .index = index};
    } else {
        src_pink_Expr (*expr) = src_pink_parse_expr();
        if (src_pink_match_token(SRC_PINK_TOKEN_ASSIGN)) {
            if ((expr->kind) != (SRC_PINK_EXPR_NAME)) {
                src_pink_fatal_error(src_pink_token.pos, "Named initializer in compound literal must be preceded by field name");
            }
            return (src_pink_CompoundField){SRC_PINK_FIELD_NAME, pos, src_pink_parse_expr(), .name = expr->name};
        } else {
            return (src_pink_CompoundField){SRC_PINK_FIELD_DEFAULT, pos, expr};
        }
    }
}

src_pink_Expr (*src_pink_parse_expr_compound(src_pink_Typespec (*type))) {
    src_pink_SrcPos pos = src_pink_token.pos;
    src_pink_expect_token(SRC_PINK_TOKEN_LBRACE);
    src_pink_CompoundField (*fields) = NULL;
    while (!(src_pink_is_token(SRC_PINK_TOKEN_RBRACE))) {
        src_pink_CompoundField field = src_pink_parse_expr_compound_field();
        old_std_buf_push((void (**))(&(fields)), &(field), sizeof(field));
        if (!(src_pink_match_token(SRC_PINK_TOKEN_COMMA))) {
            break;
        }
    }
    src_pink_expect_token(SRC_PINK_TOKEN_RBRACE);
    return src_pink_new_expr_compound(pos, type, fields, old_std_buf_len(fields));
}

src_pink_Expr (*src_pink_parse_expr_operand(void)) {
    src_pink_SrcPos pos = src_pink_token.pos;
    if (src_pink_is_token(SRC_PINK_TOKEN_INT)) {
        ullong val = src_pink_token.int_val;
        src_pink_TokenMod mod = src_pink_token.mod;
        src_pink_TokenSuffix suffix = src_pink_token.suffix;
        src_pink_next_token();
        return src_pink_new_expr_int(pos, val, mod, suffix);
    } else if (src_pink_is_token(SRC_PINK_TOKEN_FLOAT)) {
        char const ((*start)) = src_pink_token.start;
        char const ((*end)) = src_pink_token.end;
        double val = src_pink_token.float_val;
        src_pink_TokenSuffix suffix = src_pink_token.suffix;
        src_pink_next_token();
        return src_pink_new_expr_float(pos, start, end, val, suffix);
    } else if (src_pink_is_token(SRC_PINK_TOKEN_STR)) {
        char const ((*val)) = src_pink_token.str_val;
        src_pink_TokenMod mod = src_pink_token.mod;
        src_pink_next_token();
        return src_pink_new_expr_str(pos, val, mod);
    } else if (src_pink_is_token(SRC_PINK_TOKEN_NAME)) {
        char const ((*name)) = src_pink_token.name;
        src_pink_next_token();
        if (src_pink_is_token(SRC_PINK_TOKEN_LBRACE)) {
            return src_pink_parse_expr_compound(src_pink_new_typespec_name(pos, name));
        } else {
            return src_pink_new_expr_name(pos, name);
        }
    } else if (src_pink_match_keyword(src_pink_sizeof_keyword)) {
        src_pink_expect_token(SRC_PINK_TOKEN_LPAREN);
        if (src_pink_match_token(SRC_PINK_TOKEN_COLON)) {
            src_pink_Typespec (*type) = src_pink_parse_type();
            src_pink_expect_token(SRC_PINK_TOKEN_RPAREN);
            return src_pink_new_expr_sizeof_type(pos, type);
        } else {
            src_pink_Expr (*expr) = src_pink_parse_expr();
            src_pink_expect_token(SRC_PINK_TOKEN_RPAREN);
            return src_pink_new_expr_sizeof_expr(pos, expr);
        }
    } else if (src_pink_match_keyword(src_pink_alignof_keyword)) {
        src_pink_expect_token(SRC_PINK_TOKEN_LPAREN);
        if (src_pink_match_token(SRC_PINK_TOKEN_COLON)) {
            src_pink_Typespec (*type) = src_pink_parse_type();
            src_pink_expect_token(SRC_PINK_TOKEN_RPAREN);
            return src_pink_new_expr_alignof_type(pos, type);
        } else {
            src_pink_Expr (*expr) = src_pink_parse_expr();
            src_pink_expect_token(SRC_PINK_TOKEN_RPAREN);
            return src_pink_new_expr_alignof_expr(pos, expr);
        }
    } else if (src_pink_match_keyword(src_pink_typeof_keyword)) {
        src_pink_expect_token(SRC_PINK_TOKEN_LPAREN);
        if (src_pink_match_token(SRC_PINK_TOKEN_COLON)) {
            src_pink_Typespec (*type) = src_pink_parse_type();
            src_pink_expect_token(SRC_PINK_TOKEN_RPAREN);
            return src_pink_new_expr_typeof_type(pos, type);
        } else {
            src_pink_Expr (*expr) = src_pink_parse_expr();
            src_pink_expect_token(SRC_PINK_TOKEN_RPAREN);
            return src_pink_new_expr_typeof_expr(pos, expr);
        }
    } else if (src_pink_match_keyword(src_pink_offsetof_keyword)) {
        src_pink_expect_token(SRC_PINK_TOKEN_LPAREN);
        src_pink_Typespec (*type) = src_pink_parse_type();
        src_pink_expect_token(SRC_PINK_TOKEN_COMMA);
        char const ((*name)) = src_pink_parse_name();
        src_pink_expect_token(SRC_PINK_TOKEN_RPAREN);
        return src_pink_new_expr_offsetof(pos, type, name);
    } else if (src_pink_is_token(SRC_PINK_TOKEN_LBRACE)) {
        return src_pink_parse_expr_compound(NULL);
    } else if (src_pink_match_token(SRC_PINK_TOKEN_LPAREN)) {
        if (src_pink_match_token(SRC_PINK_TOKEN_COLON)) {
            src_pink_Typespec (*type) = src_pink_parse_type();
            src_pink_expect_token(SRC_PINK_TOKEN_RPAREN);
            if (src_pink_is_token(SRC_PINK_TOKEN_LBRACE)) {
                return src_pink_parse_expr_compound(type);
            } else {
                return src_pink_new_expr_cast(pos, type, src_pink_parse_expr_unary());
            }
        } else {
            src_pink_Expr (*expr) = src_pink_parse_expr();
            src_pink_expect_token(SRC_PINK_TOKEN_RPAREN);
            return src_pink_new_expr_paren(pos, expr);
        }
    } else {
        src_pink_fatal_error(src_pink_token.pos, "Unexpected token %s in expression", src_pink_token_info());
        return NULL;
    }
}

src_pink_Expr (*src_pink_parse_expr_base(void)) {
    src_pink_Expr (*expr) = src_pink_parse_expr_operand();
    while (((((src_pink_is_token(SRC_PINK_TOKEN_LPAREN)) || (src_pink_is_token(SRC_PINK_TOKEN_LBRACKET))) || (src_pink_is_token(SRC_PINK_TOKEN_DOT))) || (src_pink_is_token(SRC_PINK_TOKEN_INC))) || (src_pink_is_token(SRC_PINK_TOKEN_DEC))) {
        src_pink_SrcPos pos = src_pink_token.pos;
        if (src_pink_match_token(SRC_PINK_TOKEN_LPAREN)) {
            src_pink_Expr (*(*args)) = NULL;
            while (!(src_pink_is_token(SRC_PINK_TOKEN_RPAREN))) {
                src_pink_Expr (*arg) = src_pink_parse_expr();
                old_std_buf_push((void (**))(&(args)), &(arg), sizeof(arg));
                if (!(src_pink_match_token(SRC_PINK_TOKEN_COMMA))) {
                    break;
                }
            }
            src_pink_expect_token(SRC_PINK_TOKEN_RPAREN);
            expr = src_pink_new_expr_call(pos, expr, args, old_std_buf_len(args));
        } else if (src_pink_match_token(SRC_PINK_TOKEN_LBRACKET)) {
            src_pink_Expr (*index) = src_pink_parse_expr();
            src_pink_expect_token(SRC_PINK_TOKEN_RBRACKET);
            expr = src_pink_new_expr_index(pos, expr, index);
        } else if (src_pink_is_token(SRC_PINK_TOKEN_DOT)) {
            src_pink_next_token();
            char const ((*field)) = src_pink_token.name;
            src_pink_expect_token(SRC_PINK_TOKEN_NAME);
            expr = src_pink_new_expr_field(pos, expr, field);
        } else {
            src_pink_TokenKind op = src_pink_token.kind;
            src_pink_next_token();
            expr = src_pink_new_expr_modify(pos, op, true, expr);
        }
    }
    return expr;
}

bool src_pink_is_unary_op(void) {
    return (((((((src_pink_is_token(SRC_PINK_TOKEN_ADD)) || (src_pink_is_token(SRC_PINK_TOKEN_SUB))) || (src_pink_is_token(SRC_PINK_TOKEN_MUL))) || (src_pink_is_token(SRC_PINK_TOKEN_AND))) || (src_pink_is_token(SRC_PINK_TOKEN_NEG))) || (src_pink_is_token(SRC_PINK_TOKEN_NOT))) || (src_pink_is_token(SRC_PINK_TOKEN_INC))) || (src_pink_is_token(SRC_PINK_TOKEN_DEC));
}

src_pink_Expr (*src_pink_parse_expr_unary(void)) {
    if (src_pink_is_unary_op()) {
        src_pink_SrcPos pos = src_pink_token.pos;
        src_pink_TokenKind op = src_pink_token.kind;
        src_pink_next_token();
        if (((op) == (SRC_PINK_TOKEN_INC)) || ((op) == (SRC_PINK_TOKEN_DEC))) {
            return src_pink_new_expr_modify(pos, op, false, src_pink_parse_expr_unary());
        } else {
            return src_pink_new_expr_unary(pos, op, src_pink_parse_expr_unary());
        }
    } else {
        return src_pink_parse_expr_base();
    }
}

bool src_pink_is_mul_op(void) {
    return ((SRC_PINK_TOKEN_FIRST_MUL) <= (src_pink_token.kind)) && ((src_pink_token.kind) <= (SRC_PINK_TOKEN_LAST_MUL));
}

src_pink_Expr (*src_pink_parse_expr_mul(void)) {
    src_pink_Expr (*expr) = src_pink_parse_expr_unary();
    while (src_pink_is_mul_op()) {
        src_pink_SrcPos pos = src_pink_token.pos;
        src_pink_TokenKind op = src_pink_token.kind;
        src_pink_next_token();
        expr = src_pink_new_expr_binary(pos, op, expr, src_pink_parse_expr_unary());
    }
    return expr;
}

bool src_pink_is_add_op(void) {
    return ((SRC_PINK_TOKEN_FIRST_ADD) <= (src_pink_token.kind)) && ((src_pink_token.kind) <= (SRC_PINK_TOKEN_LAST_ADD));
}

src_pink_Expr (*src_pink_parse_expr_add(void)) {
    src_pink_Expr (*expr) = src_pink_parse_expr_mul();
    while (src_pink_is_add_op()) {
        src_pink_SrcPos pos = src_pink_token.pos;
        src_pink_TokenKind op = src_pink_token.kind;
        src_pink_next_token();
        expr = src_pink_new_expr_binary(pos, op, expr, src_pink_parse_expr_mul());
    }
    return expr;
}

bool src_pink_is_cmp_op(void) {
    return ((SRC_PINK_TOKEN_FIRST_CMP) <= (src_pink_token.kind)) && ((src_pink_token.kind) <= (SRC_PINK_TOKEN_LAST_CMP));
}

src_pink_Expr (*src_pink_parse_expr_cmp(void)) {
    src_pink_Expr (*expr) = src_pink_parse_expr_add();
    while (src_pink_is_cmp_op()) {
        src_pink_SrcPos pos = src_pink_token.pos;
        src_pink_TokenKind op = src_pink_token.kind;
        src_pink_next_token();
        expr = src_pink_new_expr_binary(pos, op, expr, src_pink_parse_expr_add());
    }
    return expr;
}

src_pink_Expr (*src_pink_parse_expr_and(void)) {
    src_pink_Expr (*expr) = src_pink_parse_expr_cmp();
    while (src_pink_match_token(SRC_PINK_TOKEN_AND_AND)) {
        src_pink_SrcPos pos = src_pink_token.pos;
        expr = src_pink_new_expr_binary(pos, SRC_PINK_TOKEN_AND_AND, expr, src_pink_parse_expr_cmp());
    }
    return expr;
}

src_pink_Expr (*src_pink_parse_expr_or(void)) {
    src_pink_Expr (*expr) = src_pink_parse_expr_and();
    while (src_pink_match_token(SRC_PINK_TOKEN_OR_OR)) {
        src_pink_SrcPos pos = src_pink_token.pos;
        expr = src_pink_new_expr_binary(pos, SRC_PINK_TOKEN_OR_OR, expr, src_pink_parse_expr_and());
    }
    return expr;
}

src_pink_Expr (*src_pink_parse_expr_ternary(void)) {
    src_pink_SrcPos pos = src_pink_token.pos;
    src_pink_Expr (*expr) = src_pink_parse_expr_or();
    if (src_pink_match_token(SRC_PINK_TOKEN_QUESTION)) {
        src_pink_Expr (*then_expr) = src_pink_parse_expr_ternary();
        src_pink_expect_token(SRC_PINK_TOKEN_COLON);
        src_pink_Expr (*else_expr) = src_pink_parse_expr_ternary();
        expr = src_pink_new_expr_ternary(pos, expr, then_expr, else_expr);
    }
    return expr;
}

src_pink_Expr (*src_pink_parse_expr(void)) {
    return src_pink_parse_expr_ternary();
}

src_pink_Expr (*src_pink_parse_paren_expr(void)) {
    src_pink_expect_token(SRC_PINK_TOKEN_LPAREN);
    src_pink_Expr (*expr) = src_pink_parse_expr();
    src_pink_expect_token(SRC_PINK_TOKEN_RPAREN);
    return expr;
}

src_pink_StmtList src_pink_parse_stmt_block(void) {
    src_pink_SrcPos pos = src_pink_token.pos;
    src_pink_expect_token(SRC_PINK_TOKEN_LBRACE);
    src_pink_Stmt (*(*stmts)) = NULL;
    while ((!(src_pink_is_token_eof())) && (!(src_pink_is_token(SRC_PINK_TOKEN_RBRACE)))) {
        src_pink_Stmt (*stmt) = src_pink_parse_stmt();
        old_std_buf_push((void (**))(&(stmts)), &(stmt), sizeof(stmt));
    }
    src_pink_expect_token(SRC_PINK_TOKEN_RBRACE);
    return src_pink_new_stmt_list(pos, stmts, old_std_buf_len(stmts));
}

src_pink_Stmt (*src_pink_parse_stmt_if(src_pink_SrcPos pos)) {
    src_pink_expect_token(SRC_PINK_TOKEN_LPAREN);
    src_pink_Expr (*cond) = src_pink_parse_expr();
    src_pink_Stmt (*init) = src_pink_parse_init_stmt(cond);
    if (init) {
        if (src_pink_match_token(SRC_PINK_TOKEN_SEMICOLON)) {
            cond = src_pink_parse_expr();
        } else {
            cond = NULL;
        }
    }
    src_pink_expect_token(SRC_PINK_TOKEN_RPAREN);
    src_pink_StmtList then_block = src_pink_parse_stmt_block();
    src_pink_StmtList else_block = {{NULL, 0}, NULL, 0};
    src_pink_ElseIf (*elseifs) = NULL;
    while (src_pink_match_keyword(src_pink_else_keyword)) {
        if (!(src_pink_match_keyword(src_pink_if_keyword))) {
            else_block = src_pink_parse_stmt_block();
            break;
        }
        src_pink_Expr (*elseif_cond) = src_pink_parse_paren_expr();
        src_pink_StmtList elseif_block = src_pink_parse_stmt_block();
        src_pink_ElseIf elseif = {elseif_cond, elseif_block};
        old_std_buf_push((void (**))(&(elseifs)), &(elseif), sizeof(elseif));
    }
    return src_pink_new_stmt_if(pos, init, cond, then_block, elseifs, old_std_buf_len(elseifs), else_block);
}

src_pink_Stmt (*src_pink_parse_stmt_while(src_pink_SrcPos pos)) {
    src_pink_Expr (*cond) = src_pink_parse_paren_expr();
    return src_pink_new_stmt_while(pos, cond, src_pink_parse_stmt_block());
}

src_pink_Stmt (*src_pink_parse_stmt_do_while(src_pink_SrcPos pos)) {
    src_pink_StmtList block = src_pink_parse_stmt_block();
    if (!(src_pink_match_keyword(src_pink_while_keyword))) {
        src_pink_fatal_error(src_pink_token.pos, "Expected \'while\' after \'do\' block");
        return NULL;
    }
    src_pink_Stmt (*stmt) = src_pink_new_stmt_do_while(pos, src_pink_parse_paren_expr(), block);
    src_pink_expect_token(SRC_PINK_TOKEN_SEMICOLON);
    return stmt;
}

bool src_pink_is_assign_op(void) {
    return ((SRC_PINK_TOKEN_FIRST_ASSIGN) <= (src_pink_token.kind)) && ((src_pink_token.kind) <= (SRC_PINK_TOKEN_LAST_ASSIGN));
}

src_pink_Stmt (*src_pink_parse_init_stmt(src_pink_Expr (*left))) {
    if (src_pink_match_token(SRC_PINK_TOKEN_COLON_ASSIGN)) {
        if ((left->kind) != (SRC_PINK_EXPR_NAME)) {
            src_pink_fatal_error(src_pink_token.pos, ":= must be preceded by a name");
            return NULL;
        }
        return src_pink_new_stmt_init(left->pos, left->name, NULL, src_pink_parse_expr());
    } else if (src_pink_match_token(SRC_PINK_TOKEN_COLON)) {
        if ((left->kind) != (SRC_PINK_EXPR_NAME)) {
            src_pink_fatal_error(src_pink_token.pos, ": must be preceded by a name");
            return NULL;
        }
        char const ((*name)) = left->name;
        src_pink_Typespec (*type) = src_pink_parse_type();
        src_pink_Expr (*expr) = NULL;
        if (src_pink_match_token(SRC_PINK_TOKEN_ASSIGN)) {
            expr = src_pink_parse_expr();
        }
        return src_pink_new_stmt_init(left->pos, name, type, expr);
    } else {
        return NULL;
    }
}

src_pink_Stmt (*src_pink_parse_simple_stmt(void)) {
    src_pink_SrcPos pos = src_pink_token.pos;
    src_pink_Expr (*expr) = src_pink_parse_expr();
    src_pink_Stmt (*stmt) = src_pink_parse_init_stmt(expr);
    if (!(stmt)) {
        if (src_pink_is_assign_op()) {
            src_pink_TokenKind op = src_pink_token.kind;
            src_pink_next_token();
            stmt = src_pink_new_stmt_assign(pos, op, expr, src_pink_parse_expr());
        } else {
            stmt = src_pink_new_stmt_expr(pos, expr);
        }
    }
    return stmt;
}

src_pink_Stmt (*src_pink_parse_stmt_for(src_pink_SrcPos pos)) {
    src_pink_expect_token(SRC_PINK_TOKEN_LPAREN);
    src_pink_Stmt (*init) = NULL;
    if (!(src_pink_is_token(SRC_PINK_TOKEN_SEMICOLON))) {
        init = src_pink_parse_simple_stmt();
    }
    src_pink_expect_token(SRC_PINK_TOKEN_SEMICOLON);
    src_pink_Expr (*cond) = NULL;
    if (!(src_pink_is_token(SRC_PINK_TOKEN_SEMICOLON))) {
        cond = src_pink_parse_expr();
    }
    src_pink_Stmt (*next) = NULL;
    if (src_pink_match_token(SRC_PINK_TOKEN_SEMICOLON)) {
        if (!(src_pink_is_token(SRC_PINK_TOKEN_RPAREN))) {
            next = src_pink_parse_simple_stmt();
            if ((next->kind) == (SRC_PINK_STMT_INIT)) {
                src_pink_error(src_pink_token.pos, "Init statements not allowed in for-statement\'s next clause");
            }
        }
    }
    src_pink_expect_token(SRC_PINK_TOKEN_RPAREN);
    return src_pink_new_stmt_for(pos, init, cond, next, src_pink_parse_stmt_block());
}

src_pink_SwitchCasePattern src_pink_parse_switch_case_pattern(void) {
    src_pink_Expr (*start) = src_pink_parse_expr();
    src_pink_Expr (*end) = NULL;
    if (src_pink_match_token(SRC_PINK_TOKEN_ELLIPSIS)) {
        end = src_pink_parse_expr();
    }
    return (src_pink_SwitchCasePattern){start, end};
}

src_pink_SwitchCase src_pink_parse_stmt_switch_case(void) {
    src_pink_SwitchCasePattern (*patterns) = NULL;
    bool is_default = false;
    bool is_first_case = true;
    while ((src_pink_is_keyword(src_pink_case_keyword)) || (src_pink_is_keyword(src_pink_default_keyword))) {
        if (src_pink_match_keyword(src_pink_case_keyword)) {
            if (!(is_first_case)) {
                src_pink_error(src_pink_token.pos, "Use comma-separated expressions to match multiple values with one case label");
                is_first_case = false;
            }
            src_pink_SwitchCasePattern pattern = src_pink_parse_switch_case_pattern();
            old_std_buf_push((void (**))(&(patterns)), &(pattern), sizeof(pattern));
            while (src_pink_match_token(SRC_PINK_TOKEN_COMMA)) {
                pattern = src_pink_parse_switch_case_pattern();
                old_std_buf_push((void (**))(&(patterns)), &(pattern), sizeof(pattern));
            }
        } else {
            src_pink_next_token();
            if (is_default) {
                src_pink_error(src_pink_token.pos, "Duplicate default labels in same switch clause");
            }
            is_default = true;
        }
        src_pink_expect_token(SRC_PINK_TOKEN_COLON);
    }
    src_pink_SrcPos pos = src_pink_token.pos;
    src_pink_Stmt (*(*stmts)) = {0};
    while ((((!(src_pink_is_token_eof())) && (!(src_pink_is_token(SRC_PINK_TOKEN_RBRACE)))) && (!(src_pink_is_keyword(src_pink_case_keyword)))) && (!(src_pink_is_keyword(src_pink_default_keyword)))) {
        src_pink_Stmt (*stmt) = src_pink_parse_stmt();
        old_std_buf_push((void (**))(&(stmts)), &(stmt), sizeof(stmt));
    }
    return (src_pink_SwitchCase){patterns, old_std_buf_len(patterns), is_default, src_pink_new_stmt_list(pos, stmts, old_std_buf_len(stmts))};
}

src_pink_Stmt (*src_pink_parse_stmt_switch(src_pink_SrcPos pos)) {
    src_pink_Expr (*expr) = src_pink_parse_paren_expr();
    src_pink_SwitchCase (*cases) = {0};
    src_pink_expect_token(SRC_PINK_TOKEN_LBRACE);
    while ((!(src_pink_is_token_eof())) && (!(src_pink_is_token(SRC_PINK_TOKEN_RBRACE)))) {
        src_pink_SwitchCase case_stmt = src_pink_parse_stmt_switch_case();
        old_std_buf_push((void (**))(&(cases)), &(case_stmt), sizeof(case_stmt));
    }
    src_pink_expect_token(SRC_PINK_TOKEN_RBRACE);
    return src_pink_new_stmt_switch(pos, expr, cases, old_std_buf_len(cases));
}

src_pink_Stmt (*src_pink_parse_stmt(void)) {
    src_pink_Notes notes = src_pink_parse_notes();
    src_pink_SrcPos pos = src_pink_token.pos;
    src_pink_Stmt (*stmt) = {0};
    if (src_pink_match_keyword(src_pink_if_keyword)) {
        stmt = src_pink_parse_stmt_if(pos);
    } else if (src_pink_match_keyword(src_pink_while_keyword)) {
        stmt = src_pink_parse_stmt_while(pos);
    } else if (src_pink_match_keyword(src_pink_do_keyword)) {
        stmt = src_pink_parse_stmt_do_while(pos);
    } else if (src_pink_match_keyword(src_pink_for_keyword)) {
        stmt = src_pink_parse_stmt_for(pos);
    } else if (src_pink_match_keyword(src_pink_switch_keyword)) {
        stmt = src_pink_parse_stmt_switch(pos);
    } else if (src_pink_is_token(SRC_PINK_TOKEN_LBRACE)) {
        stmt = src_pink_new_stmt_block(pos, src_pink_parse_stmt_block());
    } else if (src_pink_match_keyword(src_pink_break_keyword)) {
        src_pink_expect_token(SRC_PINK_TOKEN_SEMICOLON);
        stmt = src_pink_new_stmt_break(pos);
    } else if (src_pink_match_keyword(src_pink_continue_keyword)) {
        src_pink_expect_token(SRC_PINK_TOKEN_SEMICOLON);
        stmt = src_pink_new_stmt_continue(pos);
    } else if (src_pink_match_keyword(src_pink_return_keyword)) {
        src_pink_Expr (*expr) = {0};
        if (!(src_pink_is_token(SRC_PINK_TOKEN_SEMICOLON))) {
            expr = src_pink_parse_expr();
        }
        src_pink_expect_token(SRC_PINK_TOKEN_SEMICOLON);
        stmt = src_pink_new_stmt_return(pos, expr);
    } else if (src_pink_match_token(SRC_PINK_TOKEN_POUND)) {
        src_pink_Note note = src_pink_parse_note();
        src_pink_expect_token(SRC_PINK_TOKEN_SEMICOLON);
        stmt = src_pink_new_stmt_note(pos, note);
    } else if (src_pink_match_token(SRC_PINK_TOKEN_COLON)) {
        stmt = src_pink_new_stmt_label(pos, src_pink_parse_name());
    } else if (src_pink_match_keyword(src_pink_goto_keyword)) {
        stmt = src_pink_new_stmt_goto(pos, src_pink_parse_name());
        src_pink_expect_token(SRC_PINK_TOKEN_SEMICOLON);
    } else {
        stmt = src_pink_parse_simple_stmt();
        src_pink_expect_token(SRC_PINK_TOKEN_SEMICOLON);
    }
    stmt->notes = notes;
    return stmt;
}

char const ((*src_pink_parse_name(void))) {
    char const ((*name)) = src_pink_token.name;
    src_pink_expect_token(SRC_PINK_TOKEN_NAME);
    return name;
}

src_pink_EnumItem src_pink_parse_decl_enum_item(void) {
    src_pink_SrcPos pos = src_pink_token.pos;
    char const ((*name)) = src_pink_parse_name();
    src_pink_Expr (*init) = NULL;
    if (src_pink_match_token(SRC_PINK_TOKEN_ASSIGN)) {
        init = src_pink_parse_expr();
    }
    return (src_pink_EnumItem){pos, name, init};
}

src_pink_Decl (*src_pink_parse_decl_enum(src_pink_SrcPos pos)) {
    char const ((*name)) = NULL;
    if (src_pink_is_token(SRC_PINK_TOKEN_NAME)) {
        name = src_pink_parse_name();
    }
    src_pink_Typespec (*type) = NULL;
    if (src_pink_match_token(SRC_PINK_TOKEN_ASSIGN)) {
        type = src_pink_parse_type();
    }
    src_pink_expect_token(SRC_PINK_TOKEN_LBRACE);
    src_pink_EnumItem (*items) = NULL;
    while (!(src_pink_is_token(SRC_PINK_TOKEN_RBRACE))) {
        src_pink_EnumItem item = src_pink_parse_decl_enum_item();
        old_std_buf_push((void (**))(&(items)), &(item), sizeof(item));
        if (!(src_pink_match_token(SRC_PINK_TOKEN_COMMA))) {
            break;
        }
    }
    src_pink_expect_token(SRC_PINK_TOKEN_RBRACE);
    return src_pink_new_decl_enum(pos, name, type, items, old_std_buf_len(items));
}

src_pink_AggregateItem src_pink_parse_decl_aggregate_item(void) {
    src_pink_SrcPos pos = src_pink_token.pos;
    if (src_pink_match_keyword(src_pink_struct_keyword)) {
        return (src_pink_AggregateItem){.pos = pos, .kind = SRC_PINK_AGGREGATE_ITEM_SUBAGGREGATE, .subaggregate = src_pink_parse_aggregate(SRC_PINK_AGGREGATE_STRUCT)};
    } else if (src_pink_match_keyword(src_pink_union_keyword)) {
        return (src_pink_AggregateItem){.pos = pos, .kind = SRC_PINK_AGGREGATE_ITEM_SUBAGGREGATE, .subaggregate = src_pink_parse_aggregate(SRC_PINK_AGGREGATE_UNION)};
    } else {
        char const ((*(*names))) = NULL;
        char const ((*name)) = src_pink_parse_name();
        old_std_buf_push((void (**))(&(names)), &(name), sizeof(name));
        while (src_pink_match_token(SRC_PINK_TOKEN_COMMA)) {
            name = src_pink_parse_name();
            old_std_buf_push((void (**))(&(names)), &(name), sizeof(name));
        }
        src_pink_expect_token(SRC_PINK_TOKEN_COLON);
        src_pink_Typespec (*type) = src_pink_parse_type();
        src_pink_expect_token(SRC_PINK_TOKEN_SEMICOLON);
        return (src_pink_AggregateItem){.pos = pos, .kind = SRC_PINK_AGGREGATE_ITEM_FIELD, .names = names, .num_names = old_std_buf_len(names), .type = type};
    }
}

src_pink_Aggregate (*src_pink_parse_aggregate(src_pink_AggregateKind kind)) {
    src_pink_SrcPos pos = src_pink_token.pos;
    src_pink_expect_token(SRC_PINK_TOKEN_LBRACE);
    src_pink_AggregateItem (*items) = NULL;
    while ((!(src_pink_is_token_eof())) && (!(src_pink_is_token(SRC_PINK_TOKEN_RBRACE)))) {
        src_pink_AggregateItem item = src_pink_parse_decl_aggregate_item();
        old_std_buf_push((void (**))(&(items)), &(item), sizeof(item));
    }
    src_pink_expect_token(SRC_PINK_TOKEN_RBRACE);
    return src_pink_new_aggregate(pos, kind, items, old_std_buf_len(items));
}

src_pink_Decl (*src_pink_parse_decl_aggregate(src_pink_SrcPos pos, src_pink_DeclKind kind)) {
    char const ((*name)) = src_pink_parse_name();
    src_pink_AggregateKind aggregate_kind = ((kind) == (SRC_PINK_DECL_STRUCT) ? SRC_PINK_AGGREGATE_STRUCT : SRC_PINK_AGGREGATE_UNION);
    if (src_pink_match_token(SRC_PINK_TOKEN_SEMICOLON)) {
        src_pink_Decl (*decl) = src_pink_new_decl_aggregate(pos, kind, name, src_pink_new_aggregate(pos, aggregate_kind, NULL, 0));
        decl->is_incomplete = true;
        return decl;
    } else {
        return src_pink_new_decl_aggregate(pos, kind, name, src_pink_parse_aggregate(aggregate_kind));
    }
}

src_pink_Decl (*src_pink_parse_decl_var(src_pink_SrcPos pos)) {
    char const ((*name)) = src_pink_parse_name();
    if (src_pink_match_token(SRC_PINK_TOKEN_ASSIGN)) {
        src_pink_Expr (*expr) = src_pink_parse_expr();
        src_pink_expect_token(SRC_PINK_TOKEN_SEMICOLON);
        return src_pink_new_decl_var(pos, name, NULL, expr);
    } else if (src_pink_match_token(SRC_PINK_TOKEN_COLON)) {
        src_pink_Typespec (*type) = src_pink_parse_type();
        src_pink_Expr (*expr) = NULL;
        if (src_pink_match_token(SRC_PINK_TOKEN_ASSIGN)) {
            expr = src_pink_parse_expr();
        }
        src_pink_expect_token(SRC_PINK_TOKEN_SEMICOLON);
        return src_pink_new_decl_var(pos, name, type, expr);
    } else {
        src_pink_fatal_error(src_pink_token.pos, "Expected : or = after var, got %s", src_pink_token_info());
        return NULL;
    }
}

src_pink_Decl (*src_pink_parse_decl_const(src_pink_SrcPos pos)) {
    char const ((*name)) = src_pink_parse_name();
    src_pink_Typespec (*type) = NULL;
    if (src_pink_match_token(SRC_PINK_TOKEN_COLON)) {
        type = src_pink_parse_type();
    }
    src_pink_expect_token(SRC_PINK_TOKEN_ASSIGN);
    src_pink_Expr (*expr) = src_pink_parse_expr();
    src_pink_expect_token(SRC_PINK_TOKEN_SEMICOLON);
    return src_pink_new_decl_const(pos, name, type, expr);
}

src_pink_Decl (*src_pink_parse_decl_typedef(src_pink_SrcPos pos)) {
    char const ((*name)) = src_pink_parse_name();
    src_pink_expect_token(SRC_PINK_TOKEN_ASSIGN);
    src_pink_Typespec (*type) = src_pink_parse_type();
    src_pink_expect_token(SRC_PINK_TOKEN_SEMICOLON);
    return src_pink_new_decl_typedef(pos, name, type);
}

src_pink_FuncParam src_pink_parse_decl_func_param(void) {
    src_pink_SrcPos pos = src_pink_token.pos;
    char const ((*name)) = src_pink_parse_name();
    src_pink_expect_token(SRC_PINK_TOKEN_COLON);
    src_pink_Typespec (*type) = src_pink_parse_type();
    return (src_pink_FuncParam){pos, name, type};
}

src_pink_Decl (*src_pink_parse_decl_func(src_pink_SrcPos pos)) {
    char const ((*name)) = src_pink_parse_name();
    src_pink_expect_token(SRC_PINK_TOKEN_LPAREN);
    src_pink_FuncParam (*params) = NULL;
    bool has_varargs = false;
    while (!(src_pink_is_token(SRC_PINK_TOKEN_RPAREN))) {
        if (src_pink_match_token(SRC_PINK_TOKEN_ELLIPSIS)) {
            if (has_varargs) {
                src_pink_error(src_pink_token.pos, "Multiple ellipsis in function declaration");
            }
            has_varargs = true;
        } else {
            if (has_varargs) {
                src_pink_error(src_pink_token.pos, "Ellipsis must be last parameter in function declaration");
            }
            src_pink_FuncParam param = src_pink_parse_decl_func_param();
            old_std_buf_push((void (**))(&(params)), &(param), sizeof(param));
        }
        if (!(src_pink_match_token(SRC_PINK_TOKEN_COMMA))) {
            break;
        }
    }
    src_pink_expect_token(SRC_PINK_TOKEN_RPAREN);
    src_pink_Typespec (*ret_type) = NULL;
    if (src_pink_match_token(SRC_PINK_TOKEN_COLON)) {
        ret_type = src_pink_parse_type();
    }
    src_pink_StmtList block = {0};
    bool is_incomplete = {0};
    if (src_pink_match_token(SRC_PINK_TOKEN_SEMICOLON)) {
        is_incomplete = true;
    } else {
        block = src_pink_parse_stmt_block();
        is_incomplete = false;
    }
    src_pink_Decl (*decl) = src_pink_new_decl_func(pos, name, params, old_std_buf_len(params), ret_type, has_varargs, block);
    decl->is_incomplete = is_incomplete;
    return decl;
}

src_pink_NoteArg src_pink_parse_note_arg(void) {
    src_pink_SrcPos pos = src_pink_token.pos;
    src_pink_Expr (*expr) = src_pink_parse_expr();
    char const ((*name)) = NULL;
    if (src_pink_match_token(SRC_PINK_TOKEN_ASSIGN)) {
        if ((expr->kind) != (SRC_PINK_EXPR_NAME)) {
            src_pink_fatal_error(src_pink_token.pos, "Left of: operand = in note argument must be a name");
        }
        name = expr->name;
        expr = src_pink_parse_expr();
    }
    return (src_pink_NoteArg){.pos = pos, .name = name, .expr = expr};
}

src_pink_Note src_pink_parse_note(void) {
    src_pink_SrcPos pos = src_pink_token.pos;
    char const ((*name)) = src_pink_parse_name();
    src_pink_NoteArg (*args) = NULL;
    if (src_pink_match_token(SRC_PINK_TOKEN_LPAREN)) {
        src_pink_NoteArg arg = src_pink_parse_note_arg();
        old_std_buf_push((void (**))(&(args)), &(arg), sizeof(arg));
        while (src_pink_match_token(SRC_PINK_TOKEN_COMMA)) {
            arg = src_pink_parse_note_arg();
            old_std_buf_push((void (**))(&(args)), &(arg), sizeof(arg));
        }
        src_pink_expect_token(SRC_PINK_TOKEN_RPAREN);
    }
    return src_pink_new_note(pos, name, args, old_std_buf_len(args));
}

src_pink_Notes src_pink_parse_notes(void) {
    src_pink_Note (*notes) = NULL;
    while (src_pink_match_token(SRC_PINK_TOKEN_AT)) {
        src_pink_Note note = src_pink_parse_note();
        old_std_buf_push((void (**))(&(notes)), &(note), sizeof(note));
    }
    return src_pink_new_notes(notes, old_std_buf_len(notes));
}

src_pink_Decl (*src_pink_parse_decl_note(src_pink_SrcPos pos)) {
    return src_pink_new_decl_note(pos, src_pink_parse_note());
}

src_pink_Decl (*src_pink_parse_decl_import(src_pink_SrcPos pos)) {
    char const ((*rename_name)) = {0};
    bool is_relative = {0};
    repeat: ;
    is_relative = false;
    if (src_pink_match_token(SRC_PINK_TOKEN_DOT)) {
        is_relative = true;
    }
    char const ((*name)) = src_pink_token.name;
    src_pink_expect_token(SRC_PINK_TOKEN_NAME);
    if ((!(is_relative)) && (src_pink_match_token(SRC_PINK_TOKEN_ASSIGN))) {
        if (rename_name) {
            src_pink_fatal_error(pos, "Only one import assignment is allowed");
        }
        rename_name = name;
        goto repeat;
    }
    char const ((*(*names))) = NULL;
    old_std_buf_push((void (**))(&(names)), &(name), sizeof(name));
    while (src_pink_match_token(SRC_PINK_TOKEN_DOT)) {
        old_std_buf_push((void (**))(&(names)), &(src_pink_token.name), sizeof(src_pink_token.name));
        src_pink_expect_token(SRC_PINK_TOKEN_NAME);
    }
    bool import_all = false;
    src_pink_ImportItem (*items) = {0};
    if (src_pink_match_token(SRC_PINK_TOKEN_LBRACE)) {
        while (!(src_pink_is_token(SRC_PINK_TOKEN_RBRACE))) {
            if (src_pink_match_token(SRC_PINK_TOKEN_ELLIPSIS)) {
                import_all = true;
            } else {
                char const ((*item_name)) = src_pink_parse_name();
                if (src_pink_match_token(SRC_PINK_TOKEN_ASSIGN)) {
                    src_pink_ImportItem item = {.name = src_pink_parse_name(), .rename = item_name};
                    old_std_buf_push((void (**))(&(items)), &(item), sizeof(item));
                } else {
                    src_pink_ImportItem item = {.name = item_name};
                    old_std_buf_push((void (**))(&(items)), &(item), sizeof(item));
                }
                if (!(src_pink_match_token(SRC_PINK_TOKEN_COMMA))) {
                    break;
                }
            }
        }
        src_pink_expect_token(SRC_PINK_TOKEN_RBRACE);
    }
    return src_pink_new_decl_import(pos, rename_name, is_relative, names, old_std_buf_len(names), import_all, items, old_std_buf_len(items));
}

src_pink_Decl (*src_pink_parse_decl_opt(void)) {
    src_pink_SrcPos pos = src_pink_token.pos;
    if (src_pink_match_keyword(src_pink_enum_keyword)) {
        return src_pink_parse_decl_enum(pos);
    } else if (src_pink_match_keyword(src_pink_struct_keyword)) {
        return src_pink_parse_decl_aggregate(pos, SRC_PINK_DECL_STRUCT);
    } else if (src_pink_match_keyword(src_pink_union_keyword)) {
        return src_pink_parse_decl_aggregate(pos, SRC_PINK_DECL_UNION);
    } else if (src_pink_match_keyword(src_pink_const_keyword)) {
        return src_pink_parse_decl_const(pos);
    } else if (src_pink_match_keyword(src_pink_typedef_keyword)) {
        return src_pink_parse_decl_typedef(pos);
    } else if (src_pink_match_keyword(src_pink_func_keyword)) {
        return src_pink_parse_decl_func(pos);
    } else if (src_pink_match_keyword(src_pink_var_keyword)) {
        return src_pink_parse_decl_var(pos);
    } else if (src_pink_match_keyword(src_pink_import_keyword)) {
        return src_pink_parse_decl_import(pos);
    } else if (src_pink_match_token(SRC_PINK_TOKEN_POUND)) {
        return src_pink_parse_decl_note(pos);
    } else {
        return NULL;
    }
}

src_pink_Decl (*src_pink_parse_decl(void)) {
    src_pink_Notes notes = src_pink_parse_notes();
    src_pink_Decl (*decl) = src_pink_parse_decl_opt();
    if (!(decl)) {
        src_pink_fatal_error(src_pink_token.pos, "Expected declaration keyword, got %s", src_pink_token_info());
    }
    decl->notes = notes;
    return decl;
}

src_pink_Decls (*src_pink_parse_decls(void)) {
    src_pink_Decl (*(*decls)) = NULL;
    while (!(src_pink_is_token(SRC_PINK_TOKEN_EOF))) {
        src_pink_Decl (*decl) = src_pink_parse_decl();
        old_std_buf_push((void (**))(&(decls)), &(decl), sizeof(decl));
    }
    return src_pink_new_decls(decls, old_std_buf_len(decls));
}

char const ((*(src_pink_static_package_search_paths[SRC_PINK_MAX_SEARCH_PATHS])));
char const ((*(*src_pink_package_search_paths))) = src_pink_static_package_search_paths;
int src_pink_num_package_search_paths;
void src_pink_add_package_search_path(char const ((*path))) {
    if (src_pink_flag_verbose) {
        printf("Adding package search path %s\n", path);
    }
    src_pink_package_search_paths[(src_pink_num_package_search_paths)++] = old_std_str_intern(path);
}

void src_pink_add_package_search_path_range(char const ((*start)), char const ((*end))) {
    char (path[MAX_PATH]) = {0};
    size_t len = old_std_clamp_max((end) - (start), (MAX_PATH) - (1));
    memcpy(path, start, len);
    path[len] = 0;
    src_pink_add_package_search_path(path);
}

void src_pink_init_package_search_paths(void) {
    char (*pinkhome_var) = getenv("PINK_HOME");
    if (!(pinkhome_var)) {
        printf("error: Set the environment variable PINK_HOME to the Pink home directory (where `lib` is located)\n");
        exit(1);
    }
    char (path[MAX_PATH]) = {0};
    old_std_os_path_copy(path, pinkhome_var);
    old_std_os_path_join(path, "lib");
    src_pink_add_package_search_path(path);
    src_pink_add_package_search_path(".");
    src_pink_add_package_search_path("./vendor");
    src_pink_add_package_search_path("./src");
    src_pink_add_package_search_path("./tmp");
    char (*pinkpath_var) = getenv("PINK_PATH");
    if (pinkpath_var) {
        char (*start) = pinkpath_var;
        for (char (*ptr) = pinkpath_var; *(ptr); (ptr)++) {
            if ((*(ptr)) == (';')) {
                src_pink_add_package_search_path_range(start, ptr);
                start = (ptr) + (1);
            }
        }
        if (*(start)) {
            src_pink_add_package_search_path(start);
        }
    }
}

void src_pink_init_compiler(void) {
    src_pink_init_target();
    src_pink_init_package_search_paths();
    src_pink_init_keywords();
    src_pink_init_builtin_types();
    old_std_map_put(&(src_pink_decl_note_names), src_pink_declare_note_name, (void *)(1));
}

void src_pink_parse_env_vars(void) {
    char (*pinkos_var) = getenv("PINK_OS");
    if (pinkos_var) {
        int os = src_pink_get_os(pinkos_var);
        if ((os) == (-(1))) {
            printf("Unknown target operating system in PINK_OS environment variable: %s\n", pinkos_var);
        } else {
            src_pink_target_os = os;
        }
    }
    char (*pinkarch_var) = getenv("PINK_ARCH");
    if (pinkarch_var) {
        int arch = src_pink_get_arch(pinkarch_var);
        if ((arch) == (-(1))) {
            printf("Unknown target architecture in PINK_ARCH environment variable: %s\n", pinkarch_var);
        } else {
            src_pink_target_arch = arch;
        }
    }
}

int src_pink_pink_entry(int argc, char const ((*(*argv))), void (*gen_all)(void), char const ((*extension))) {
    src_pink_parse_env_vars();
    char const ((*output_name)) = {0};
    bool flag_check = false;
    old_std_os_add_flag_str("o", &(output_name), "file", "Output file (default: out_<main-package>.c)");
    old_std_os_add_flag_enum("os", &(src_pink_target_os), "Target operating system", src_pink_os_names, SRC_PINK_NUM_OSES);
    old_std_os_add_flag_enum("arch", &(src_pink_target_arch), "Target machine architecture", src_pink_arch_names, SRC_PINK_NUM_ARCHES);
    old_std_os_add_flag_bool("check", &(flag_check), "Semantic checking with no code generation");
    old_std_os_add_flag_bool("lazy", &(src_pink_flag_lazy), "Only compile what\'s reachable from the main package");
    old_std_os_add_flag_bool("nosourcemap", &(src_pink_flag_nosourcemap), "Don\'t generate any source map information");
    old_std_os_add_flag_bool("notypeinfo", &(src_pink_flag_notypeinfo), "Don\'t generate any typeinfo tables");
    old_std_os_add_flag_bool("fullgen", &(src_pink_flag_fullgen), "Force full code generation even for non-reachable symbols");
    old_std_os_add_flag_bool("verbose", &(src_pink_flag_verbose), "Extra diagnostic information");
    char const ((*program_name)) = old_std_os_parse_flags(&(argc), &(argv));
    if ((argc) != (1)) {
        printf("Usage: %s [flags] <main-package>\n", program_name);
        old_std_os_print_flags_usage();
        return 1;
    }
    char const ((*package_name)) = argv[0];
    if (src_pink_flag_verbose) {
        printf("Target operating system: %s\n", src_pink_os_names[src_pink_target_os]);
        printf("Target architecture: %s\n", src_pink_arch_names[src_pink_target_arch]);
    }
    src_pink_init_compiler();
    src_pink_builtin_package = src_pink_import_package("builtin");
    if (!(src_pink_builtin_package)) {
        printf("error: Failed to compile package \'builtin\'.\n");
        return 1;
    }
    src_pink_builtin_package->external_name = old_std_str_intern("");
    src_pink_Package (*main_package) = src_pink_import_package(package_name);
    if (!(main_package)) {
        printf("error: Failed to compile package \'%s\'\n", package_name);
        return 1;
    }
    char const ((*main_name)) = old_std_str_intern("main");
    src_pink_Sym (*main_sym) = src_pink_get_package_sym(main_package, main_name);
    if (!(main_sym)) {
        printf("error: No \'main\' entry point defined in package \'%s\'\n", package_name);
        return 1;
    }
    main_sym->external_name = main_name;
    src_pink_reachable_phase = SRC_PINK_REACHABLE_NATURAL;
    src_pink_resolve_sym(main_sym);
    for (size_t i = 0; (i) < (old_std_buf_len(src_pink_package_list)); (i)++) {
        if (src_pink_package_list[i]->always_reachable) {
            src_pink_resolve_package_syms(src_pink_package_list[i]);
        }
    }
    src_pink_finalize_reachable_syms();
    if (src_pink_flag_verbose) {
        printf("Reached %d symbols in %d packages from %s/main\n", (int)(old_std_buf_len(src_pink_reachable_syms)), (int)(old_std_buf_len(src_pink_package_list)), package_name);
    }
    if (!(src_pink_flag_lazy)) {
        src_pink_reachable_phase = SRC_PINK_REACHABLE_FORCED;
        for (size_t i = 0; (i) < (old_std_buf_len(src_pink_package_list)); (i)++) {
            src_pink_resolve_package_syms(src_pink_package_list[i]);
        }
        src_pink_finalize_reachable_syms();
    }
    if (!(flag_check)) {
        char (c_path[MAX_PATH]) = {0};
        if (output_name) {
            old_std_os_path_copy(c_path, output_name);
        } else {
            snprintf(c_path, sizeof(c_path), "out_%s.%s", package_name, extension);
        }
        gen_all();
        char (*c_code) = src_pink_gen_buf;
        src_pink_gen_buf = NULL;
        if (!(old_std_write_file(c_path, c_code, old_std_buf_len(c_code)))) {
            printf("error: Failed to write file: %s\n", c_path);
            return 1;
        }
    }
    return 0;
}

src_pink_Package (*src_pink_current_package);
src_pink_Package (*src_pink_builtin_package);
old_std_Map src_pink_package_map;
src_pink_Package (*(*src_pink_package_list));
uint8_t src_pink_reachable_phase = SRC_PINK_REACHABLE_NATURAL;
src_pink_Sym (*src_pink_get_package_sym(src_pink_Package (*package), char const ((*name)))) {
    return old_std_map_get(&(package->syms_map), name);
}

void src_pink_add_package(src_pink_Package (*package)) {
    src_pink_Package (*old_package) = old_std_map_get(&(src_pink_package_map), package->path);
    if ((old_package) != (package)) {
        old_std_map_put(&(src_pink_package_map), package->path, package);
        old_std_buf_push((void (**))(&(src_pink_package_list)), &(package), sizeof(package));
    }
}

src_pink_Package (*src_pink_enter_package(src_pink_Package (*new_package))) {
    src_pink_Package (*old_package) = src_pink_current_package;
    src_pink_current_package = new_package;
    return old_package;
}

void src_pink_leave_package(src_pink_Package (*old_package)) {
    src_pink_current_package = old_package;
}

src_pink_Sym (*(*src_pink_reachable_syms));
src_pink_Sym (*(*src_pink_sorted_syms));
src_pink_Sym (src_pink_local_syms[SRC_PINK_MAX_LOCAL_SYMS]);
src_pink_Sym (*src_pink_local_syms_end) = src_pink_local_syms;
bool src_pink_is_local_sym(src_pink_Sym (*sym)) {
    return ((src_pink_local_syms) <= (sym)) && ((sym) < (src_pink_local_syms_end));
}

src_pink_Sym (*src_pink_sym_new(src_pink_SymKind kind, char const ((*name)), src_pink_Decl (*decl))) {
    src_pink_Sym (*sym) = old_std_xcalloc(1, sizeof(src_pink_Sym));
    sym->kind = kind;
    sym->name = name;
    sym->decl = decl;
    sym->home_package = src_pink_current_package;
    src_pink_set_resolved_sym(sym, sym);
    return sym;
}

void src_pink_process_decl_notes(src_pink_Decl (*decl), src_pink_Sym (*sym)) {
    src_pink_Note (*foreign_note) = src_pink_get_decl_note(decl, src_pink_foreign_name);
    if (foreign_note) {
        if ((foreign_note->num_args) > (1)) {
            src_pink_fatal_error(decl->pos, "@foreign takes 0 or 1 argument");
        }
        char const ((*external_name)) = {0};
        if ((foreign_note->num_args) == (0)) {
            external_name = sym->name;
        } else {
            src_pink_Expr (*arg) = foreign_note->args[0].expr;
            if ((arg->kind) != (SRC_PINK_EXPR_STR)) {
                src_pink_fatal_error(decl->pos, "@foreign argument 1 must be a string literal");
            }
            external_name = arg->str_lit.val;
        }
        sym->external_name = external_name;
    }
}

src_pink_Sym (*src_pink_sym_decl(src_pink_Decl (*decl))) {
    src_pink_SymKind kind = SRC_PINK_SYM_NONE;
    switch (decl->kind) {
    case SRC_PINK_DECL_STRUCT:
    case SRC_PINK_DECL_UNION:
    case SRC_PINK_DECL_TYPEDEF:
    case SRC_PINK_DECL_ENUM: {
        kind = SRC_PINK_SYM_TYPE;
        break;
    }
    case SRC_PINK_DECL_VAR: {
        kind = SRC_PINK_SYM_VAR;
        break;
    }
    case SRC_PINK_DECL_CONST: {
        kind = SRC_PINK_SYM_CONST;
        break;
    }
    case SRC_PINK_DECL_FUNC: {
        kind = SRC_PINK_SYM_FUNC;
        break;
    }
    default: {
        break;
        break;
    }
    }
    src_pink_Sym (*sym) = src_pink_sym_new(kind, decl->name, decl);
    src_pink_set_resolved_sym(decl, sym);
    src_pink_process_decl_notes(decl, sym);
    return sym;
}

src_pink_Sym (*src_pink_sym_get_local(char const ((*name)))) {
    for (src_pink_Sym (*it) = src_pink_local_syms_end; (it) != (src_pink_local_syms); (it)--) {
        src_pink_Sym (*sym) = (it) - (1);
        if ((sym->name) == (name)) {
            return sym;
        }
    }
    return NULL;
}

src_pink_Sym (*src_pink_sym_get(char const ((*name)))) {
    src_pink_Sym (*sym) = src_pink_sym_get_local(name);
    return (sym ? sym : src_pink_get_package_sym(src_pink_current_package, name));
}

bool src_pink_sym_push_var(char const ((*name)), src_pink_Type (*type)) {
    if (src_pink_sym_get_local(name)) {
        return false;
    }
    if ((src_pink_local_syms_end) == ((src_pink_local_syms) + (SRC_PINK_MAX_LOCAL_SYMS))) {
        old_std_fatal("Too many local symbols");
    }
    *((src_pink_local_syms_end)++) = (src_pink_Sym){.name = name, .kind = SRC_PINK_SYM_VAR, .state = SRC_PINK_SYM_RESOLVED, .type = type};
    return true;
}

src_pink_Sym (*src_pink_sym_enter(void)) {
    return src_pink_local_syms_end;
}

void src_pink_sym_leave(src_pink_Sym (*sym)) {
    src_pink_local_syms_end = sym;
}

void src_pink_sym_global_put(char const ((*name)), src_pink_Sym (*sym)) {
    src_pink_Sym (*old_sym) = old_std_map_get(&(src_pink_current_package->syms_map), name);
    if (old_sym) {
        if ((sym) == (old_sym)) {
            return;
        }
        if ((((sym->kind) == (SRC_PINK_SYM_PACKAGE)) && ((old_sym->kind) == (SRC_PINK_SYM_PACKAGE))) && ((sym->package) == (old_sym->package))) {
            return;
        }
        src_pink_SrcPos pos = (sym->decl ? sym->decl->pos : src_pink_pos_builtin);
        if (old_sym->decl) {
            src_pink_warning(old_sym->decl->pos, "Previous definition of \'%s\'", name);
        }
        src_pink_fatal_error(pos, "Duplicate definition of global symbol \'%s\'.", name);
    }
    old_std_map_put(&(src_pink_current_package->syms_map), name, sym);
    old_std_buf_push((void (**))(&(src_pink_current_package->syms)), &(sym), sizeof(sym));
}

src_pink_Sym (*src_pink_sym_global_type(char const ((*name)), src_pink_Type (*type))) {
    name = old_std_str_intern(name);
    src_pink_Sym (*sym) = src_pink_sym_new(SRC_PINK_SYM_TYPE, name, NULL);
    sym->state = SRC_PINK_SYM_RESOLVED;
    sym->type = type;
    sym->external_name = name;
    src_pink_sym_global_put(name, sym);
    return sym;
}

src_pink_Sym (*src_pink_sym_global_decl(src_pink_Decl (*decl))) {
    src_pink_Sym (*sym) = NULL;
    if (decl->name) {
        sym = src_pink_sym_decl(decl);
        src_pink_sym_global_put(sym->name, sym);
    }
    if ((decl->kind) == (SRC_PINK_DECL_ENUM)) {
        src_pink_Typespec (*enum_typespec) = src_pink_new_typespec_name(decl->pos, (sym ? sym->name : old_std_str_intern("int")));
        char const ((*prev_item_name)) = NULL;
        for (size_t i = 0; (i) < (decl->enum_decl.num_items); (i)++) {
            src_pink_EnumItem item = decl->enum_decl.items[i];
            src_pink_Expr (*init) = {0};
            if (item.init) {
                init = item.init;
            } else if (prev_item_name) {
                init = src_pink_new_expr_binary(item.pos, SRC_PINK_TOKEN_ADD, src_pink_new_expr_name(item.pos, prev_item_name), src_pink_new_expr_int(item.pos, 1, 0, 0));
            } else {
                init = src_pink_new_expr_int(item.pos, 0, 0, 0);
            }
            src_pink_Decl (*item_decl) = src_pink_new_decl_const(item.pos, item.name, enum_typespec, init);
            item_decl->notes = decl->notes;
            src_pink_sym_global_decl(item_decl);
            prev_item_name = item.name;
        }
    }
    return sym;
}

void src_pink_put_type_name(char (*(*buf)), src_pink_Type (*type)) {
    char const ((*type_name)) = src_pink_type_names[type->kind];
    if (type_name) {
        old_std_buf_printf(buf, "%s", type_name);
    } else {
        switch (type->kind) {
        case SRC_PINK_CMPL_TYPE_STRUCT:
        case SRC_PINK_CMPL_TYPE_UNION:
        case SRC_PINK_CMPL_TYPE_ENUM:
        case SRC_PINK_CMPL_TYPE_INCOMPLETE: {
            old_std_buf_printf(buf, "%s", type->sym->name);
            break;
        }
        case SRC_PINK_CMPL_TYPE_CONST: {
            src_pink_put_type_name(buf, type->base);
            old_std_buf_printf(buf, " const");
            break;
        }
        case SRC_PINK_CMPL_TYPE_PTR: {
            src_pink_put_type_name(buf, type->base);
            old_std_buf_printf(buf, "*");
            break;
        }
        case SRC_PINK_CMPL_TYPE_ARRAY: {
            src_pink_put_type_name(buf, type->base);
            old_std_buf_printf(buf, "[%zu]", type->num_elems);
            break;
        }
        case SRC_PINK_CMPL_TYPE_FUNC: {
            old_std_buf_printf(buf, "fun(");
            for (size_t i = 0; (i) < (type->function.num_params); (i)++) {
                if ((i) != (0)) {
                    old_std_buf_printf(buf, ", ");
                }
                src_pink_put_type_name(buf, type->function.params[i]);
            }
            if (type->function.has_varargs) {
                old_std_buf_printf(buf, "...");
            }
            old_std_buf_printf(buf, ")");
            if ((type->function.ret) != (src_pink_type_void)) {
                old_std_buf_printf(buf, ": ");
                src_pink_put_type_name(buf, type->function.ret);
            }
            break;
        }
        default: {
            break;
            break;
        }
        }
    }
}

char (*src_pink_get_type_name(src_pink_Type (*type))) {
    char (*buf) = NULL;
    src_pink_put_type_name(&(buf), type);
    return buf;
}

src_pink_Operand src_pink_operand_null;
src_pink_Operand src_pink_operand_rvalue(src_pink_Type (*type)) {
    return (src_pink_Operand){.type = src_pink_unqualify_type(type)};
}

src_pink_Operand src_pink_operand_lvalue(src_pink_Type (*type)) {
    return (src_pink_Operand){.type = type, .is_lvalue = true};
}

src_pink_Operand src_pink_operand_const(src_pink_Type (*type), old_std_Val val) {
    return (src_pink_Operand){.type = src_pink_unqualify_type(type), .is_const = true, .val = val};
}

src_pink_Type (*src_pink_type_decay(src_pink_Type (*type))) {
    type = src_pink_unqualify_type(type);
    if ((type->kind) == (SRC_PINK_CMPL_TYPE_ARRAY)) {
        type = src_pink_type_ptr(type->base);
    }
    return type;
}

src_pink_Operand src_pink_operand_decay(src_pink_Operand operand) {
    operand.type = src_pink_type_decay(operand.type);
    operand.is_lvalue = false;
    return operand;
}

bool src_pink_is_convertible(src_pink_Operand (*operand), src_pink_Type (*dest)) {
    dest = src_pink_unqualify_type(dest);
    src_pink_Type (*src) = src_pink_unqualify_type(operand->type);
    if ((dest) == (src)) {
        return true;
    } else if ((src_pink_is_arithmetic_type(dest)) && (src_pink_is_arithmetic_type(src))) {
        return true;
    } else if ((src_pink_is_ptr_like_type(dest)) && (src_pink_is_null_ptr(*(operand)))) {
        return true;
    } else if ((src_pink_is_ptr_type(dest)) && (src_pink_is_ptr_type(src))) {
        if ((src_pink_is_const_type(dest->base)) && (src_pink_is_const_type(src->base))) {
            return (((dest->base->base) == (src->base->base)) || ((dest->base->base) == (src_pink_type_void))) || ((src->base->base) == (src_pink_type_void));
        } else {
            src_pink_Type (*unqual_dest_base) = src_pink_unqualify_type(dest->base);
            if ((unqual_dest_base) == (src->base)) {
                return true;
            } else if ((unqual_dest_base) == (src_pink_type_void)) {
                return (src_pink_is_const_type(dest->base)) || (!(src_pink_is_const_type(src->base)));
            } else {
                return (src->base) == (src_pink_type_void);
            }
        }
    } else {
        return false;
    }
}

bool src_pink_is_castable(src_pink_Operand (*operand), src_pink_Type (*dest)) {
    src_pink_Type (*src) = operand->type;
    if (src_pink_is_convertible(operand, dest)) {
        return true;
    } else if (src_pink_is_integer_type(dest)) {
        return src_pink_is_ptr_like_type(src);
    } else if (src_pink_is_integer_type(src)) {
        return src_pink_is_ptr_like_type(dest);
    } else if ((src_pink_is_ptr_like_type(dest)) && (src_pink_is_ptr_like_type(src))) {
        return true;
    } else {
        return false;
    }
}

bool src_pink_convert_operand(src_pink_Operand (*operand), src_pink_Type (*type)) {
    if (src_pink_is_convertible(operand, type)) {
        cast_operand(operand, type);
        operand->type = src_pink_unqualify_type(operand->type);
        operand->is_lvalue = false;
        return true;
    }
    return false;
}

bool src_pink_is_null_ptr(src_pink_Operand operand) {
    if ((operand.is_const) && (((src_pink_is_ptr_type(operand.type)) || (src_pink_is_integer_type(operand.type))))) {
        cast_operand(&(operand), src_pink_type_ullong);
        return (operand.val.ull) == (0);
    } else {
        return false;
    }
}

void src_pink_promote_operand(src_pink_Operand (*operand)) {
    switch (operand->type->kind) {
    case SRC_PINK_CMPL_TYPE_BOOL:
    case SRC_PINK_CMPL_TYPE_CHAR:
    case SRC_PINK_CMPL_TYPE_SCHAR:
    case SRC_PINK_CMPL_TYPE_UCHAR:
    case SRC_PINK_CMPL_TYPE_SHORT:
    case SRC_PINK_CMPL_TYPE_USHORT:
    case SRC_PINK_CMPL_TYPE_ENUM: {
        cast_operand(operand, src_pink_type_int);
        break;
    }
    default: {
        break;
    }
    }
}

void src_pink_unify_arithmetic_operands(src_pink_Operand (*left), src_pink_Operand (*right)) {
    if ((left->type) == (src_pink_type_double)) {
        cast_operand(right, src_pink_type_double);
    } else if ((right->type) == (src_pink_type_double)) {
        cast_operand(left, src_pink_type_double);
    } else if ((left->type) == (src_pink_type_float)) {
        cast_operand(right, src_pink_type_float);
    } else if ((right->type) == (src_pink_type_float)) {
        cast_operand(left, src_pink_type_float);
    } else {
        src_pink_promote_operand(left);
        src_pink_promote_operand(right);
        if ((left->type) != (right->type)) {
            if ((src_pink_is_signed_type(left->type)) == (src_pink_is_signed_type(right->type))) {
                if ((src_pink_type_rank(left->type)) <= (src_pink_type_rank(right->type))) {
                    cast_operand(left, right->type);
                } else {
                    cast_operand(right, left->type);
                }
            } else if ((src_pink_is_signed_type(left->type)) && ((src_pink_type_rank(right->type)) >= (src_pink_type_rank(left->type)))) {
                cast_operand(left, right->type);
            } else if ((src_pink_is_signed_type(right->type)) && ((src_pink_type_rank(left->type)) >= (src_pink_type_rank(right->type)))) {
                cast_operand(right, left->type);
            } else if ((src_pink_is_signed_type(left->type)) && ((src_pink_type_sizeof(left->type)) > (src_pink_type_sizeof(right->type)))) {
                cast_operand(right, left->type);
            } else if ((src_pink_is_signed_type(right->type)) && ((src_pink_type_sizeof(right->type)) > (src_pink_type_sizeof(left->type)))) {
                cast_operand(left, right->type);
            } else {
                src_pink_Type (*type) = src_pink_unsigned_type((src_pink_is_signed_type(left->type) ? left->type : right->type));
                cast_operand(left, type);
                cast_operand(right, type);
            }
        }
    }
}

old_std_Map src_pink_resolved_val_map;
old_std_Val src_pink_get_resolved_val(void (*ptr)) {
    uint64_t u64 = old_std_map_get_uint64(&(src_pink_resolved_val_map), ptr);
    old_std_Val val = {0};
    memcpy(&(val), &(u64), sizeof(u64));
    return val;
}

void src_pink_set_resolved_val(void (*ptr), old_std_Val val) {
    uint64_t u64 = {0};
    memcpy(&(u64), &(val), sizeof(val));
    old_std_map_put_uint64(&(src_pink_resolved_val_map), ptr, u64);
}

old_std_Map src_pink_resolved_type_map;
src_pink_Type (*src_pink_get_resolved_type(void (*ptr))) {
    return old_std_map_get(&(src_pink_resolved_type_map), ptr);
}

void src_pink_set_resolved_type(void (*ptr), src_pink_Type (*type)) {
    old_std_map_put(&(src_pink_resolved_type_map), ptr, type);
}

old_std_Map src_pink_resolved_sym_map;
src_pink_Sym (*src_pink_get_resolved_sym(void const ((*ptr)))) {
    return old_std_map_get(&(src_pink_resolved_sym_map), ptr);
}

void src_pink_set_resolved_sym(void const ((*ptr)), src_pink_Sym (*sym)) {
    if (!(src_pink_is_local_sym(sym))) {
        old_std_map_put(&(src_pink_resolved_sym_map), ptr, sym);
    }
}

old_std_Map src_pink_resolved_expected_type_map;
src_pink_Type (*src_pink_get_resolved_expected_type(src_pink_Expr (*expr))) {
    return old_std_map_get(&(src_pink_resolved_expected_type_map), expr);
}

void src_pink_set_resolved_expected_type(src_pink_Expr (*expr), src_pink_Type (*type)) {
    if ((expr) && (type)) {
        old_std_map_put(&(src_pink_resolved_expected_type_map), expr, type);
    }
}

src_pink_Operand src_pink_resolve_expr(src_pink_Expr (*expr)) {
    return src_pink_resolve_expected_expr(expr, NULL);
}

src_pink_Operand src_pink_resolve_expr_rvalue(src_pink_Expr (*expr)) {
    return src_pink_operand_decay(src_pink_resolve_expr(expr));
}

src_pink_Operand src_pink_resolve_expected_expr_rvalue(src_pink_Expr (*expr), src_pink_Type (*expected_type)) {
    return src_pink_operand_decay(src_pink_resolve_expected_expr(expr, expected_type));
}

src_pink_Type (*src_pink_resolve_typespec(src_pink_Typespec (*typespec))) {
    if (!(typespec)) {
        return src_pink_type_void;
    }
    src_pink_Type (*result) = NULL;
    switch (typespec->kind) {
    case SRC_PINK_TYPESPEC_NAME: {
        {
            src_pink_Sym (*sym) = src_pink_resolve_name(typespec->name);
            if (!(sym)) {
                src_pink_fatal_error(typespec->pos, "Unresolved type name \'%s\'", typespec->name);
            }
            if ((sym->kind) != (SRC_PINK_SYM_TYPE)) {
                src_pink_fatal_error(typespec->pos, "%s must denote a type", typespec->name);
                return NULL;
            }
            src_pink_set_resolved_sym(typespec, sym);
            result = sym->type;
        }
        break;
    }
    case SRC_PINK_TYPESPEC_CONST: {
        result = src_pink_type_const(src_pink_resolve_typespec(typespec->base));
        break;
    }
    case SRC_PINK_TYPESPEC_PTR: {
        result = src_pink_type_ptr(src_pink_resolve_typespec(typespec->base));
        break;
    }
    case SRC_PINK_TYPESPEC_ARRAY: {
        {
            int size = 0;
            if (typespec->num_elems) {
                src_pink_Operand operand = src_pink_resolve_const_expr(typespec->num_elems);
                if (!(src_pink_is_integer_type(operand.type))) {
                    src_pink_fatal_error(typespec->pos, "Array size constant expression must have integer type");
                }
                cast_operand(&(operand), src_pink_type_int);
                size = operand.val.i;
                if ((size) <= (0)) {
                    src_pink_fatal_error(typespec->num_elems->pos, "Non-positive array size");
                }
            }
            result = src_pink_type_array(src_pink_resolve_typespec(typespec->base), size);
        }
        break;
    }
    case SRC_PINK_TYPESPEC_FUNC: {
        {
            src_pink_Type (*(*args)) = NULL;
            for (size_t i = 0; (i) < (typespec->function.num_args); (i)++) {
                src_pink_Type (*arg) = src_pink_resolve_typespec(typespec->function.args[i]);
                if ((arg) == (src_pink_type_void)) {
                    src_pink_fatal_error(typespec->pos, "Function parameter type cannot be void");
                }
                old_std_buf_push((void (**))(&(args)), &(arg), sizeof(arg));
            }
            src_pink_Type (*ret) = src_pink_type_void;
            if (typespec->function.ret) {
                ret = src_pink_resolve_typespec(typespec->function.ret);
            }
            if (src_pink_is_array_type(ret)) {
                src_pink_fatal_error(typespec->pos, "Function return type cannot be array");
            }
            result = src_pink_type_func(args, old_std_buf_len(args), ret, false);
        }
        break;
    }
    default: {
        return NULL;
        break;
    }
    }
    src_pink_set_resolved_type(typespec, result);
    return result;
}

src_pink_Type (*src_pink_complete_aggregate(src_pink_Type (*type), src_pink_Aggregate (*aggregate))) {
    src_pink_TypeField (*fields) = {0};
    for (size_t i = 0; (i) < (aggregate->num_items); (i)++) {
        src_pink_AggregateItem item = aggregate->items[i];
        if ((item.kind) == (SRC_PINK_AGGREGATE_ITEM_FIELD)) {
            src_pink_Type (*item_type) = src_pink_resolve_typespec(item.type);
            src_pink_complete_type(item_type);
            if ((src_pink_type_sizeof(item_type)) == (0)) {
                src_pink_fatal_error(item.pos, "Field type of size 0 is not allowed");
            }
            for (size_t j = 0; (j) < (item.num_names); (j)++) {
                src_pink_TypeField type_field = {item.names[j], item_type};
                old_std_buf_push((void (**))(&(fields)), &(type_field), sizeof(type_field));
            }
        } else {
            src_pink_Type (*item_type) = src_pink_complete_aggregate(NULL, item.subaggregate);
            src_pink_TypeField type_field = {NULL, item_type};
            old_std_buf_push((void (**))(&(fields)), &(type_field), sizeof(type_field));
        }
    }
    if (!(type)) {
        type = src_pink_type_incomplete(NULL);
        type->kind = SRC_PINK_CMPL_TYPE_COMPLETING;
    }
    if ((aggregate->kind) == (SRC_PINK_AGGREGATE_STRUCT)) {
        src_pink_type_complete_struct(type, fields, old_std_buf_len(fields));
    } else {
        src_pink_type_complete_union(type, fields, old_std_buf_len(fields));
    }
    if ((type->aggregate.num_fields) == (0)) {
        src_pink_fatal_error(aggregate->pos, "No fields");
    }
    if (src_pink_has_duplicate_fields(type)) {
        src_pink_fatal_error(aggregate->pos, "Duplicate fields");
    }
    return type;
}

void src_pink_complete_type(src_pink_Type (*type)) {
    if ((type->kind) == (SRC_PINK_CMPL_TYPE_COMPLETING)) {
        src_pink_fatal_error(type->sym->decl->pos, "Type completion cycle");
        return;
    } else if ((type->kind) != (SRC_PINK_CMPL_TYPE_INCOMPLETE)) {
        return;
    }
    src_pink_Sym (*sym) = type->sym;
    src_pink_Package (*old_package) = src_pink_enter_package(sym->home_package);
    src_pink_Decl (*decl) = sym->decl;
    if (decl->is_incomplete) {
        src_pink_fatal_error(decl->pos, "Trying to use incomplete type as complete type");
    }
    type->kind = SRC_PINK_CMPL_TYPE_COMPLETING;
    src_pink_complete_aggregate(type, decl->aggregate);
    old_std_buf_push((void (**))(&(src_pink_sorted_syms)), &(type->sym), sizeof(type->sym));
    src_pink_leave_package(old_package);
}

src_pink_Type (*src_pink_resolve_typed_init(src_pink_SrcPos pos, src_pink_Type (*type), src_pink_Expr (*expr))) {
    src_pink_Type (*expected_type) = src_pink_unqualify_type(type);
    src_pink_Operand operand = src_pink_resolve_expected_expr(expr, expected_type);
    if (((src_pink_is_incomplete_array_type(type)) && (src_pink_is_array_type(operand.type))) && ((type->base) == (operand.type->base))) {
    } else {
        if ((type) && (src_pink_is_ptr_type(type))) {
            operand = src_pink_operand_decay(operand);
        }
        if (!(src_pink_convert_operand(&(operand), expected_type))) {
            return NULL;
        }
    }
    src_pink_set_resolved_expected_type(expr, operand.type);
    return operand.type;
}

src_pink_Type (*src_pink_resolve_init(src_pink_SrcPos pos, src_pink_Typespec (*typespec), src_pink_Expr (*expr))) {
    src_pink_Type (*type) = {0};
    if (typespec) {
        src_pink_Type (*declared_type) = src_pink_resolve_typespec(typespec);
        type = declared_type;
        if (expr) {
            type = src_pink_resolve_typed_init(pos, declared_type, expr);
            if (!(type)) {
                src_pink_fatal_error(pos, "Invalid type in initialization. Expected %s", src_pink_get_type_name(declared_type));
            }
        }
    } else {
        type = src_pink_unqualify_type(src_pink_resolve_expr(expr).type);
        if ((src_pink_is_array_type(type)) && ((expr->kind) != (SRC_PINK_EXPR_COMPOUND))) {
            type = src_pink_type_decay(type);
            src_pink_set_resolved_type(expr, type);
        }
        src_pink_set_resolved_expected_type(expr, type);
    }
    src_pink_complete_type(type);
    if ((type->size) == (0)) {
        src_pink_fatal_error(pos, "Cannot declare variable of size 0");
    }
    return type;
}

src_pink_Type (*src_pink_resolve_decl_var(src_pink_Decl (*decl))) {
    return src_pink_resolve_init(decl->pos, decl->var_decl.type, decl->var_decl.expr);
}

src_pink_Type (*src_pink_resolve_decl_const(src_pink_Decl (*decl), old_std_Val (*val))) {
    src_pink_Operand result = src_pink_resolve_const_expr(decl->const_decl.expr);
    if (!(src_pink_is_scalar_type(result.type))) {
        src_pink_fatal_error(decl->pos, "Const declarations must have scalar type");
    }
    if (decl->const_decl.type) {
        src_pink_Type (*type) = src_pink_resolve_typespec(decl->const_decl.type);
        if (!(src_pink_convert_operand(&(result), type))) {
            src_pink_fatal_error(decl->pos, "Invalid type in constant declaration. Expected %s, got %s", src_pink_get_type_name(type), src_pink_get_type_name(result.type));
        }
    }
    *(val) = result.val;
    return result.type;
}

src_pink_Type (*src_pink_resolve_decl_func(src_pink_Decl (*decl))) {
    src_pink_Type (*(*params)) = NULL;
    for (size_t i = 0; (i) < (decl->function.num_params); (i)++) {
        src_pink_Type (*param) = src_pink_resolve_typespec(decl->function.params[i].type);
        src_pink_complete_type(param);
        if ((param) == (src_pink_type_void)) {
            src_pink_fatal_error(decl->pos, "Function parameter type cannot be void");
        }
        old_std_buf_push((void (**))(&(params)), &(param), sizeof(param));
    }
    src_pink_Type (*ret_type) = src_pink_type_void;
    if (decl->function.ret_type) {
        ret_type = src_pink_resolve_typespec(decl->function.ret_type);
        src_pink_complete_type(ret_type);
    }
    if (src_pink_is_array_type(ret_type)) {
        src_pink_fatal_error(decl->pos, "Function return type cannot be array");
    }
    return src_pink_type_func(params, old_std_buf_len(params), ret_type, decl->function.has_varargs);
}

src_pink_Label (src_pink_labels[SRC_PINK_MAX_LABELS]);
src_pink_Label (*src_pink_labels_end) = src_pink_labels;
src_pink_Label (*src_pink_get_label(src_pink_SrcPos pos, char const ((*name)))) {
    src_pink_Label (*label) = {0};
    for (label = src_pink_labels; (label) != (src_pink_labels_end); (label)++) {
        if ((label->name) == (name)) {
            return label;
        }
    }
    if ((label) == ((src_pink_labels) + (SRC_PINK_MAX_LABELS))) {
        src_pink_fatal_error(pos, "Too many labels");
    }
    *(label) = (src_pink_Label){.name = name, .pos = pos};
    (src_pink_labels_end)++;
    return label;
}

void src_pink_reference_label(src_pink_SrcPos pos, char const ((*name))) {
    src_pink_Label (*label) = src_pink_get_label(pos, name);
    label->referenced = true;
}

void src_pink_define_label(src_pink_SrcPos pos, char const ((*name))) {
    src_pink_Label (*label) = src_pink_get_label(pos, name);
    if (label->defined) {
        src_pink_fatal_error(pos, "Multiple definitions of label \'%s\'", name);
    }
    label->defined = true;
}

void src_pink_resolve_labels(void) {
    for (src_pink_Label (*label) = src_pink_labels; (label) != (src_pink_labels_end); (label)++) {
        if ((label->referenced) && (!(label->defined))) {
            src_pink_fatal_error(label->pos, "Label \'%s\' referenced but not defined", label->name);
        }
        if ((label->defined) && (!(label->referenced))) {
            src_pink_warning(label->pos, "Label \'%s\' defined but not referenced", label->name);
        }
    }
    src_pink_labels_end = src_pink_labels;
}

bool src_pink_is_cond_operand(src_pink_Operand operand) {
    operand = src_pink_operand_decay(operand);
    return src_pink_is_scalar_type(operand.type);
}

void src_pink_resolve_cond_expr(src_pink_Expr (*expr)) {
    src_pink_Operand cond = src_pink_resolve_expr_rvalue(expr);
    if (!(src_pink_is_cond_operand(cond))) {
        src_pink_fatal_error(expr->pos, "Conditional expression must have scalar type");
    }
}

bool src_pink_resolve_stmt_block(src_pink_StmtList block, src_pink_Type (*ret_type), src_pink_StmtCtx ctx) {
    src_pink_Sym (*scope) = src_pink_sym_enter();
    bool returns = false;
    for (size_t i = 0; (i) < (block.num_stmts); (i)++) {
        returns = (src_pink_resolve_stmt(block.stmts[i], ret_type, ctx)) || (returns);
    }
    src_pink_sym_leave(scope);
    return returns;
}

void src_pink_resolve_stmt_assign(src_pink_Stmt (*stmt)) {
    src_pink_Operand left = src_pink_resolve_expr(stmt->assign.left);
    if (!(left.is_lvalue)) {
        src_pink_fatal_error(stmt->pos, "Cannot assign to non-lvalue");
    }
    if (src_pink_is_array_type(left.type)) {
        src_pink_fatal_error(stmt->pos, "Cannot assign to array");
    }
    if (left.type->nonmodifiable) {
        src_pink_fatal_error(stmt->pos, "Left-hand side of assignment has non-modifiable type");
    }
    char const ((*assign_op_name)) = src_pink_token_kind_name(stmt->assign.op);
    src_pink_TokenKind binary_op = src_pink_assign_token_to_binary_token[stmt->assign.op];
    src_pink_Operand right = src_pink_resolve_expected_expr_rvalue(stmt->assign.right, left.type);
    src_pink_Operand result = {0};
    if ((stmt->assign.op) == (SRC_PINK_TOKEN_ASSIGN)) {
        result = right;
    } else if (((stmt->assign.op) == (SRC_PINK_TOKEN_ADD_ASSIGN)) || ((stmt->assign.op) == (SRC_PINK_TOKEN_SUB_ASSIGN))) {
        if (((left.type->kind) == (SRC_PINK_CMPL_TYPE_PTR)) && (src_pink_is_integer_type(right.type))) {
            result = src_pink_operand_rvalue(left.type);
        } else if ((src_pink_is_arithmetic_type(left.type)) && (src_pink_is_arithmetic_type(right.type))) {
            result = src_pink_resolve_expr_binary_op(binary_op, assign_op_name, stmt->pos, left, right);
        } else {
            src_pink_fatal_error(stmt->pos, "Invalid operand types for %s", assign_op_name);
        }
    } else {
        result = src_pink_resolve_expr_binary_op(binary_op, assign_op_name, stmt->pos, left, right);
    }
    if (!(src_pink_convert_operand(&(result), left.type))) {
        src_pink_fatal_error(stmt->pos, "Invalid type in assignment. Expected %s, got %s", src_pink_get_type_name(left.type), src_pink_get_type_name(result.type));
    }
}

void src_pink_resolve_stmt_init(src_pink_Stmt (*stmt)) {
    src_pink_Type (*type) = src_pink_resolve_init(stmt->pos, stmt->init.type, stmt->init.expr);
    if (!(src_pink_sym_push_var(stmt->init.name, type))) {
        src_pink_fatal_error(stmt->pos, "Shadowed definition of local symbol");
    }
}

void src_pink_resolve_static_assert(src_pink_Note note) {
    if ((note.num_args) != (1)) {
        src_pink_fatal_error(note.pos, "#static_assert takes 1 argument");
    }
    src_pink_Operand operand = src_pink_resolve_const_expr(note.args[0].expr);
    if (!(operand.val.ull)) {
        src_pink_fatal_error(note.pos, "#static_assert failed");
    }
}

bool src_pink_resolve_stmt(src_pink_Stmt (*stmt), src_pink_Type (*ret_type), src_pink_StmtCtx ctx) {
    switch (stmt->kind) {
    case SRC_PINK_STMT_RETURN: {
        if (stmt->expr) {
            src_pink_Operand operand = src_pink_resolve_expected_expr_rvalue(stmt->expr, ret_type);
            if (!(src_pink_convert_operand(&(operand), ret_type))) {
                src_pink_fatal_error(stmt->pos, "Invalid type in return expression. Expected %s, got %s", src_pink_get_type_name(ret_type), src_pink_get_type_name(operand.type));
            }
        } else if ((ret_type) != (src_pink_type_void)) {
            src_pink_fatal_error(stmt->pos, "Empty return expression for function with non-void return type");
        }
        return true;
        break;
    }
    case SRC_PINK_STMT_BREAK: {
        if (!(ctx.is_break_legal)) {
            src_pink_fatal_error(stmt->pos, "Illegal break");
        }
        return false;
        break;
    }
    case SRC_PINK_STMT_CONTINUE: {
        if (!(ctx.is_continue_legal)) {
            src_pink_fatal_error(stmt->pos, "Illegal continue");
        }
        return false;
        break;
    }
    case SRC_PINK_STMT_BLOCK: {
        return src_pink_resolve_stmt_block(stmt->block, ret_type, ctx);
        break;
    }
    case SRC_PINK_STMT_NOTE: {
        if ((stmt->note.name) == (src_pink_assert_name)) {
            if ((stmt->note.num_args) != (1)) {
                src_pink_fatal_error(stmt->pos, "//#assert takes 1 argument");
            }
            src_pink_resolve_cond_expr(stmt->note.args[0].expr);
        } else if ((stmt->note.name) == (src_pink_static_assert_name)) {
            src_pink_resolve_static_assert(stmt->note);
        } else {
            src_pink_warning(stmt->pos, "Unknown statement #directive \'%s\'", stmt->note.name);
        }
        return false;
        break;
    }
    case SRC_PINK_STMT_IF: {
        {
            src_pink_Sym (*scope) = src_pink_sym_enter();
            if (stmt->if_stmt.init) {
                src_pink_resolve_stmt_init(stmt->if_stmt.init);
            }
            if (stmt->if_stmt.cond) {
                src_pink_resolve_cond_expr(stmt->if_stmt.cond);
            } else if (!(src_pink_is_cond_operand(src_pink_resolve_name_operand(stmt->pos, stmt->if_stmt.init->init.name)))) {
                src_pink_fatal_error(stmt->pos, "Conditional expression must have scalar type");
            }
            bool returns = src_pink_resolve_stmt_block(stmt->if_stmt.then_block, ret_type, ctx);
            for (size_t i = 0; (i) < (stmt->if_stmt.num_elseifs); (i)++) {
                src_pink_ElseIf elseif = stmt->if_stmt.elseifs[i];
                src_pink_resolve_cond_expr(elseif.cond);
                returns = (src_pink_resolve_stmt_block(elseif.block, ret_type, ctx)) && (returns);
            }
            if (stmt->if_stmt.else_block.stmts) {
                returns = (src_pink_resolve_stmt_block(stmt->if_stmt.else_block, ret_type, ctx)) && (returns);
            } else {
                returns = false;
            }
            src_pink_sym_leave(scope);
            return returns;
        }
        break;
    }
    case SRC_PINK_STMT_WHILE:
    case SRC_PINK_STMT_DO_WHILE: {
        src_pink_resolve_cond_expr(stmt->while_stmt.cond);
        ctx.is_break_legal = true;
        ctx.is_continue_legal = true;
        src_pink_resolve_stmt_block(stmt->while_stmt.block, ret_type, ctx);
        return false;
        break;
    }
    case SRC_PINK_STMT_FOR: {
        {
            src_pink_Sym (*scope) = src_pink_sym_enter();
            if (stmt->for_stmt.init) {
                src_pink_resolve_stmt(stmt->for_stmt.init, ret_type, ctx);
            }
            if (stmt->for_stmt.cond) {
                src_pink_resolve_cond_expr(stmt->for_stmt.cond);
            }
            if (stmt->for_stmt.next) {
                src_pink_resolve_stmt(stmt->for_stmt.next, ret_type, ctx);
            }
            ctx.is_break_legal = true;
            ctx.is_continue_legal = true;
            src_pink_resolve_stmt_block(stmt->for_stmt.block, ret_type, ctx);
            src_pink_sym_leave(scope);
            return false;
        }
        break;
    }
    case SRC_PINK_STMT_SWITCH: {
        {
            src_pink_Operand operand = src_pink_resolve_expr_rvalue(stmt->switch_stmt.expr);
            if (!(src_pink_is_integer_type(operand.type))) {
                src_pink_fatal_error(stmt->pos, "Switch expression must have integer type");
            }
            ctx.is_break_legal = true;
            bool returns = true;
            bool has_default = false;
            for (size_t i = 0; (i) < (stmt->switch_stmt.num_cases); (i)++) {
                src_pink_SwitchCase switch_case = stmt->switch_stmt.cases[i];
                for (size_t j = 0; (j) < (switch_case.num_patterns); (j)++) {
                    src_pink_SwitchCasePattern pattern = switch_case.patterns[j];
                    src_pink_Expr (*start_expr) = pattern.start;
                    src_pink_Operand start_operand = src_pink_resolve_const_expr(start_expr);
                    if (!(src_pink_convert_operand(&(start_operand), operand.type))) {
                        src_pink_fatal_error(start_expr->pos, "Invalid type in switch case expression. Expected %s, got %s", src_pink_get_type_name(operand.type), src_pink_get_type_name(start_operand.type));
                    }
                    src_pink_Expr (*end_expr) = pattern.end;
                    if (end_expr) {
                        src_pink_Operand end_operand = src_pink_resolve_const_expr(end_expr);
                        if (!(src_pink_convert_operand(&(end_operand), operand.type))) {
                            src_pink_fatal_error(end_expr->pos, "Invalid type in switch case expression. Expected %s, got %s", src_pink_get_type_name(operand.type), src_pink_get_type_name(end_operand.type));
                        }
                        src_pink_convert_operand(&(start_operand), src_pink_type_llong);
                        src_pink_set_resolved_val(start_expr, start_operand.val);
                        src_pink_convert_operand(&(end_operand), src_pink_type_llong);
                        src_pink_set_resolved_val(end_expr, end_operand.val);
                        if ((end_operand.val.ll) < (start_operand.val.ll)) {
                            src_pink_fatal_error(start_expr->pos, "Case range end value cannot be less thn start value");
                        }
                        if (((end_operand.val.ll) - (start_operand.val.ll)) >= (256)) {
                            src_pink_fatal_error(start_expr->pos, "Case range cannot span more than 256 values");
                        }
                    }
                }
                if (switch_case.is_default) {
                    if (has_default) {
                        src_pink_fatal_error(stmt->pos, "Switch statement has multiple default clauses");
                    }
                    has_default = true;
                }
                if ((switch_case.block.num_stmts) > (1)) {
                    src_pink_Stmt (*last_stmt) = switch_case.block.stmts[(switch_case.block.num_stmts) - (1)];
                    if ((last_stmt->kind) == (SRC_PINK_STMT_BREAK)) {
                        src_pink_warning(last_stmt->pos, "Case blocks already end with an implicit break");
                    }
                }
                returns = (src_pink_resolve_stmt_block(switch_case.block, ret_type, ctx)) && (returns);
            }
            return (returns) && (has_default);
        }
        break;
    }
    case SRC_PINK_STMT_ASSIGN: {
        src_pink_resolve_stmt_assign(stmt);
        return false;
        break;
    }
    case SRC_PINK_STMT_INIT: {
        src_pink_resolve_stmt_init(stmt);
        return false;
        break;
    }
    case SRC_PINK_STMT_EXPR: {
        src_pink_resolve_expr(stmt->expr);
        return false;
        break;
    }
    case SRC_PINK_STMT_LABEL: {
        src_pink_define_label(stmt->pos, stmt->label);
        return false;
        break;
    }
    case SRC_PINK_STMT_GOTO: {
        src_pink_reference_label(stmt->pos, stmt->label);
        return false;
        break;
    }
    default: {
        return false;
        break;
    }
    }
}

void src_pink_resolve_func_body(src_pink_Sym (*sym)) {
    src_pink_Decl (*decl) = sym->decl;
    if (decl->is_incomplete) {
        return;
    }
    src_pink_Package (*old_package) = src_pink_enter_package(sym->home_package);
    src_pink_Sym (*scope) = src_pink_sym_enter();
    for (size_t i = 0; (i) < (decl->function.num_params); (i)++) {
        src_pink_FuncParam param = decl->function.params[i];
        src_pink_Type (*param_type) = src_pink_resolve_typespec(param.type);
        if (src_pink_is_array_type(param_type)) {
            param_type = src_pink_type_ptr(param_type->base);
        }
        src_pink_sym_push_var(param.name, param_type);
    }
    src_pink_Type (*ret_type) = src_pink_resolve_typespec(decl->function.ret_type);
    bool returns = src_pink_resolve_stmt_block(decl->function.block, ret_type, (src_pink_StmtCtx){0});
    src_pink_resolve_labels();
    src_pink_sym_leave(scope);
    if (((ret_type) != (src_pink_type_void)) && (!(returns))) {
        src_pink_fatal_error(decl->pos, "Not all control paths return values");
    }
    src_pink_leave_package(old_package);
}

void src_pink_resolve_sym(src_pink_Sym (*sym)) {
    if ((sym->state) == (SRC_PINK_SYM_RESOLVED)) {
        return;
    } else if ((sym->state) == (SRC_PINK_SYM_RESOLVING)) {
        src_pink_fatal_error(sym->decl->pos, "Cyclic dependency");
        return;
    }
    if (!(src_pink_is_local_sym(sym))) {
        old_std_buf_push((void (**))(&(src_pink_reachable_syms)), &(sym), sizeof(sym));
        sym->reachable = src_pink_reachable_phase;
    }
    sym->state = SRC_PINK_SYM_RESOLVING;
    src_pink_Decl (*decl) = sym->decl;
    src_pink_Package (*old_package) = src_pink_enter_package(sym->home_package);
    switch (sym->kind) {
    case SRC_PINK_SYM_TYPE: {
        if ((decl) && ((decl->kind) == (SRC_PINK_DECL_TYPEDEF))) {
            sym->type = src_pink_resolve_typespec(decl->typedef_decl.type);
        } else if ((decl->kind) == (SRC_PINK_DECL_ENUM)) {
            src_pink_Type (*base) = (decl->enum_decl.type ? src_pink_resolve_typespec(decl->enum_decl.type) : src_pink_type_int);
            if (!(src_pink_is_integer_type(base))) {
                src_pink_fatal_error(decl->pos, "Base type of enum must be integer type");
            }
            sym->type = src_pink_type_enum(sym, base);
        } else {
            sym->type = src_pink_type_incomplete(sym);
        }
        break;
    }
    case SRC_PINK_SYM_VAR: {
        sym->type = src_pink_resolve_decl_var(decl);
        break;
    }
    case SRC_PINK_SYM_CONST: {
        sym->type = src_pink_resolve_decl_const(decl, &(sym->val));
        break;
    }
    case SRC_PINK_SYM_FUNC: {
        sym->type = src_pink_resolve_decl_func(decl);
        break;
    }
    case SRC_PINK_SYM_PACKAGE: {
        break;
        break;
    }
    default: {
        break;
    }
    }
    src_pink_leave_package(old_package);
    sym->state = SRC_PINK_SYM_RESOLVED;
    if ((decl->is_incomplete) || ((((decl->kind) != (SRC_PINK_DECL_STRUCT)) && ((decl->kind) != (SRC_PINK_DECL_UNION))))) {
        old_std_buf_push((void (**))(&(src_pink_sorted_syms)), &(sym), sizeof(sym));
    }
}

void src_pink_finalize_sym(src_pink_Sym (*sym)) {
    if (((sym->decl) && (!(src_pink_is_decl_foreign(sym->decl)))) && (!(sym->decl->is_incomplete))) {
        if ((sym->kind) == (SRC_PINK_SYM_TYPE)) {
            src_pink_complete_type(sym->type);
        } else if ((sym->kind) == (SRC_PINK_SYM_FUNC)) {
            src_pink_resolve_func_body(sym);
        }
    }
}

src_pink_Sym (*src_pink_resolve_name(char const ((*name)))) {
    src_pink_Sym (*sym) = src_pink_sym_get(name);
    if (!(sym)) {
        return NULL;
    }
    src_pink_resolve_sym(sym);
    return sym;
}

src_pink_Package (*src_pink_try_resolve_package(src_pink_Expr (*expr))) {
    if ((expr->kind) == (SRC_PINK_EXPR_NAME)) {
        src_pink_Sym (*sym) = src_pink_resolve_name(expr->name);
        if ((sym) && ((sym->kind) == (SRC_PINK_SYM_PACKAGE))) {
            return sym->package;
        }
    } else if ((expr->kind) == (SRC_PINK_EXPR_FIELD)) {
        src_pink_Package (*package) = src_pink_try_resolve_package(expr->field.expr);
        if (package) {
            src_pink_Sym (*sym) = src_pink_get_package_sym(package, expr->field.name);
            if ((sym) && ((sym->kind) == (SRC_PINK_SYM_PACKAGE))) {
                return sym->package;
            }
        }
    }
    return NULL;
}

src_pink_Operand src_pink_resolve_expr_field(src_pink_Expr (*expr)) {
    src_pink_Package (*package) = src_pink_try_resolve_package(expr->field.expr);
    if (package) {
        src_pink_Package (*old_package) = src_pink_enter_package(package);
        src_pink_Sym (*sym) = src_pink_resolve_name(expr->field.name);
        src_pink_Operand operand = src_pink_resolve_name_operand(expr->pos, expr->field.name);
        src_pink_leave_package(old_package);
        src_pink_set_resolved_sym(expr, sym);
        return operand;
    }
    src_pink_Operand operand = src_pink_resolve_expr(expr->field.expr);
    bool was_const_type = src_pink_is_const_type(operand.type);
    src_pink_Type (*type) = src_pink_unqualify_type(operand.type);
    src_pink_complete_type(type);
    if (src_pink_is_ptr_type(type)) {
        operand = src_pink_operand_lvalue(type->base);
        was_const_type = src_pink_is_const_type(operand.type);
        type = src_pink_unqualify_type(operand.type);
        src_pink_complete_type(type);
    }
    if (((type->kind) != (SRC_PINK_CMPL_TYPE_STRUCT)) && ((type->kind) != (SRC_PINK_CMPL_TYPE_UNION))) {
        src_pink_fatal_error(expr->pos, "Can only access fields on aggregates or pointers to aggregates");
        return src_pink_operand_null;
    }
    for (size_t i = 0; (i) < (type->aggregate.num_fields); (i)++) {
        src_pink_TypeField field = type->aggregate.fields[i];
        if ((field.name) == (expr->field.name)) {
            src_pink_Operand field_operand = (operand.is_lvalue ? src_pink_operand_lvalue(field.type) : src_pink_operand_rvalue(field.type));
            if (was_const_type) {
                field_operand.type = src_pink_type_const(field_operand.type);
            }
            return field_operand;
        }
    }
    src_pink_fatal_error(expr->pos, "No field named \'%s\'", expr->field.name);
    return src_pink_operand_null;
}

llong src_pink_eval_unary_op_ll(src_pink_TokenKind op, llong val) {
    switch (op) {
    case SRC_PINK_TOKEN_ADD: {
        return +(val);
        break;
    }
    case SRC_PINK_TOKEN_SUB: {
        return -(val);
        break;
    }
    case SRC_PINK_TOKEN_NEG: {
        return ~(val);
        break;
    }
    case SRC_PINK_TOKEN_NOT: {
        return !(val);
        break;
    }
    default: {
        break;
    }
    }
    return 0;
}

ullong src_pink_eval_unary_op_ull(src_pink_TokenKind op, ullong val) {
    switch (op) {
    case SRC_PINK_TOKEN_ADD: {
        return +(val);
        break;
    }
    case SRC_PINK_TOKEN_SUB: {
        return (0ull) - (val);
        break;
    }
    case SRC_PINK_TOKEN_NEG: {
        return ~(val);
        break;
    }
    case SRC_PINK_TOKEN_NOT: {
        return !(val);
        break;
    }
    default: {
        break;
    }
    }
    return 0;
}

llong src_pink_eval_binary_op_ll(src_pink_TokenKind op, llong left, llong right) {
    switch (op) {
    case SRC_PINK_TOKEN_MUL: {
        return (left) * (right);
        break;
    }
    case SRC_PINK_TOKEN_DIV: {
        return ((right) != (0) ? (left) / (right) : 0);
        break;
    }
    case SRC_PINK_TOKEN_MOD: {
        return ((right) != (0) ? (left) % (right) : 0);
        break;
    }
    case SRC_PINK_TOKEN_AND: {
        return (left) & (right);
        break;
    }
    case SRC_PINK_TOKEN_LSHIFT: {
        return (left) << (right);
        break;
    }
    case SRC_PINK_TOKEN_RSHIFT: {
        return (left) >> (right);
        break;
    }
    case SRC_PINK_TOKEN_ADD: {
        return (left) + (right);
        break;
    }
    case SRC_PINK_TOKEN_SUB: {
        return (left) - (right);
        break;
    }
    case SRC_PINK_TOKEN_OR: {
        return (left) | (right);
        break;
    }
    case SRC_PINK_TOKEN_XOR: {
        return (left) ^ (right);
        break;
    }
    case SRC_PINK_TOKEN_EQ: {
        return (left) == (right);
        break;
    }
    case SRC_PINK_TOKEN_NOTEQ: {
        return (left) != (right);
        break;
    }
    case SRC_PINK_TOKEN_LT: {
        return (left) < (right);
        break;
    }
    case SRC_PINK_TOKEN_LTEQ: {
        return (left) <= (right);
        break;
    }
    case SRC_PINK_TOKEN_GT: {
        return (left) > (right);
        break;
    }
    case SRC_PINK_TOKEN_GTEQ: {
        return (left) >= (right);
        break;
    }
    default: {
        break;
    }
    }
    return 0;
}

ullong src_pink_eval_binary_op_ull(src_pink_TokenKind op, ullong left, ullong right) {
    switch (op) {
    case SRC_PINK_TOKEN_MUL: {
        return (left) * (right);
        break;
    }
    case SRC_PINK_TOKEN_DIV: {
        return ((right) != (0) ? (left) / (right) : 0);
        break;
    }
    case SRC_PINK_TOKEN_MOD: {
        return ((right) != (0) ? (left) % (right) : 0);
        break;
    }
    case SRC_PINK_TOKEN_AND: {
        return (left) & (right);
        break;
    }
    case SRC_PINK_TOKEN_LSHIFT: {
        return (left) << (right);
        break;
    }
    case SRC_PINK_TOKEN_RSHIFT: {
        return (left) >> (right);
        break;
    }
    case SRC_PINK_TOKEN_ADD: {
        return (left) + (right);
        break;
    }
    case SRC_PINK_TOKEN_SUB: {
        return (left) - (right);
        break;
    }
    case SRC_PINK_TOKEN_OR: {
        return (left) | (right);
        break;
    }
    case SRC_PINK_TOKEN_XOR: {
        return (left) ^ (right);
        break;
    }
    case SRC_PINK_TOKEN_EQ: {
        return (left) == (right);
        break;
    }
    case SRC_PINK_TOKEN_NOTEQ: {
        return (left) != (right);
        break;
    }
    case SRC_PINK_TOKEN_LT: {
        return (left) < (right);
        break;
    }
    case SRC_PINK_TOKEN_LTEQ: {
        return (left) <= (right);
        break;
    }
    case SRC_PINK_TOKEN_GT: {
        return (left) > (right);
        break;
    }
    case SRC_PINK_TOKEN_GTEQ: {
        return (left) >= (right);
        break;
    }
    default: {
        break;
    }
    }
    return 0;
}

old_std_Val src_pink_eval_unary_op(src_pink_TokenKind op, src_pink_Type (*type), old_std_Val val) {
    if (src_pink_is_integer_type(type)) {
        src_pink_Operand operand = src_pink_operand_const(type, val);
        if (src_pink_is_signed_type(type)) {
            cast_operand(&(operand), src_pink_type_llong);
            operand.val.ll = src_pink_eval_unary_op_ll(op, operand.val.ll);
        } else {
            cast_operand(&(operand), src_pink_type_ullong);
            operand.val.ll = src_pink_eval_unary_op_ull(op, operand.val.ull);
        }
        cast_operand(&(operand), type);
        return operand.val;
    } else {
        return (old_std_Val){0};
    }
}

old_std_Val src_pink_eval_binary_op(src_pink_TokenKind op, src_pink_Type (*type), old_std_Val left, old_std_Val right) {
    if (src_pink_is_integer_type(type)) {
        src_pink_Operand left_operand = src_pink_operand_const(type, left);
        src_pink_Operand right_operand = src_pink_operand_const(type, right);
        src_pink_Operand result_operand = {0};
        if (src_pink_is_signed_type(type)) {
            cast_operand(&(left_operand), src_pink_type_llong);
            cast_operand(&(right_operand), src_pink_type_llong);
            result_operand = src_pink_operand_const(src_pink_type_llong, (old_std_Val){.ll = src_pink_eval_binary_op_ll(op, left_operand.val.ll, right_operand.val.ll)});
        } else {
            cast_operand(&(left_operand), src_pink_type_ullong);
            cast_operand(&(right_operand), src_pink_type_ullong);
            result_operand = src_pink_operand_const(src_pink_type_ullong, (old_std_Val){.ull = src_pink_eval_binary_op_ull(op, left_operand.val.ull, right_operand.val.ull)});
        }
        cast_operand(&(result_operand), type);
        return result_operand.val;
    } else {
        return (old_std_Val){0};
    }
}

src_pink_Operand src_pink_resolve_name_operand(src_pink_SrcPos pos, char const ((*name))) {
    src_pink_Sym (*sym) = src_pink_resolve_name(name);
    if (!(sym)) {
        src_pink_fatal_error(pos, "Unresolved name \'%s\'", name);
    }
    if ((sym->kind) == (SRC_PINK_SYM_VAR)) {
        src_pink_Operand operand = src_pink_operand_lvalue(sym->type);
        if (src_pink_is_array_type(operand.type)) {
            operand = src_pink_operand_decay(operand);
        }
        return operand;
    } else if ((sym->kind) == (SRC_PINK_SYM_CONST)) {
        return src_pink_operand_const(sym->type, sym->val);
    } else if ((sym->kind) == (SRC_PINK_SYM_FUNC)) {
        return src_pink_operand_rvalue(sym->type);
    } else {
        src_pink_fatal_error(pos, "%s must be a var or const", name);
        return src_pink_operand_null;
    }
}

src_pink_Operand src_pink_resolve_expr_name(src_pink_Expr (*expr)) {
    return src_pink_resolve_name_operand(expr->pos, expr->name);
}

src_pink_Operand src_pink_resolve_unary_op(src_pink_TokenKind op, src_pink_Operand operand) {
    src_pink_promote_operand(&(operand));
    if (operand.is_const) {
        return src_pink_operand_const(operand.type, src_pink_eval_unary_op(op, operand.type, operand.val));
    } else {
        return operand;
    }
}

src_pink_Operand src_pink_resolve_expr_unary(src_pink_Expr (*expr)) {
    src_pink_Operand operand = src_pink_resolve_expr_rvalue(expr->unary.expr);
    src_pink_Type (*type) = operand.type;
    switch (expr->unary.op) {
    case SRC_PINK_TOKEN_MUL: {
        if (!(src_pink_is_ptr_type(type))) {
            src_pink_fatal_error(expr->pos, "Cannot deref non-ptr type");
        }
        return src_pink_operand_lvalue(type->base);
        break;
    }
    case SRC_PINK_TOKEN_ADD:
    case SRC_PINK_TOKEN_SUB: {
        if (!(src_pink_is_arithmetic_type(type))) {
            src_pink_fatal_error(expr->pos, "Can only use unary %s with arithmetic types", src_pink_token_kind_name(expr->unary.op));
        }
        return src_pink_resolve_unary_op(expr->unary.op, operand);
        break;
    }
    case SRC_PINK_TOKEN_NEG: {
        if (!(src_pink_is_integer_type(type))) {
            src_pink_fatal_error(expr->pos, "Can only use ~ with integer types");
        }
        return src_pink_resolve_unary_op(expr->unary.op, operand);
        break;
    }
    case SRC_PINK_TOKEN_NOT: {
        if (!(src_pink_is_scalar_type(type))) {
            src_pink_fatal_error(expr->pos, " Can only use ! with scalar types");
        }
        return src_pink_resolve_unary_op(expr->unary.op, operand);
        break;
    }
    default: {
        break;
    }
    }
    return (src_pink_Operand){0};
}

src_pink_Operand src_pink_resolve_binary_op(src_pink_TokenKind op, src_pink_Operand left, src_pink_Operand right) {
    if ((left.is_const) && (right.is_const)) {
        return src_pink_operand_const(left.type, src_pink_eval_binary_op(op, left.type, left.val, right.val));
    } else {
        return src_pink_operand_rvalue(left.type);
    }
}

src_pink_Operand src_pink_resolve_binary_arithmetic_op(src_pink_TokenKind op, src_pink_Operand left, src_pink_Operand right) {
    src_pink_unify_arithmetic_operands(&(left), &(right));
    return src_pink_resolve_binary_op(op, left, right);
}

src_pink_Operand src_pink_resolve_expr_binary_op(src_pink_TokenKind op, char const ((*op_name)), src_pink_SrcPos pos, src_pink_Operand left, src_pink_Operand right) {
    switch (op) {
    case SRC_PINK_TOKEN_MUL:
    case SRC_PINK_TOKEN_DIV: {
        if (!(src_pink_is_arithmetic_type(left.type))) {
            src_pink_fatal_error(pos, "Left operand of %s must have arithmetic type", op_name);
        }
        if (!(src_pink_is_arithmetic_type(right.type))) {
            src_pink_fatal_error(pos, "Right operand of %s must have arithmetic type", op_name);
        }
        return src_pink_resolve_binary_arithmetic_op(op, left, right);
        break;
    }
    case SRC_PINK_TOKEN_MOD: {
        if (!(src_pink_is_integer_type(left.type))) {
            src_pink_fatal_error(pos, "Left operand of %% must have integer type");
        }
        if (!(src_pink_is_integer_type(right.type))) {
            src_pink_fatal_error(pos, "Right operand of %% must have integer type");
        }
        return src_pink_resolve_binary_arithmetic_op(op, left, right);
        break;
    }
    case SRC_PINK_TOKEN_ADD: {
        if ((src_pink_is_arithmetic_type(left.type)) && (src_pink_is_arithmetic_type(right.type))) {
            return src_pink_resolve_binary_arithmetic_op(op, left, right);
        } else if ((src_pink_is_ptr_type(left.type)) && (src_pink_is_integer_type(right.type))) {
            src_pink_complete_type(left.type->base);
            if ((src_pink_type_sizeof(left.type->base)) == (0)) {
                src_pink_fatal_error(pos, "Cannot do pointer arithmetic with size 0 base type");
            }
            return src_pink_operand_rvalue(left.type);
        } else if ((src_pink_is_ptr_type(right.type)) && (src_pink_is_integer_type(left.type))) {
            src_pink_complete_type(right.type->base);
            if ((src_pink_type_sizeof(right.type->base)) == (0)) {
                src_pink_fatal_error(pos, "Cannot do pointer arithmetic with size 0 base type");
            }
            return src_pink_operand_rvalue(right.type);
        } else {
            src_pink_fatal_error(pos, "Operands of + must both have arithmetic type, or pointer and integer type");
        }
        break;
    }
    case SRC_PINK_TOKEN_SUB: {
        if ((src_pink_is_arithmetic_type(left.type)) && (src_pink_is_arithmetic_type(right.type))) {
            return src_pink_resolve_binary_arithmetic_op(op, left, right);
        } else if ((src_pink_is_ptr_type(left.type)) && (src_pink_is_integer_type(right.type))) {
            return src_pink_operand_rvalue(left.type);
        } else if ((src_pink_is_ptr_type(left.type)) && (src_pink_is_ptr_type(right.type))) {
            if ((left.type->base) != (right.type->base)) {
                src_pink_fatal_error(pos, "Cannot subtract pointers to different types");
            }
            return src_pink_operand_rvalue(src_pink_type_ssize);
        } else {
            src_pink_fatal_error(pos, "Operands of - must both have arithmetic type, pointer and integer type, or compatible pointer types");
        }
        break;
    }
    case SRC_PINK_TOKEN_LSHIFT:
    case SRC_PINK_TOKEN_RSHIFT: {
        if ((src_pink_is_integer_type(left.type)) && (src_pink_is_integer_type(right.type))) {
            src_pink_promote_operand(&(left));
            src_pink_promote_operand(&(right));
            src_pink_Type (*result_type) = left.type;
            src_pink_Operand result = {0};
            if (src_pink_is_signed_type(left.type)) {
                cast_operand(&(left), src_pink_type_llong);
                cast_operand(&(right), src_pink_type_llong);
            } else {
                cast_operand(&(left), src_pink_type_ullong);
                cast_operand(&(right), src_pink_type_ullong);
            }
            result = src_pink_resolve_binary_op(op, left, right);
            cast_operand(&(result), result_type);
            return result;
        } else {
            src_pink_fatal_error(pos, "Operands of %s must both have integer type", op_name);
        }
        break;
    }
    case SRC_PINK_TOKEN_EQ:
    case SRC_PINK_TOKEN_NOTEQ: {
        if ((src_pink_is_arithmetic_type(left.type)) && (src_pink_is_arithmetic_type(right.type))) {
            src_pink_Operand result = src_pink_resolve_binary_arithmetic_op(op, left, right);
            cast_operand(&(result), src_pink_type_int);
            return result;
        } else if ((src_pink_is_ptr_type(left.type)) && (src_pink_is_ptr_type(right.type))) {
            src_pink_Type (*unqual_left_base) = src_pink_unqualify_type(left.type->base);
            src_pink_Type (*unqual_right_base) = src_pink_unqualify_type(right.type->base);
            if ((((unqual_left_base) != (unqual_right_base)) && ((unqual_left_base) != (src_pink_type_void))) && ((unqual_right_base) != (src_pink_type_void))) {
                src_pink_fatal_error(pos, "Cannot compare pointers to different types");
            }
            return src_pink_operand_rvalue(src_pink_type_int);
        } else if ((((src_pink_is_null_ptr(left)) && (src_pink_is_ptr_type(right.type)))) || (((src_pink_is_null_ptr(right)) && (src_pink_is_ptr_type(left.type))))) {
            return src_pink_operand_rvalue(src_pink_type_int);
        } else {
            src_pink_fatal_error(pos, "Operands of %s must be arithmetic types or compatible pointer types", op_name);
        }
        break;
    }
    case SRC_PINK_TOKEN_LT:
    case SRC_PINK_TOKEN_LTEQ:
    case SRC_PINK_TOKEN_GT:
    case SRC_PINK_TOKEN_GTEQ: {
        if ((src_pink_is_arithmetic_type(left.type)) && (src_pink_is_arithmetic_type(right.type))) {
            src_pink_Operand result = src_pink_resolve_binary_arithmetic_op(op, left, right);
            cast_operand(&(result), src_pink_type_int);
            return result;
        } else if ((src_pink_is_ptr_type(left.type)) && (src_pink_is_ptr_type(right.type))) {
            if ((src_pink_unqualify_type(left.type->base)) != (src_pink_unqualify_type(right.type->base))) {
                src_pink_fatal_error(pos, "Cannot compare pointers to different types");
            }
            return src_pink_operand_rvalue(src_pink_type_int);
        } else if ((((src_pink_is_null_ptr(left)) && (src_pink_is_ptr_type(right.type)))) || (((src_pink_is_null_ptr(right)) && (src_pink_is_ptr_type(left.type))))) {
            return src_pink_operand_rvalue(src_pink_type_int);
        } else {
            src_pink_fatal_error(pos, "Operands of %s must be arithmetic types or compatible pointer types", op_name);
        }
        break;
    }
    case SRC_PINK_TOKEN_AND:
    case SRC_PINK_TOKEN_XOR:
    case SRC_PINK_TOKEN_OR: {
        if ((src_pink_is_integer_type(left.type)) && (src_pink_is_integer_type(right.type))) {
            return src_pink_resolve_binary_arithmetic_op(op, left, right);
        } else {
            src_pink_fatal_error(pos, "Operands of %s must have arithmetic types", op_name);
        }
        break;
    }
    case SRC_PINK_TOKEN_AND_AND:
    case SRC_PINK_TOKEN_OR_OR: {
        if ((src_pink_is_scalar_type(left.type)) && (src_pink_is_scalar_type(right.type))) {
            if ((left.is_const) && (right.is_const)) {
                cast_operand(&(left), src_pink_type_bool);
                cast_operand(&(right), src_pink_type_bool);
                int i = {0};
                if ((op) == (SRC_PINK_TOKEN_AND_AND)) {
                    i = (left.val.b) && (right.val.b);
                } else {
                    i = (left.val.b) || (right.val.b);
                }
                return src_pink_operand_const(src_pink_type_int, (old_std_Val){.i = i});
            } else {
                return src_pink_operand_rvalue(src_pink_type_int);
            }
        } else {
            src_pink_fatal_error(pos, "Operands of %s must have scalar types", op_name);
        }
        break;
    }
    default: {
        break;
    }
    }
    return (src_pink_Operand){0};
}

src_pink_Operand src_pink_resolve_expr_binary(src_pink_Expr (*expr)) {
    src_pink_Operand left = src_pink_resolve_expr_rvalue(expr->binary.left);
    src_pink_Operand right = src_pink_resolve_expr_rvalue(expr->binary.right);
    src_pink_TokenKind op = expr->binary.op;
    char const ((*op_name)) = src_pink_token_kind_name(op);
    return src_pink_resolve_expr_binary_op(op, op_name, expr->pos, left, right);
}

src_pink_Operand src_pink_resolve_expr_compound(src_pink_Expr (*expr), src_pink_Type (*expected_type)) {
    if ((!(expected_type)) && (!(expr->compound.type))) {
        src_pink_fatal_error(expr->pos, "Implicitly typed compound literals used in context without expected type");
    }
    src_pink_Type (*type) = NULL;
    if (expr->compound.type) {
        type = src_pink_resolve_typespec(expr->compound.type);
    } else {
        type = expected_type;
    }
    src_pink_complete_type(type);
    bool is_const = src_pink_is_const_type(type);
    type = src_pink_unqualify_type(type);
    if (((type->kind) == (SRC_PINK_CMPL_TYPE_STRUCT)) || ((type->kind) == (SRC_PINK_CMPL_TYPE_UNION))) {
        int index = 0;
        for (size_t i = 0; (i) < (expr->compound.num_fields); (i)++) {
            src_pink_CompoundField field = expr->compound.fields[i];
            if ((field.kind) == (SRC_PINK_FIELD_INDEX)) {
                src_pink_fatal_error(field.pos, "Index field initializer not allowed for struct/union compound literal");
            } else if ((field.kind) == (SRC_PINK_FIELD_NAME)) {
                index = src_pink_aggregate_item_field_index(type, field.name);
                if ((index) == (-(1))) {
                    src_pink_fatal_error(field.pos, "Named field in compound literal does not exist");
                }
            }
            if ((index) >= ((int)(type->aggregate.num_fields))) {
                src_pink_fatal_error(field.pos, "Field initializer in struct/union compound literal out of range");
            }
            src_pink_Type (*field_type) = type->aggregate.fields[index].type;
            if (!(src_pink_resolve_typed_init(field.pos, field_type, field.init))) {
                src_pink_fatal_error(field.pos, "Invalid type in compound literal initializer for aggregate type. Expected %s", src_pink_get_type_name(field_type));
            }
            (index)++;
        }
    } else if ((type->kind) == (SRC_PINK_CMPL_TYPE_ARRAY)) {
        size_t index = 0;
        size_t max_index = 0;
        for (size_t i = 0; (i) < (expr->compound.num_fields); (i)++) {
            src_pink_CompoundField field = expr->compound.fields[i];
            if ((field.kind) == (SRC_PINK_FIELD_NAME)) {
                src_pink_fatal_error(field.pos, "Named field initializer not allowed for array compound literals");
            } else if ((field.kind) == (SRC_PINK_FIELD_INDEX)) {
                src_pink_Operand operand = src_pink_resolve_const_expr(field.index);
                if (!(src_pink_is_integer_type(operand.type))) {
                    src_pink_fatal_error(field.pos, "Field initializer index expression must have type int");
                }
                if (!(cast_operand(&(operand), src_pink_type_int))) {
                    src_pink_fatal_error(field.pos, "Invalid type in field initializer index. Expected integer type");
                }
                if ((operand.val.i) < (0)) {
                    src_pink_fatal_error(field.pos, "Field initializer index cannot be negative");
                }
                index = operand.val.i;
            }
            if ((type->num_elems) && ((index) >= ((int)(type->num_elems)))) {
                src_pink_fatal_error(field.pos, "Field initializer in array compound literal out of range");
            }
            if (!(src_pink_resolve_typed_init(field.pos, type->base, field.init))) {
                src_pink_fatal_error(field.pos, "Invalid type in compound literal initializer for array type. Expected %s", src_pink_get_type_name(type->base));
            }
            max_index = old_std_max(max_index, index);
            (index)++;
        }
        if ((type->num_elems) == (0)) {
            type = src_pink_type_array(type->base, (max_index) + (1));
        }
    } else {
        if ((expr->compound.num_fields) > (1)) {
            src_pink_fatal_error(expr->pos, "Compound literal for scalar type cannot have more than one operand");
        }
        if ((expr->compound.num_fields) == (1)) {
            src_pink_CompoundField field = expr->compound.fields[0];
            src_pink_Operand init = src_pink_resolve_expected_expr_rvalue(field.init, type);
            if (!(src_pink_convert_operand(&(init), type))) {
                src_pink_fatal_error(field.pos, "Invalid type in compound literal initializer. Expected %s, got %s", src_pink_get_type_name(type), src_pink_get_type_name(init.type));
            }
        }
    }
    return src_pink_operand_lvalue((is_const ? src_pink_type_const(type) : type));
}

src_pink_Operand src_pink_resolve_expr_call(src_pink_Expr (*expr)) {
    if ((expr->call.expr->kind) == (SRC_PINK_EXPR_NAME)) {
        src_pink_Sym (*sym) = src_pink_resolve_name(expr->call.expr->name);
        if ((sym) && ((sym->kind) == (SRC_PINK_SYM_TYPE))) {
            if ((expr->call.num_args) != (1)) {
                src_pink_fatal_error(expr->pos, "Type conversion operator takes 1 argument");
            }
            src_pink_Operand operand = src_pink_resolve_expr_rvalue(expr->call.args[0]);
            if (!(cast_operand(&(operand), sym->type))) {
                src_pink_fatal_error(expr->pos, "Invalid type cast from %s to %s", src_pink_get_type_name(operand.type), src_pink_get_type_name(sym->type));
            }
            src_pink_set_resolved_sym(expr->call.expr, sym);
            return operand;
        }
    }
    src_pink_Operand function = src_pink_resolve_expr_rvalue(expr->call.expr);
    if ((function.type->kind) != (SRC_PINK_CMPL_TYPE_FUNC)) {
        src_pink_fatal_error(expr->pos, "Cannot call non-function value");
    }
    size_t num_params = function.type->function.num_params;
    if ((expr->call.num_args) < (num_params)) {
        src_pink_fatal_error(expr->pos, "Function call with too few arguments");
    }
    if (((expr->call.num_args) > (num_params)) && (!(function.type->function.has_varargs))) {
        src_pink_fatal_error(expr->pos, "Function call with too many arguments");
    }
    for (size_t i = 0; (i) < (num_params); (i)++) {
        src_pink_Type (*param_type) = function.type->function.params[i];
        src_pink_Operand arg = src_pink_resolve_expected_expr_rvalue(expr->call.args[i], param_type);
        if (src_pink_is_array_type(param_type)) {
            param_type = src_pink_type_ptr(param_type->base);
        }
        if (!(src_pink_convert_operand(&(arg), param_type))) {
            src_pink_fatal_error(expr->call.args[i]->pos, "Invalid type in function call argument. Expected %s, got %s", src_pink_get_type_name(param_type), src_pink_get_type_name(arg.type));
        }
    }
    for (size_t i = num_params; (i) < (expr->call.num_args); (i)++) {
        src_pink_resolve_expr_rvalue(expr->call.args[i]);
    }
    return src_pink_operand_rvalue(function.type->function.ret);
}

src_pink_Operand src_pink_resolve_expr_ternary(src_pink_Expr (*expr), src_pink_Type (*expected_type)) {
    src_pink_Operand cond = src_pink_resolve_expr_rvalue(expr->ternary.cond);
    if (!(src_pink_is_scalar_type(cond.type))) {
        src_pink_fatal_error(expr->pos, "Ternary conditional must have scalar type");
    }
    src_pink_Operand left = src_pink_resolve_expected_expr_rvalue(expr->ternary.then_expr, expected_type);
    src_pink_Operand right = src_pink_resolve_expected_expr_rvalue(expr->ternary.else_expr, expected_type);
    if ((left.type) == (right.type)) {
        return src_pink_operand_rvalue(left.type);
    } else if ((src_pink_is_arithmetic_type(left.type)) && (src_pink_is_arithmetic_type(right.type))) {
        src_pink_unify_arithmetic_operands(&(left), &(right));
        if (((cond.is_const) && (left.is_const)) && (right.is_const)) {
            return src_pink_operand_const(left.type, (cond.val.i ? left.val : right.val));
        } else {
            return src_pink_operand_rvalue(left.type);
        }
    } else if ((src_pink_is_ptr_type(left.type)) && (src_pink_is_null_ptr(right))) {
        return src_pink_operand_rvalue(left.type);
    } else if ((src_pink_is_ptr_type(right.type)) && (src_pink_is_null_ptr(left))) {
        return src_pink_operand_rvalue(right.type);
    } else {
        src_pink_fatal_error(expr->pos, "Left and right operands of ternary expression must have arithmetic types or identical types");
    }
    return (src_pink_Operand){0};
}

src_pink_Operand src_pink_resolve_expr_index(src_pink_Expr (*expr)) {
    src_pink_Operand operand = src_pink_resolve_expr_rvalue(expr->index.expr);
    if (!(src_pink_is_ptr_type(operand.type))) {
        src_pink_fatal_error(expr->pos, "Can only index arrays and pointers");
    }
    src_pink_Operand index = src_pink_resolve_expr_rvalue(expr->index.index);
    if (!(src_pink_is_integer_type(index.type))) {
        src_pink_fatal_error(expr->pos, "Index must have integer type");
    }
    return src_pink_operand_lvalue(operand.type->base);
}

src_pink_Operand src_pink_resolve_expr_cast(src_pink_Expr (*expr)) {
    src_pink_Type (*type) = src_pink_resolve_typespec(expr->cast.type);
    src_pink_Operand operand = src_pink_resolve_expr_rvalue(expr->cast.expr);
    if (!(cast_operand(&(operand), type))) {
        src_pink_fatal_error(expr->pos, "Invalid type cast from %s to %s", src_pink_get_type_name(operand.type), src_pink_get_type_name(type));
    }
    return operand;
}

src_pink_Operand src_pink_resolve_expr_int(src_pink_Expr (*expr)) {
    ullong int_max = src_pink_type_metrics[SRC_PINK_CMPL_TYPE_INT].max;
    ullong uint_max = src_pink_type_metrics[SRC_PINK_CMPL_TYPE_UINT].max;
    ullong long_max = src_pink_type_metrics[SRC_PINK_CMPL_TYPE_LONG].max;
    ullong ulong_max = src_pink_type_metrics[SRC_PINK_CMPL_TYPE_ULONG].max;
    ullong llong_max = src_pink_type_metrics[SRC_PINK_CMPL_TYPE_LLONG].max;
    ullong val = expr->int_lit.val;
    src_pink_Operand operand = src_pink_operand_const(src_pink_type_ullong, (old_std_Val){.ull = val});
    src_pink_Type (*type) = src_pink_type_ullong;
    if ((expr->int_lit.mod) == (SRC_PINK_MOD_NONE)) {
        bool overflow = false;
        switch (expr->int_lit.suffix) {
        case SRC_PINK_SUFFIX_NONE: {
            type = src_pink_type_int;
            if ((val) > (int_max)) {
                type = src_pink_type_long;
                if ((val) > (long_max)) {
                    type = src_pink_type_llong;
                    overflow = (val) > (llong_max);
                }
            }
            break;
        }
        case SRC_PINK_SUFFIX_U: {
            type = src_pink_type_uint;
            if ((val) > (uint_max)) {
                type = src_pink_type_ulong;
                if ((val) > (ulong_max)) {
                    type = src_pink_type_ullong;
                }
            }
            break;
        }
        case SRC_PINK_SUFFIX_L: {
            type = src_pink_type_long;
            if ((val) > (long_max)) {
                type = src_pink_type_llong;
                overflow = (val) > (llong_max);
            }
            break;
        }
        case SRC_PINK_SUFFIX_UL: {
            type = src_pink_type_ulong;
            if ((val) > (ulong_max)) {
                type = src_pink_type_ullong;
            }
            break;
        }
        case SRC_PINK_SUFFIX_LL: {
            type = src_pink_type_llong;
            overflow = (val) > (llong_max);
            break;
        }
        case SRC_PINK_SUFFIX_ULL: {
            type = src_pink_type_ullong;
            break;
        }
        default: {
            break;
        }
        }
        if (overflow) {
            src_pink_fatal_error(expr->pos, "Integer literal overflow");
        }
    } else {
        switch (expr->int_lit.suffix) {
        case SRC_PINK_SUFFIX_NONE: {
            type = src_pink_type_int;
            if ((val) > (int_max)) {
                type = src_pink_type_uint;
                if ((val) > (uint_max)) {
                    type = src_pink_type_long;
                    if ((val) > (long_max)) {
                        type = src_pink_type_ulong;
                        if ((val) > (ulong_max)) {
                            type = src_pink_type_llong;
                            if ((val) > (llong_max)) {
                                type = src_pink_type_ullong;
                            }
                        }
                    }
                }
            }
            break;
        }
        case SRC_PINK_SUFFIX_U: {
            type = src_pink_type_uint;
            if ((val) > (uint_max)) {
                type = src_pink_type_ulong;
                if ((val) > (ulong_max)) {
                    type = src_pink_type_ullong;
                }
            }
            break;
        }
        case SRC_PINK_SUFFIX_L: {
            type = src_pink_type_long;
            if ((val) > (long_max)) {
                type = src_pink_type_ulong;
                if ((val) > (ulong_max)) {
                    type = src_pink_type_llong;
                    if ((val) > (llong_max)) {
                        type = src_pink_type_ullong;
                    }
                }
            }
            break;
        }
        case SRC_PINK_SUFFIX_UL: {
            type = src_pink_type_ulong;
            if ((val) > (ulong_max)) {
                type = src_pink_type_ullong;
            }
            break;
        }
        case SRC_PINK_SUFFIX_LL: {
            type = src_pink_type_llong;
            if ((val) > (llong_max)) {
                type = src_pink_type_ullong;
            }
            break;
        }
        case SRC_PINK_SUFFIX_ULL: {
            type = src_pink_type_ullong;
            break;
        }
        default: {
            break;
        }
        }
    }
    cast_operand(&(operand), type);
    return operand;
}

src_pink_Operand src_pink_resolve_expr_modify(src_pink_Expr (*expr)) {
    src_pink_Operand operand = src_pink_resolve_expr(expr->modify.expr);
    src_pink_Type (*type) = operand.type;
    src_pink_complete_type(type);
    if (!(operand.is_lvalue)) {
        src_pink_fatal_error(expr->pos, "Cannot modify non-lvalue");
    }
    if (type->nonmodifiable) {
        src_pink_fatal_error(expr->pos, "Cannot modify non-modifiable type");
    }
    if (!(((src_pink_is_integer_type(type)) || ((type->kind) == (SRC_PINK_CMPL_TYPE_PTR))))) {
        src_pink_fatal_error(expr->pos, "%s only valid for integer and pointer types", src_pink_token_kind_name(expr->modify.op));
    }
    return src_pink_operand_rvalue(type);
}

src_pink_Operand src_pink_resolve_expected_expr(src_pink_Expr (*expr), src_pink_Type (*expected_type)) {
    src_pink_Operand result = {0};
    switch (expr->kind) {
    case SRC_PINK_EXPR_PAREN: {
        result = src_pink_resolve_expected_expr(expr->paren.expr, expected_type);
        break;
    }
    case SRC_PINK_EXPR_INT: {
        result = src_pink_resolve_expr_int(expr);
        break;
    }
    case SRC_PINK_EXPR_FLOAT: {
        result = src_pink_operand_const(((expr->float_lit.suffix) == (SRC_PINK_SUFFIX_D) ? src_pink_type_double : src_pink_type_float), (old_std_Val){0});
        break;
    }
    case SRC_PINK_EXPR_STR: {
        result = src_pink_operand_rvalue(src_pink_type_array(src_pink_type_char, (strlen(expr->str_lit.val)) + (1)));
        break;
    }
    case SRC_PINK_EXPR_NAME: {
        result = src_pink_resolve_expr_name(expr);
        src_pink_set_resolved_sym(expr, src_pink_resolve_name(expr->name));
        break;
    }
    case SRC_PINK_EXPR_CAST: {
        result = src_pink_resolve_expr_cast(expr);
        break;
    }
    case SRC_PINK_EXPR_CALL: {
        result = src_pink_resolve_expr_call(expr);
        break;
    }
    case SRC_PINK_EXPR_INDEX: {
        result = src_pink_resolve_expr_index(expr);
        break;
    }
    case SRC_PINK_EXPR_FIELD: {
        result = src_pink_resolve_expr_field(expr);
        break;
    }
    case SRC_PINK_EXPR_COMPOUND: {
        result = src_pink_resolve_expr_compound(expr, expected_type);
        break;
    }
    case SRC_PINK_EXPR_UNARY: {
        if ((expr->unary.op) == (SRC_PINK_TOKEN_AND)) {
            src_pink_Operand operand = {0};
            if ((expected_type) && (src_pink_is_ptr_type(expected_type))) {
                operand = src_pink_resolve_expected_expr(expr->unary.expr, expected_type->base);
            } else {
                operand = src_pink_resolve_expr(expr->unary.expr);
            }
            if (!(operand.is_lvalue)) {
                src_pink_fatal_error(expr->pos, "Cannot take address of non-lvalue");
            }
            result = src_pink_operand_rvalue(src_pink_type_ptr(operand.type));
        } else {
            result = src_pink_resolve_expr_unary(expr);
        }
        break;
    }
    case SRC_PINK_EXPR_BINARY: {
        result = src_pink_resolve_expr_binary(expr);
        break;
    }
    case SRC_PINK_EXPR_TERNARY: {
        result = src_pink_resolve_expr_ternary(expr, expected_type);
        break;
    }
    case SRC_PINK_EXPR_SIZEOF_EXPR: {
        {
            if ((expr->sizeof_expr->kind) == (SRC_PINK_EXPR_NAME)) {
                src_pink_Sym (*sym) = src_pink_resolve_name(expr->sizeof_expr->name);
                if ((sym) && ((sym->kind) == (SRC_PINK_SYM_TYPE))) {
                    src_pink_complete_type(sym->type);
                    result = src_pink_operand_const(src_pink_type_usize, (old_std_Val){.ull = src_pink_type_sizeof(sym->type)});
                    src_pink_set_resolved_type(expr->sizeof_expr, sym->type);
                    src_pink_set_resolved_sym(expr->sizeof_expr, sym);
                    break;
                }
            }
            src_pink_Type (*type) = src_pink_resolve_expr(expr->sizeof_expr).type;
            src_pink_complete_type(type);
            result = src_pink_operand_const(src_pink_type_usize, (old_std_Val){.ull = src_pink_type_sizeof(type)});
        }
        break;
    }
    case SRC_PINK_EXPR_SIZEOF_TYPE: {
        {
            src_pink_Type (*type) = src_pink_resolve_typespec(expr->sizeof_type);
            src_pink_complete_type(type);
            result = src_pink_operand_const(src_pink_type_usize, (old_std_Val){.ull = src_pink_type_sizeof(type)});
        }
        break;
    }
    case SRC_PINK_EXPR_ALIGNOF_EXPR: {
        {
            if ((expr->sizeof_expr->kind) == (SRC_PINK_EXPR_NAME)) {
                src_pink_Sym (*sym) = src_pink_resolve_name(expr->alignof_expr->name);
                if ((sym) && ((sym->kind) == (SRC_PINK_SYM_TYPE))) {
                    src_pink_complete_type(sym->type);
                    result = src_pink_operand_const(src_pink_type_usize, (old_std_Val){.ull = src_pink_type_alignof(sym->type)});
                    src_pink_set_resolved_type(expr->alignof_expr, sym->type);
                    src_pink_set_resolved_sym(expr->alignof_expr, sym);
                    break;
                }
            }
            src_pink_Type (*type) = src_pink_resolve_expr(expr->alignof_expr).type;
            src_pink_complete_type(type);
            result = src_pink_operand_const(src_pink_type_usize, (old_std_Val){.ull = src_pink_type_alignof(type)});
        }
        break;
    }
    case SRC_PINK_EXPR_ALIGNOF_TYPE: {
        {
            src_pink_Type (*type) = src_pink_resolve_typespec(expr->alignof_type);
            src_pink_complete_type(type);
            result = src_pink_operand_const(src_pink_type_usize, (old_std_Val){.ull = src_pink_type_alignof(type)});
        }
        break;
    }
    case SRC_PINK_EXPR_TYPEOF_TYPE: {
        {
            src_pink_Type (*type) = src_pink_resolve_typespec(expr->typeof_type);
            result = src_pink_operand_const(src_pink_type_ullong, (old_std_Val){.ull = type->typeid});
        }
        break;
    }
    case SRC_PINK_EXPR_TYPEOF_EXPR: {
        {
            if ((expr->typeof_expr->kind) == (SRC_PINK_EXPR_NAME)) {
                src_pink_Sym (*sym) = src_pink_resolve_name(expr->typeof_expr->name);
                if ((sym) && ((sym->kind) == (SRC_PINK_SYM_TYPE))) {
                    result = src_pink_operand_const(src_pink_type_ullong, (old_std_Val){.ull = sym->type->typeid});
                    src_pink_set_resolved_type(expr->typeof_expr, sym->type);
                    src_pink_set_resolved_sym(expr->typeof_expr, sym);
                    break;
                }
            }
            src_pink_Type (*type) = src_pink_resolve_expr(expr->typeof_expr).type;
            result = src_pink_operand_const(src_pink_type_ullong, (old_std_Val){.ull = type->typeid});
        }
        break;
    }
    case SRC_PINK_EXPR_OFFSETOF: {
        {
            src_pink_Type (*type) = src_pink_resolve_typespec(expr->offsetof_field.type);
            src_pink_complete_type(type);
            if (((type->kind) != (SRC_PINK_CMPL_TYPE_STRUCT)) && ((type->kind) != (SRC_PINK_CMPL_TYPE_UNION))) {
                src_pink_fatal_error(expr->pos, "offsetof can only be used with struct/union types");
            }
            int field = src_pink_aggregate_item_field_index(type, expr->offsetof_field.name);
            if ((field) < (0)) {
                src_pink_fatal_error(expr->pos, "No field \'%s\' in type", expr->offsetof_field.name);
            }
            result = src_pink_operand_const(src_pink_type_usize, (old_std_Val){.ull = type->aggregate.fields[field].offset});
        }
        break;
    }
    case SRC_PINK_EXPR_MODIFY: {
        result = src_pink_resolve_expr_modify(expr);
        break;
    }
    default: {
        result = src_pink_operand_null;
        break;
    }
    }
    src_pink_set_resolved_type(expr, result.type);
    return result;
}

src_pink_Operand src_pink_resolve_const_expr(src_pink_Expr (*expr)) {
    src_pink_Operand operand = src_pink_resolve_expr(expr);
    if (!(operand.is_const)) {
        src_pink_fatal_error(expr->pos, "Expected constant expression");
    }
    return operand;
}

old_std_Map src_pink_decl_note_names;
void src_pink_init_builtin_syms(void) {
    src_pink_sym_global_type("void", src_pink_type_void);
    src_pink_sym_global_type("bool", src_pink_type_bool);
    src_pink_sym_global_type("char", src_pink_type_char);
    src_pink_sym_global_type("schar", src_pink_type_schar);
    src_pink_sym_global_type("uchar", src_pink_type_uchar);
    src_pink_sym_global_type("short", src_pink_type_short);
    src_pink_sym_global_type("ushort", src_pink_type_ushort);
    src_pink_sym_global_type("int", src_pink_type_int);
    src_pink_sym_global_type("uint", src_pink_type_uint);
    src_pink_sym_global_type("long", src_pink_type_long);
    src_pink_sym_global_type("ulong", src_pink_type_ulong);
    src_pink_sym_global_type("llong", src_pink_type_llong);
    src_pink_sym_global_type("ullong", src_pink_type_ullong);
    src_pink_sym_global_type("float", src_pink_type_float);
    src_pink_sym_global_type("double", src_pink_type_double);
}

void src_pink_add_package_decls(src_pink_Package (*package)) {
    for (size_t i = 0; (i) < (package->num_decls); (i)++) {
        src_pink_Decl (*decl) = package->decls[i];
        if ((decl->kind) == (SRC_PINK_DECL_NOTE)) {
            if (!(old_std_map_get(&(src_pink_decl_note_names), decl->note.name))) {
                src_pink_warning(decl->pos, "Unknown declaration #directive \'%s\'", decl->note.name);
            }
            if ((decl->note.name) == (src_pink_declare_note_name)) {
                if ((decl->note.num_args) != (1)) {
                    src_pink_fatal_error(decl->pos, "#declare_note takes 1 argument");
                }
                src_pink_Expr (*arg) = decl->note.args[0].expr;
                if ((arg->kind) != (SRC_PINK_EXPR_NAME)) {
                    src_pink_fatal_error(decl->pos, "#declare_note argument must be name");
                }
                old_std_map_put(&(src_pink_decl_note_names), arg->name, (void *)(1));
            } else if ((decl->note.name) == (src_pink_static_assert_name)) {
                if (!(src_pink_flag_lazy)) {
                    src_pink_resolve_static_assert(decl->note);
                }
            }
        } else if ((decl->kind) == (SRC_PINK_DECL_IMPORT)) {
        } else {
            src_pink_sym_global_decl(decl);
        }
    }
}

bool src_pink_is_package_dir(char const ((*search_path)), char const ((*package_path))) {
    char (path[MAX_PATH]) = {0};
    old_std_os_path_copy(path, search_path);
    old_std_os_path_join(path, package_path);
    old_std_os_DirListIter iter = {0};
    for (old_std_os_dir_list(&(iter), path); iter.valid; old_std_os_dir_list_next(&(iter))) {
        char const ((*ext)) = old_std_os_path_ext(iter.name);
        if (((ext) != (iter.name)) && ((strcmp(ext, "pink")) == (0))) {
            old_std_os_dir_list_free(&(iter));
            return true;
        }
    }
    return false;
}

bool src_pink_copy_package_full_path(char (dest[MAX_PATH]), char const ((*package_path))) {
    for (int i = 0; (i) < (src_pink_num_package_search_paths); (i)++) {
        if (src_pink_is_package_dir(src_pink_package_search_paths[i], package_path)) {
            old_std_os_path_copy(dest, src_pink_package_search_paths[i]);
            old_std_os_path_join(dest, package_path);
            return true;
        }
    }
    return false;
}

src_pink_Package (*src_pink_import_package(char const ((*package_path)))) {
    package_path = old_std_str_intern(package_path);
    src_pink_Package (*package) = old_std_map_get(&(src_pink_package_map), package_path);
    if (!(package)) {
        package = old_std_xcalloc(1, sizeof(src_pink_Package));
        package->path = package_path;
        if (src_pink_flag_verbose) {
            printf("Importing %s\n", package_path);
        }
        char (full_path[MAX_PATH]) = {0};
        if (!(src_pink_copy_package_full_path(full_path, package_path))) {
            return NULL;
        }
        strcpy(package->full_path, full_path);
        src_pink_add_package(package);
        src_pink_compile_package(package);
    }
    return package;
}

void src_pink_import_all_package_symbols(src_pink_Package (*package)) {
    char const ((*main_name)) = old_std_str_intern("main");
    for (size_t i = 0; (i) < (old_std_buf_len(package->syms)); (i)++) {
        if (((package->syms[i]->home_package) == (package)) && ((package->syms[i]->name) != (main_name))) {
            src_pink_sym_global_put(package->syms[i]->name, package->syms[i]);
        }
    }
}

void src_pink_import_package_symbols(src_pink_Decl (*decl), src_pink_Package (*package)) {
    for (size_t i = 0; (i) < (decl->import_decl.num_items); (i)++) {
        src_pink_ImportItem item = decl->import_decl.items[i];
        src_pink_Sym (*sym) = src_pink_get_package_sym(package, item.name);
        if (!(sym)) {
            src_pink_fatal_error(decl->pos, "Symbol \'%s\' does not exist in package \'%s\'", item.name, package->path);
        }
        src_pink_sym_global_put((item.rename ? item.rename : item.name), sym);
    }
}

void src_pink_process_package_imports(src_pink_Package (*package)) {
    for (size_t i = 0; (i) < (package->num_decls); (i)++) {
        src_pink_Decl (*decl) = package->decls[i];
        if ((decl->kind) == (SRC_PINK_DECL_NOTE)) {
            if ((decl->note.name) == (src_pink_always_name)) {
                package->always_reachable = true;
            }
        } else if ((decl->kind) == (SRC_PINK_DECL_IMPORT)) {
            char (*path_buf) = NULL;
            if (decl->import_decl.is_relative) {
                old_std_buf_printf(&(path_buf), "%s/", package->path);
            }
            for (size_t k = 0; (k) < (decl->import_decl.num_names); (k)++) {
                if (!(old_std_str_islower(decl->import_decl.names[k]))) {
                    src_pink_fatal_error(decl->pos, "Import name must be lower case: \'%s\'", decl->import_decl.names[k]);
                }
                old_std_buf_printf(&(path_buf), "%s%s", ((k) == (0) ? "" : "/"), decl->import_decl.names[k]);
            }
            src_pink_Package (*imported_package) = src_pink_import_package(path_buf);
            if (!(imported_package)) {
                src_pink_fatal_error(decl->pos, "Failed to import package \'%s\'", path_buf);
            }
            old_std_buf_free((void (**))(&(path_buf)));
            src_pink_import_package_symbols(decl, imported_package);
            if (decl->import_decl.import_all) {
                src_pink_import_all_package_symbols(imported_package);
            }
            char const ((*sym_name)) = (decl->name ? decl->name : decl->import_decl.names[(decl->import_decl.num_names) - (1)]);
            src_pink_Sym (*sym) = src_pink_sym_new(SRC_PINK_SYM_PACKAGE, sym_name, decl);
            sym->package = imported_package;
            src_pink_sym_global_put(sym_name, sym);
        }
    }
}

bool src_pink_parse_package(src_pink_Package (*package)) {
    src_pink_Decl (*(*decls)) = NULL;
    old_std_os_DirListIter iter = {0};
    for (old_std_os_dir_list(&(iter), package->full_path); iter.valid; old_std_os_dir_list_next(&(iter))) {
        if (((iter.is_dir) || ((iter.name[0]) == ('_'))) || ((iter.name[0]) == ('.'))) {
            continue;
        }
        char (name[MAX_PATH]) = {0};
        old_std_os_path_copy(name, iter.name);
        char (*ext) = old_std_os_path_ext(name);
        if (((ext) == (name)) || ((strcmp(ext, "pink")) != (0))) {
            continue;
        }
        ext[-(1)] = 0;
        if (src_pink_is_excluded_target_filename(name)) {
            continue;
        }
        char (path[MAX_PATH]) = {0};
        old_std_os_path_copy(path, iter.base);
        old_std_os_path_join(path, iter.name);
        old_std_os_path_absolute(path);
        char const ((*code)) = old_std_read_file(path);
        if (!(code)) {
            src_pink_fatal_error((src_pink_SrcPos){.name = path}, "Failed to read source file");
        }
        src_pink_init_stream(old_std_str_intern(path), code);
        src_pink_Decls (*file_decls) = src_pink_parse_decls();
        for (size_t i = 0; (i) < (file_decls->num_decls); (i)++) {
            old_std_buf_push((void (**))(&(decls)), &(file_decls->decls[i]), sizeof(file_decls->decls[i]));
        }
    }
    package->decls = decls;
    package->num_decls = (int)(old_std_buf_len(decls));
    return (package) != (NULL);
}

bool src_pink_compile_package(src_pink_Package (*package)) {
    if (!(src_pink_parse_package(package))) {
        return false;
    }
    src_pink_Package (*old_package) = src_pink_enter_package(package);
    if ((old_std_buf_len(src_pink_package_list)) == (1)) {
        src_pink_init_builtin_syms();
    }
    if (src_pink_builtin_package) {
        src_pink_import_all_package_symbols(src_pink_builtin_package);
    }
    src_pink_add_package_decls(package);
    src_pink_process_package_imports(package);
    src_pink_leave_package(old_package);
    return true;
}

void src_pink_resolve_package_syms(src_pink_Package (*package)) {
    src_pink_Package (*old_package) = src_pink_enter_package(package);
    for (size_t i = 0; (i) < (old_std_buf_len(package->syms)); (i)++) {
        if ((package->syms[i]->home_package) == (package)) {
            src_pink_resolve_sym(package->syms[i]);
        }
    }
    src_pink_leave_package(old_package);
}

void src_pink_finalize_reachable_syms(void) {
    if (src_pink_flag_verbose) {
        printf("Finalizing reachable symbols\n");
    }
    size_t prev_num_reachable = 0;
    ullong num_reachable = old_std_buf_len(src_pink_reachable_syms);
    for (size_t i = 0; (i) < (num_reachable); (i)++) {
        src_pink_finalize_sym(src_pink_reachable_syms[i]);
        if ((i) == ((num_reachable) - (1))) {
            if (src_pink_flag_verbose) {
                printf("New reachable symbols:");
                for (size_t k = prev_num_reachable; (k) < (num_reachable); (k)++) {
                    printf(" %s/%s", src_pink_reachable_syms[k]->home_package->path, src_pink_reachable_syms[k]->name);
                }
                printf("\n");
            }
            prev_num_reachable = num_reachable;
            num_reachable = old_std_buf_len(src_pink_reachable_syms);
        }
    }
}

char const ((*(src_pink_os_names[SRC_PINK_NUM_OSES]))) = {[SRC_PINK_OS_WINDOWS] = "windows"};
char const ((*(src_pink_arch_names[SRC_PINK_NUM_ARCHES]))) = {[SRC_PINK_ARCH_X64] = "x64", [SRC_PINK_ARCH_X86] = "x86"};
int src_pink_target_os;
int src_pink_target_arch;
int src_pink_get_os(char const ((*name))) {
    for (int i = 0; (i) < (SRC_PINK_NUM_OSES); (i)++) {
        if ((strcmp(src_pink_os_names[i], name)) == (0)) {
            return i;
        }
    }
    return -(1);
}

int src_pink_get_arch(char const ((*name))) {
    for (int i = 0; (i) < (SRC_PINK_NUM_ARCHES); (i)++) {
        if ((strcmp(src_pink_arch_names[i], name)) == (0)) {
            return i;
        }
    }
    return -(1);
}

void src_pink_init_default_type_metrics(src_pink_TypeMetrics (metrics[SRC_PINK_NUM_CMPL_TYPE_KINDS])) {
    metrics[SRC_PINK_CMPL_TYPE_BOOL] = (src_pink_TypeMetrics){.size = 1, .align = 1};
    metrics[SRC_PINK_CMPL_TYPE_CHAR] = (src_pink_TypeMetrics){.size = 1, .align = 1, .max = 0x7f, .sign = true};
    metrics[SRC_PINK_CMPL_TYPE_SCHAR] = (src_pink_TypeMetrics){.size = 1, .align = 1, .max = 0x7f, .sign = true};
    metrics[SRC_PINK_CMPL_TYPE_UCHAR] = (src_pink_TypeMetrics){.size = 1, .align = 1, .max = 0xff};
    metrics[SRC_PINK_CMPL_TYPE_SHORT] = (src_pink_TypeMetrics){.size = 2, .align = 2, .max = 0x7fff, .sign = true};
    metrics[SRC_PINK_CMPL_TYPE_USHORT] = (src_pink_TypeMetrics){.size = 2, .align = 2, .max = 0xffff};
    metrics[SRC_PINK_CMPL_TYPE_INT] = (src_pink_TypeMetrics){.size = 4, .align = 4, .max = 0x7fffffff, .sign = true};
    metrics[SRC_PINK_CMPL_TYPE_UINT] = (src_pink_TypeMetrics){.size = 4, .align = 4, .max = 0xffffffff};
    metrics[SRC_PINK_CMPL_TYPE_LLONG] = (src_pink_TypeMetrics){.size = 8, .align = 8, .max = 0x7fffffffffffffff, .sign = true};
    metrics[SRC_PINK_CMPL_TYPE_ULLONG] = (src_pink_TypeMetrics){.size = 8, .align = 8, .max = 0xffffffffffffffff};
    metrics[SRC_PINK_CMPL_TYPE_FLOAT] = (src_pink_TypeMetrics){.size = 4, .align = 4};
    metrics[SRC_PINK_CMPL_TYPE_DOUBLE] = (src_pink_TypeMetrics){.size = 8, .align = 8};
}

src_pink_TypeMetrics (src_pink_win32_x86_metrics[SRC_PINK_NUM_CMPL_TYPE_KINDS]) = {[SRC_PINK_CMPL_TYPE_PTR] = {.size = 4, .align = 4}, [SRC_PINK_CMPL_TYPE_LONG] = {.size = 4, .align = 4, .max = 0x7fffffff, .sign = true}, [SRC_PINK_CMPL_TYPE_ULONG] = {.size = 4, .align = 4, .max = 0x7fffffff, .sign = true}};
src_pink_TypeMetrics (src_pink_win32_x64_metrics[SRC_PINK_NUM_CMPL_TYPE_KINDS]) = {[SRC_PINK_CMPL_TYPE_PTR] = {.size = 8, .align = 8}, [SRC_PINK_CMPL_TYPE_LONG] = {.size = 4, .align = 4, .max = 0x7fffffff, .sign = true}, [SRC_PINK_CMPL_TYPE_ULONG] = {.size = 4, .align = 4, .max = 0x7fffffff, .sign = true}};
src_pink_TypeMetrics (src_pink_ilp32_metrics[SRC_PINK_NUM_CMPL_TYPE_KINDS]) = {[SRC_PINK_CMPL_TYPE_PTR] = {.size = 4, .align = 4}, [SRC_PINK_CMPL_TYPE_LONG] = {.size = 4, .align = 4, .max = 0x7fffffff, .sign = true}, [SRC_PINK_CMPL_TYPE_ULONG] = {.size = 4, .align = 4, .max = 0x7fffffff, .sign = true}};
src_pink_TypeMetrics (src_pink_lp64_metrics[SRC_PINK_NUM_CMPL_TYPE_KINDS]) = {[SRC_PINK_CMPL_TYPE_PTR] = {.size = 8, .align = 8}, [SRC_PINK_CMPL_TYPE_LONG] = {.size = 8, .align = 8, .max = 0x7fffffffffffffff, .sign = true}, [SRC_PINK_CMPL_TYPE_ULONG] = {.size = 8, .align = 8, .max = 0xffffffffffffffff, .sign = true}};
void src_pink_init_target(void) {
    src_pink_type_metrics = NULL;
    switch (src_pink_target_os) {
    case SRC_PINK_OS_WINDOWS: {
        switch (src_pink_target_arch) {
        case SRC_PINK_ARCH_X86: {
            src_pink_type_metrics = src_pink_win32_x86_metrics;
            break;
        }
        case SRC_PINK_ARCH_X64: {
            src_pink_type_metrics = src_pink_win32_x64_metrics;
            break;
        }
        default: {
            break;
        }
        }
        break;
    }
    default: {
        break;
    }
    }
    if (!(src_pink_type_metrics)) {
        printf("Unsupported os/arch combination: %s/%s\n", src_pink_os_names[src_pink_target_os], src_pink_arch_names[src_pink_target_arch]);
        exit(1);
    }
    src_pink_init_default_type_metrics(src_pink_type_metrics);
    if ((src_pink_type_metrics[SRC_PINK_CMPL_TYPE_PTR].size) == (4)) {
        src_pink_type_uintptr = src_pink_type_uint;
        src_pink_type_usize = src_pink_type_uint;
        src_pink_type_ssize = src_pink_type_int;
    } else {
        src_pink_type_uintptr = src_pink_type_ullong;
        src_pink_type_usize = src_pink_type_ullong;
        src_pink_type_ssize = src_pink_type_llong;
    }
}

bool src_pink_is_excluded_target_filename(char const ((*name))) {
    char const ((*end)) = (name) + (strlen(name));
    char const ((*ptr1)) = end;
    while (((ptr1) != (name)) && ((ptr1[-(1)]) != ('_'))) {
        (ptr1)--;
    }
    char (str1[MAX_PATH]) = {0};
    if ((ptr1) == (name)) {
        str1[0] = 0;
    } else {
        memcpy(str1, ptr1, (end) - (ptr1));
        str1[(end) - (ptr1)] = 0;
        (ptr1)--;
    }
    char const ((*ptr2)) = ptr1;
    while (((ptr2) != (name)) && ((ptr2[-(1)]) != ('_'))) {
        (ptr2)--;
    }
    char (str2[MAX_PATH]) = {0};
    if ((ptr2) == (name)) {
        str2[0] = 0;
    } else {
        memcpy(str2, ptr2, (ptr1) - (ptr2));
        str2[(ptr1) - (ptr2)] = 0;
    }
    int os1 = src_pink_get_os(str1);
    int arch1 = src_pink_get_arch(str1);
    int os2 = src_pink_get_os(str2);
    int arch2 = src_pink_get_arch(str2);
    if (((arch1) != (-(1))) && ((os2) != (-(1)))) {
        return ((arch1) != (src_pink_target_arch)) || ((os2) != (src_pink_target_os));
    } else if (((arch2) != (-(1))) && ((os1) != (-(1)))) {
        return ((arch2) != (src_pink_target_arch)) || ((os1) != (src_pink_target_os));
    } else if ((os1) != (-(1))) {
        return (os1) != (src_pink_target_os);
    } else if ((arch1) != (-(1))) {
        return (arch1) != (src_pink_target_arch);
    } else {
        return false;
    }
}

src_pink_TypeMetrics (*src_pink_type_metrics);
src_pink_Type (*src_pink_type_void) = &((src_pink_Type){SRC_PINK_CMPL_TYPE_VOID});
src_pink_Type (*src_pink_type_bool) = &((src_pink_Type){SRC_PINK_CMPL_TYPE_BOOL});
src_pink_Type (*src_pink_type_char) = &((src_pink_Type){SRC_PINK_CMPL_TYPE_CHAR});
src_pink_Type (*src_pink_type_uchar) = &((src_pink_Type){SRC_PINK_CMPL_TYPE_UCHAR});
src_pink_Type (*src_pink_type_schar) = &((src_pink_Type){SRC_PINK_CMPL_TYPE_SCHAR});
src_pink_Type (*src_pink_type_short) = &((src_pink_Type){SRC_PINK_CMPL_TYPE_SHORT});
src_pink_Type (*src_pink_type_ushort) = &((src_pink_Type){SRC_PINK_CMPL_TYPE_USHORT});
src_pink_Type (*src_pink_type_int) = &((src_pink_Type){SRC_PINK_CMPL_TYPE_INT});
src_pink_Type (*src_pink_type_uint) = &((src_pink_Type){SRC_PINK_CMPL_TYPE_UINT});
src_pink_Type (*src_pink_type_long) = &((src_pink_Type){SRC_PINK_CMPL_TYPE_LONG});
src_pink_Type (*src_pink_type_ulong) = &((src_pink_Type){SRC_PINK_CMPL_TYPE_ULONG});
src_pink_Type (*src_pink_type_llong) = &((src_pink_Type){SRC_PINK_CMPL_TYPE_LLONG});
src_pink_Type (*src_pink_type_ullong) = &((src_pink_Type){SRC_PINK_CMPL_TYPE_ULLONG});
src_pink_Type (*src_pink_type_float) = &((src_pink_Type){SRC_PINK_CMPL_TYPE_FLOAT});
src_pink_Type (*src_pink_type_double) = &((src_pink_Type){SRC_PINK_CMPL_TYPE_DOUBLE});
int src_pink_next_typeid = 1;
src_pink_Type (*src_pink_type_uintptr);
src_pink_Type (*src_pink_type_usize);
src_pink_Type (*src_pink_type_ssize);
old_std_Map src_pink_typeid_map;
src_pink_Type (*src_pink_get_type_from_typeid(int typeid)) {
    if ((typeid) == (0)) {
        return NULL;
    }
    return old_std_map_get(&(src_pink_typeid_map), (void *)((uintptr_t)(typeid)));
}

void src_pink_register_typeid(src_pink_Type (*type)) {
    old_std_map_put(&(src_pink_typeid_map), (void *)((uintptr_t)(type->typeid)), type);
}

src_pink_Type (*src_pink_type_alloc(TypeKind kind)) {
    src_pink_Type (*type) = old_std_xcalloc(1, sizeof(src_pink_Type));
    type->kind = kind;
    type->typeid = (src_pink_next_typeid)++;
    src_pink_register_typeid(type);
    return type;
}

bool src_pink_is_ptr_type(src_pink_Type (*type)) {
    return (type->kind) == (SRC_PINK_CMPL_TYPE_PTR);
}

bool src_pink_is_func_type(src_pink_Type (*type)) {
    return (type->kind) == (SRC_PINK_CMPL_TYPE_FUNC);
}

bool src_pink_is_ptr_like_type(src_pink_Type (*type)) {
    return ((type->kind) == (SRC_PINK_CMPL_TYPE_PTR)) || ((type->kind) == (SRC_PINK_CMPL_TYPE_FUNC));
}

bool src_pink_is_const_type(src_pink_Type (*type)) {
    return (type->kind) == (SRC_PINK_CMPL_TYPE_CONST);
}

bool src_pink_is_array_type(src_pink_Type (*type)) {
    return (type->kind) == (SRC_PINK_CMPL_TYPE_ARRAY);
}

bool src_pink_is_incomplete_array_type(src_pink_Type (*type)) {
    return (src_pink_is_array_type(type)) && ((type->num_elems) == (0));
}

bool src_pink_is_integer_type(src_pink_Type (*type)) {
    return ((SRC_PINK_CMPL_TYPE_BOOL) <= (type->kind)) && ((type->kind) <= (SRC_PINK_CMPL_TYPE_ENUM));
}

bool src_pink_is_floating_type(src_pink_Type (*type)) {
    return ((SRC_PINK_CMPL_TYPE_FLOAT) <= (type->kind)) && ((type->kind) <= (SRC_PINK_CMPL_TYPE_DOUBLE));
}

bool src_pink_is_arithmetic_type(src_pink_Type (*type)) {
    return ((SRC_PINK_CMPL_TYPE_BOOL) <= (type->kind)) && ((type->kind) <= (SRC_PINK_CMPL_TYPE_DOUBLE));
}

bool src_pink_is_scalar_type(src_pink_Type (*type)) {
    return ((SRC_PINK_CMPL_TYPE_BOOL) <= (type->kind)) && ((type->kind) <= (SRC_PINK_CMPL_TYPE_FUNC));
}

bool src_pink_is_aggregate_type(src_pink_Type (*type)) {
    return ((type->kind) == (SRC_PINK_CMPL_TYPE_STRUCT)) || ((type->kind) == (SRC_PINK_CMPL_TYPE_UNION));
}

bool src_pink_is_signed_type(src_pink_Type (*type)) {
    switch (type->kind) {
    case SRC_PINK_CMPL_TYPE_CHAR: {
        return src_pink_type_metrics[SRC_PINK_CMPL_TYPE_CHAR].sign;
        break;
    }
    case SRC_PINK_CMPL_TYPE_SCHAR:
    case SRC_PINK_CMPL_TYPE_SHORT:
    case SRC_PINK_CMPL_TYPE_INT:
    case SRC_PINK_CMPL_TYPE_LONG:
    case SRC_PINK_CMPL_TYPE_LLONG: {
        return true;
        break;
    }
    default: {
        return false;
        break;
    }
    }
}

char const ((*(src_pink_type_names[SRC_PINK_NUM_CMPL_TYPE_KINDS]))) = {[SRC_PINK_CMPL_TYPE_VOID] = "void", [SRC_PINK_CMPL_TYPE_BOOL] = "bool", [SRC_PINK_CMPL_TYPE_CHAR] = "char", [SRC_PINK_CMPL_TYPE_SCHAR] = "schar", [SRC_PINK_CMPL_TYPE_UCHAR] = "uchar", [SRC_PINK_CMPL_TYPE_SHORT] = "short", [SRC_PINK_CMPL_TYPE_USHORT] = "ushort", [SRC_PINK_CMPL_TYPE_INT] = "int", [SRC_PINK_CMPL_TYPE_UINT] = "uint", [SRC_PINK_CMPL_TYPE_LONG] = "long", [SRC_PINK_CMPL_TYPE_ULONG] = "ulong", [SRC_PINK_CMPL_TYPE_LLONG] = "llong", [SRC_PINK_CMPL_TYPE_ULLONG] = "ullong", [SRC_PINK_CMPL_TYPE_FLOAT] = "float", [SRC_PINK_CMPL_TYPE_DOUBLE] = "double"};
int (src_pink_type_ranks[SRC_PINK_NUM_CMPL_TYPE_KINDS]) = {[SRC_PINK_CMPL_TYPE_BOOL] = 1, [SRC_PINK_CMPL_TYPE_CHAR] = 2, [SRC_PINK_CMPL_TYPE_SCHAR] = 2, [SRC_PINK_CMPL_TYPE_UCHAR] = 2, [SRC_PINK_CMPL_TYPE_SHORT] = 3, [SRC_PINK_CMPL_TYPE_USHORT] = 3, [SRC_PINK_CMPL_TYPE_INT] = 4, [SRC_PINK_CMPL_TYPE_UINT] = 4, [SRC_PINK_CMPL_TYPE_LONG] = 5, [SRC_PINK_CMPL_TYPE_ULONG] = 5, [SRC_PINK_CMPL_TYPE_LLONG] = 6, [SRC_PINK_CMPL_TYPE_ULLONG] = 6};
int src_pink_type_rank(src_pink_Type (*type)) {
    int rank = src_pink_type_ranks[type->kind];
    return rank;
}

src_pink_Type (*src_pink_unsigned_type(src_pink_Type (*type))) {
    switch (type->kind) {
    case SRC_PINK_CMPL_TYPE_BOOL: {
        return src_pink_type_bool;
        break;
    }
    case SRC_PINK_CMPL_TYPE_CHAR:
    case SRC_PINK_CMPL_TYPE_SCHAR:
    case SRC_PINK_CMPL_TYPE_UCHAR: {
        return src_pink_type_uchar;
        break;
    }
    case SRC_PINK_CMPL_TYPE_SHORT:
    case SRC_PINK_CMPL_TYPE_USHORT: {
        return src_pink_type_ushort;
        break;
    }
    case SRC_PINK_CMPL_TYPE_INT:
    case SRC_PINK_CMPL_TYPE_UINT: {
        return src_pink_type_uint;
        break;
    }
    case SRC_PINK_CMPL_TYPE_LONG:
    case SRC_PINK_CMPL_TYPE_ULONG: {
        return src_pink_type_ulong;
        break;
    }
    case SRC_PINK_CMPL_TYPE_LLONG:
    case SRC_PINK_CMPL_TYPE_ULLONG: {
        return src_pink_type_ullong;
        break;
    }
    default: {
        return NULL;
        break;
    }
    }
}

size_t src_pink_type_sizeof(src_pink_Type (*type)) {
    return type->size;
}

size_t src_pink_type_alignof(src_pink_Type (*type)) {
    return type->align;
}

old_std_Map src_pink_cached_ptr_types;
src_pink_Type (*src_pink_type_ptr(src_pink_Type (*base))) {
    src_pink_Type (*type) = old_std_map_get(&(src_pink_cached_ptr_types), base);
    if (!(type)) {
        type = src_pink_type_alloc(SRC_PINK_CMPL_TYPE_PTR);
        type->size = src_pink_type_metrics[SRC_PINK_CMPL_TYPE_PTR].size;
        type->align = src_pink_type_metrics[SRC_PINK_CMPL_TYPE_PTR].align;
        type->base = base;
        old_std_map_put(&(src_pink_cached_ptr_types), base, type);
    }
    return type;
}

old_std_Map src_pink_cached_const_types;
src_pink_Type (*src_pink_type_const(src_pink_Type (*base))) {
    if ((base->kind) == (SRC_PINK_CMPL_TYPE_CONST)) {
        return base;
    }
    src_pink_Type (*type) = old_std_map_get(&(src_pink_cached_const_types), base);
    if (!(type)) {
        src_pink_complete_type(base);
        type = src_pink_type_alloc(SRC_PINK_CMPL_TYPE_CONST);
        type->nonmodifiable = true;
        type->size = base->size;
        type->align = base->align;
        type->base = base;
        old_std_map_put(&(src_pink_cached_const_types), base, type);
    }
    return type;
}

src_pink_Type (*src_pink_unqualify_type(src_pink_Type (*type))) {
    if ((type->kind) == (SRC_PINK_CMPL_TYPE_CONST)) {
        return type->base;
    } else {
        return type;
    }
}

old_std_Map src_pink_cached_array_types;
src_pink_Type (*src_pink_type_array(src_pink_Type (*base), size_t num_elems)) {
    ullong hash = old_std_hash_mix(old_std_hash_ptr(base), old_std_hash_uint64(num_elems));
    uint64_t key = (hash ? hash : 1);
    src_pink_CachedArrayType (*cached) = old_std_map_get_from_uint64(&(src_pink_cached_array_types), key);
    for (src_pink_CachedArrayType (*it) = cached; it; it = it->next) {
        src_pink_Type (*type) = it->type;
        if (((type->base) == (base)) && ((type->num_elems) == (num_elems))) {
            return type;
        }
    }
    src_pink_complete_type(base);
    src_pink_Type (*type) = src_pink_type_alloc(SRC_PINK_CMPL_TYPE_ARRAY);
    type->nonmodifiable = base->nonmodifiable;
    type->size = (num_elems) * (src_pink_type_sizeof(base));
    type->align = src_pink_type_alignof(base);
    type->base = base;
    type->num_elems = num_elems;
    src_pink_CachedArrayType (*new_cached) = old_std_xmalloc(sizeof(src_pink_CachedArrayType));
    new_cached->type = type;
    new_cached->next = cached;
    old_std_map_put_from_uint64(&(src_pink_cached_array_types), key, new_cached);
    return type;
}

old_std_Map src_pink_cached_func_types;
src_pink_Type (*src_pink_type_func(src_pink_Type (*(*params)), size_t num_params, src_pink_Type (*ret), bool has_varargs)) {
    ullong params_size = (num_params) * (sizeof(*(params)));
    ullong hash = old_std_hash_mix(old_std_hash_bytes(params, params_size), old_std_hash_ptr(ret));
    uint64_t key = (hash ? hash : 1);
    src_pink_CachedFuncType (*cached) = old_std_map_get_from_uint64(&(src_pink_cached_func_types), key);
    for (src_pink_CachedFuncType (*it) = cached; it; it = it->next) {
        src_pink_Type (*type) = it->type;
        if ((((type->function.num_params) == (num_params)) && ((type->function.ret) == (ret))) && ((type->function.has_varargs) == (has_varargs))) {
            if ((memcmp(type->function.params, params, params_size)) == (0)) {
                return type;
            }
        }
    }
    src_pink_Type (*type) = src_pink_type_alloc(SRC_PINK_CMPL_TYPE_FUNC);
    type->size = src_pink_type_metrics[SRC_PINK_CMPL_TYPE_PTR].size;
    type->align = src_pink_type_metrics[SRC_PINK_CMPL_TYPE_PTR].align;
    type->function.params = old_std_memdup(params, params_size);
    type->function.num_params = num_params;
    type->function.has_varargs = has_varargs;
    type->function.ret = ret;
    src_pink_CachedFuncType (*new_cached) = old_std_xmalloc(sizeof(src_pink_CachedFuncType));
    new_cached->type = type;
    new_cached->next = cached;
    old_std_map_put_from_uint64(&(src_pink_cached_func_types), key, new_cached);
    return type;
}

bool src_pink_has_duplicate_fields(src_pink_Type (*type)) {
    for (size_t i = 0; (i) < (type->aggregate.num_fields); (i)++) {
        for (size_t j = (i) + (1); (j) < (type->aggregate.num_fields); (j)++) {
            if ((type->aggregate.fields[i].name) == (type->aggregate.fields[j].name)) {
                return true;
            }
        }
    }
    return false;
}

void src_pink_add_type_fields(src_pink_TypeField (*(*fields)), src_pink_Type (*type), size_t offset) {
    for (size_t i = 0; (i) < (type->aggregate.num_fields); (i)++) {
        src_pink_TypeField (*field) = &(type->aggregate.fields[i]);
        src_pink_TypeField new_field = {field->name, field->type, (field->offset) + (offset)};
        old_std_buf_push((void (**))(fields), &(new_field), sizeof(new_field));
    }
}

void src_pink_type_complete_struct(src_pink_Type (*type), src_pink_TypeField (*fields), size_t num_fields) {
    type->kind = SRC_PINK_CMPL_TYPE_STRUCT;
    type->size = 0;
    type->align = 0;
    bool nonmodifiable = false;
    src_pink_TypeField (*new_fields) = {0};
    for (src_pink_TypeField (*it) = fields; (it) != ((fields) + (num_fields)); (it)++) {
        if (it->name) {
            it->offset = type->size;
            old_std_buf_push((void (**))(&(new_fields)), it, sizeof(*(it)));
        } else {
            src_pink_add_type_fields(&(new_fields), it->type, type->size);
        }
        type->align = old_std_max(type->align, src_pink_type_alignof(it->type));
        type->size = (src_pink_type_sizeof(it->type)) + (old_std_align_up(type->size, src_pink_type_alignof(it->type)));
        nonmodifiable = (it->type->nonmodifiable) || (nonmodifiable);
    }
    type->size = old_std_align_up(type->size, type->align);
    type->aggregate.fields = new_fields;
    type->aggregate.num_fields = old_std_buf_len(new_fields);
    type->nonmodifiable = nonmodifiable;
}

void src_pink_type_complete_union(src_pink_Type (*type), src_pink_TypeField (*fields), size_t num_fields) {
    type->kind = SRC_PINK_CMPL_TYPE_UNION;
    type->size = 0;
    type->align = 0;
    bool nonmodifiable = false;
    src_pink_TypeField (*new_fields) = {0};
    for (src_pink_TypeField (*it) = fields; (it) != ((fields) + (num_fields)); (it)++) {
        if (it->name) {
            it->offset = type->size;
            old_std_buf_push((void (**))(&(new_fields)), it, sizeof(*(it)));
        } else {
            src_pink_add_type_fields(&(new_fields), it->type, 0);
        }
        type->size = old_std_max(type->size, src_pink_type_sizeof(it->type));
        type->align = old_std_max(type->align, src_pink_type_alignof(it->type));
        nonmodifiable = (it->type->nonmodifiable) || (nonmodifiable);
    }
    type->size = old_std_align_up(type->size, type->align);
    type->aggregate.fields = new_fields;
    type->aggregate.num_fields = old_std_buf_len(new_fields);
    type->nonmodifiable = nonmodifiable;
}

src_pink_Type (*src_pink_type_incomplete(src_pink_Sym (*sym))) {
    src_pink_Type (*type) = src_pink_type_alloc(SRC_PINK_CMPL_TYPE_INCOMPLETE);
    type->sym = sym;
    return type;
}

src_pink_Type (*src_pink_type_enum(src_pink_Sym (*sym), src_pink_Type (*base))) {
    src_pink_Type (*type) = src_pink_type_alloc(SRC_PINK_CMPL_TYPE_ENUM);
    type->sym = sym;
    type->base = base;
    type->size = src_pink_type_int->size;
    type->align = src_pink_type_int->align;
    return type;
}

void src_pink_init_builtin_type(src_pink_Type (*type)) {
    type->typeid = (src_pink_next_typeid)++;
    src_pink_register_typeid(type);
    type->size = src_pink_type_metrics[type->kind].size;
    type->align = src_pink_type_metrics[type->kind].align;
}

void src_pink_init_builtin_types(void) {
    src_pink_init_builtin_type(src_pink_type_void);
    src_pink_init_builtin_type(src_pink_type_bool);
    src_pink_init_builtin_type(src_pink_type_char);
    src_pink_init_builtin_type(src_pink_type_uchar);
    src_pink_init_builtin_type(src_pink_type_schar);
    src_pink_init_builtin_type(src_pink_type_short);
    src_pink_init_builtin_type(src_pink_type_ushort);
    src_pink_init_builtin_type(src_pink_type_int);
    src_pink_init_builtin_type(src_pink_type_uint);
    src_pink_init_builtin_type(src_pink_type_long);
    src_pink_init_builtin_type(src_pink_type_ulong);
    src_pink_init_builtin_type(src_pink_type_llong);
    src_pink_init_builtin_type(src_pink_type_ullong);
    src_pink_init_builtin_type(src_pink_type_float);
    src_pink_init_builtin_type(src_pink_type_double);
}

int src_pink_aggregate_item_field_index(src_pink_Type (*type), char const ((*name))) {
    for (size_t i = 0; (i) < (type->aggregate.num_fields); (i)++) {
        if ((type->aggregate.fields[i].name) == (name)) {
            return (int)(i);
        }
    }
    return -(1);
}

src_pink_Type (*src_pink_aggregate_item_field_type_from_index(src_pink_Type (*type), int index)) {
    return type->aggregate.fields[index].type;
}

src_pink_Type (*src_pink_aggregate_item_field_type_from_name(src_pink_Type (*type), char const ((*name)))) {
    int index = src_pink_aggregate_item_field_index(type, name);
    if ((index) < (0)) {
        return NULL;
    }
    return src_pink_aggregate_item_field_type_from_index(type, index);
}

void (*old_std_arena_alloc(old_std_Arena (*arena), size_t size)) {
    if ((size) > ((size_t)(((arena->end) - (arena->ptr))))) {
        old_std_arena_grow(arena, size);
    }
    char (*ptr) = arena->ptr;
    arena->ptr = old_std_align_up_ptr((arena->ptr) + (size), OLD_STD_ARENA_ALIGNMENT);
    return ptr;
}

void old_std_buf_printf(char (*(*buf)), char const ((*fmt)), ...) {
    va_list args = {0};
    va_start_ptr(&(args), &(fmt));
    ullong cap = (old_std_buf_cap(*(buf))) - (old_std_buf_len(*(buf)));
    int n = (1) + (vsnprintf(old_std_buf_end(*(buf), 1), cap, fmt, args));
    va_end_ptr(&(args));
    if ((n) > (cap)) {
        old_std_buf_fit((void (**))(buf), (n) + (old_std_buf_len(*(buf))), 1);
        va_start_ptr(&(args), &(fmt));
        ullong new_cap = (old_std_buf_cap(*(buf))) - (old_std_buf_len(*(buf)));
        n = (1) + (vsnprintf(old_std_buf_end(*(buf), 1), new_cap, fmt, args));
        va_end_ptr(&(args));
    }
    old_std_buf__hdr(*(buf))->len += (n) - (1);
}

char (*old_std_strf(char const ((*fmt)), ...)) {
    va_list args = {0};
    va_start_ptr(&(args), &(fmt));
    int n = (1) + (vsnprintf(NULL, 0, fmt, args));
    va_end_ptr(&(args));
    char (*str) = old_std_xmalloc(n);
    va_start_ptr(&(args), &(fmt));
    vsnprintf(str, n, fmt, args);
    va_end_ptr(&(args));
    return str;
}

void (*old_std_map_get(old_std_Map (*map), void const ((*key)))) {
    return (void *)((uintptr_t)(old_std_map_get_uint64_from_uint64(map, (uint64_t)((uintptr_t)(key)))));
}

void old_std_map_put(old_std_Map (*map), void const ((*key)), void (*val)) {
    old_std_map_put_uint64_from_uint64(map, (uint64_t)((uintptr_t)(key)), (uint64_t)((uintptr_t)(val)));
}

void (*old_std_buf_end(void (*b), size_t elem_size)) {
    return ((char *)(b)) + ((elem_size) * (old_std_buf_len(b)));
}

size_t old_std_buf_len(void (*b)) {
    return (b ? old_std_buf__hdr(b)->len : 0);
}

char const ((*old_std_str_intern(char const ((*str))))) {
    return old_std_str_intern_range(str, (str) + (strlen(str)));
}

void old_std_buf_push(void (*(*b)), void (*elem), size_t elem_size) {
    old_std_buf_fit(b, (1) + (old_std_buf_len(*(b))), elem_size);
    memcpy(((char *)(*(b))) + ((elem_size) * ((old_std_buf__hdr(*(b))->len)++)), elem, elem_size);
}

void old_std_os_path_copy(char (path[MAX_PATH]), char const ((*src))) {
    strncpy(path, src, MAX_PATH);
    path[(MAX_PATH) - (1)] = 0;
    old_std_os_path_normalize(path);
}

void old_std_os_path_join(char (path[MAX_PATH]), char const ((*src))) {
    char (*ptr) = (path) + (strlen(path));
    if (((ptr) != (path)) && ((ptr[-(1)]) == ('/'))) {
        (ptr)--;
    }
    if ((*(src)) == ('/')) {
        (src)++;
    }
    snprintf(ptr, ((path) + (MAX_PATH)) - (ptr), "/%s", src);
}

void old_std_os_path_absolute(char (path[MAX_PATH])) {
    char (rel_path[MAX_PATH]) = {0};
    old_std_os_path_copy(rel_path, path);
    _fullpath(path, rel_path, MAX_PATH);
}

old_std_Arena old_std_intern_arena;
char const ((*old_std_str_intern_range(char const ((*start)), char const ((*end))))) {
    size_t len = (end) - (start);
    ullong hash = old_std_hash_bytes(start, len);
    uint64_t key = (hash ? hash : 1);
    old_std_Intern (*intern) = old_std_map_get_from_uint64(&(old_std_interns), key);
    for (old_std_Intern (*it) = intern; it; it = it->next) {
        if (((it->len) == (len)) && ((strncmp(it->str, start, len)) == (0))) {
            return it->str;
        }
    }
    old_std_Intern (*new_intern) = old_std_arena_alloc(&(old_std_intern_arena), ((offsetof(old_std_Intern, str)) + (len)) + (1));
    new_intern->len = len;
    new_intern->next = intern;
    memcpy(new_intern->str, start, len);
    new_intern->str[len] = 0;
    old_std_map_put_from_uint64(&(old_std_interns), key, new_intern);
    return new_intern->str;
}

size_t old_std_clamp_max(size_t x, size_t max) {
    return old_std_min(x, max);
}

void old_std_os_add_flag_str(char const ((*name)), char const ((*(*ptr))), char const ((*arg_name)), char const ((*help))) {
    old_std_os_FlagDef def = {.kind = OLD_STD_OS_FLAG_STR, .name = name, .help = help, .arg_name = arg_name, .ptr = {.s = ptr}};
    old_std_buf_push((void (**))(&(old_std_os_flag_defs)), &(def), sizeof(def));
}

void old_std_os_add_flag_enum(char const ((*name)), int (*ptr), char const ((*help)), char const ((*(*options))), int num_options) {
    old_std_os_FlagDef def = {.kind = OLD_STD_OS_FLAG_ENUM, .name = name, .help = help, .ptr = {.i = ptr}, .options = options, .num_options = num_options};
    old_std_buf_push((void (**))(&(old_std_os_flag_defs)), &(def), sizeof(def));
}

void old_std_os_add_flag_bool(char const ((*name)), bool (*ptr), char const ((*help))) {
    old_std_os_FlagDef def = {.kind = OLD_STD_OS_FLAG_BOOL, .name = name, .help = help, .ptr = {.b = ptr}};
    old_std_buf_push((void (**))(&(old_std_os_flag_defs)), &(def), sizeof(def));
}

char const ((*old_std_os_parse_flags(int (*argc_ptr), char const ((*(*(*argv_ptr))))))) {
    int argc = *(argc_ptr);
    char const ((*(*argv))) = *(argv_ptr);
    int i = {0};
    for (i = 1; (i) < (argc); (i)++) {
        char const ((*arg)) = argv[i];
        char const ((*name)) = arg;
        if ((*(name)) == ('-')) {
            (name)++;
            if ((*(name)) == ('-')) {
                (name)++;
            }
            old_std_os_FlagDef (*flag) = old_std_os_get_flag_def(name);
            if (!(flag)) {
                printf("Unknown flag %s\n", arg);
                continue;
            }
            switch (flag->kind) {
            case OLD_STD_OS_FLAG_BOOL: {
                *(flag->ptr.b) = true;
                break;
            }
            case OLD_STD_OS_FLAG_STR: {
                if (((i) + (1)) < (argc)) {
                    (i)++;
                    *(flag->ptr.s) = argv[i];
                } else {
                    printf("No value argument after -%s\n", arg);
                }
                break;
            }
            case OLD_STD_OS_FLAG_ENUM: {
                {
                    char const ((*option)) = {0};
                    if (((i) + (1)) < (argc)) {
                        (i)++;
                        option = argv[i];
                    } else {
                        printf("No value after %s\n", arg);
                        break;
                    }
                    bool found = false;
                    for (int k = 0; (k) < (flag->num_options); (k)++) {
                        if ((strcmp(flag->options[k], option)) == (0)) {
                            *(flag->ptr.i) = k;
                            found = true;
                            break;
                        }
                    }
                    if (!(found)) {
                        printf("Invalid value \'%s\' for %s\n", option, arg);
                    }
                }
                break;
            }
            default: {
                printf("Unhandled flag kind\n");
                break;
            }
            }
        } else {
            break;
        }
    }
    *(argc_ptr) = (argc) - (i);
    *(argv_ptr) = (argv) + (i);
    return old_std_os_path_file(_strdup(argv[0]));
}

void old_std_os_print_flags_usage(void) {
    printf("Flags:\n");
    for (size_t i = 0; (i) < (old_std_buf_len(old_std_os_flag_defs)); (i)++) {
        old_std_os_FlagDef flag = old_std_os_flag_defs[i];
        char (note[256]) = {0};
        char (format[256]) = {0};
        switch (flag.kind) {
        case OLD_STD_OS_FLAG_STR: {
            snprintf(format, sizeof(format), "%s <%s>", flag.name, (flag.arg_name ? flag.arg_name : (char const (*))("value")));
            if (*(flag.ptr.s)) {
                snprintf(note, sizeof(note), "(default: %s)", *(flag.ptr.s));
            }
            break;
        }
        case OLD_STD_OS_FLAG_ENUM: {
            {
                char (*end) = (format) + (sizeof(format));
                char (*ptr) = format;
                ptr += snprintf(ptr, (end) - (ptr), "%s <", flag.name);
                for (int k = 0; (k) < (flag.num_options); (k)++) {
                    ptr += snprintf(ptr, (end) - (ptr), "%s%s", ((k) == (0) ? "" : "|"), flag.options[k]);
                    if ((k) == (*(flag.ptr.i))) {
                        snprintf(note, sizeof(note), " (default: %s)", flag.options[k]);
                    }
                }
                snprintf(ptr, (end) - (ptr), ">");
            }
            break;
        }
        case OLD_STD_OS_FLAG_BOOL:
        default: {
            snprintf(format, sizeof(format), "%s", flag.name);
            break;
        }
        }
        printf(" -%-32s %s%s\n", format, (flag.help ? flag.help : (char const (*))("")), note);
    }
}

bool old_std_write_file(char const ((*path)), char const ((*buf)), size_t len) {
    FILE (*file) = fopen(path, "w");
    if (!(file)) {
        return false;
    }
    ullong n = fwrite(buf, len, 1, file);
    fclose(file);
    return (n) == (1);
}

void (*old_std_xcalloc(size_t num_elems, size_t elem_size)) {
    void (*ptr) = calloc(num_elems, elem_size);
    if (!(ptr)) {
        perror("xcalloc failed");
        exit(1);
    }
    return ptr;
}

void old_std_fatal(char const ((*fmt)), ...) {
    va_list args = {0};
    va_start_ptr(&(args), &(fmt));
    printf("FATAL: ");
    vprintf(fmt, args);
    printf("\n");
    va_end_ptr(&(args));
    exit(1);
}

uint64_t old_std_map_get_uint64(old_std_Map (*map), void (*key)) {
    return old_std_map_get_uint64_from_uint64(map, (uint64_t)((uintptr_t)(key)));
}

void old_std_map_put_uint64(old_std_Map (*map), void (*key), uint64_t val) {
    old_std_map_put_uint64_from_uint64(map, (uint64_t)((uintptr_t)(key)), val);
}

size_t old_std_max(size_t x, size_t y) {
    return ((x) >= (y) ? x : y);
}

void old_std_os_dir_list(old_std_os_DirListIter (*iter), char const ((*path))) {
    memset(iter, 0, sizeof(*(iter)));
    old_std_os_path_copy(iter->base, path);
    char (filespec[MAX_PATH]) = {0};
    old_std_os_path_copy(filespec, path);
    old_std_os_path_join(filespec, "*");
    FindData fileinfo = {0};
    llong handle = _findfirst(filespec, &(fileinfo));
    iter->handle = (void *)(handle);
    old_std_os_dir__update(iter, (handle) == (-(1)), &(fileinfo));
    if (old_std_os_dir_excluded(iter)) {
        old_std_os_dir_list_next(iter);
    }
}

void old_std_os_dir_list_next(old_std_os_DirListIter (*iter)) {
    if (!(iter->valid)) {
        return;
    }
    do {
        FindData fileinfo = {0};
        int result = _findnext((intptr_t)(iter->handle), &(fileinfo));
        old_std_os_dir__update(iter, (result) != (0), &(fileinfo));
        if ((result) != (0)) {
            old_std_os_dir_list_free(iter);
            return;
        }
    } while (old_std_os_dir_excluded(iter));
}

char (*old_std_os_path_ext(char (path[MAX_PATH]))) {
    for (char (*ptr) = (path) + (strlen(path)); (ptr) != (path); (ptr)--) {
        if ((ptr[-(1)]) == ('.')) {
            return ptr;
        }
    }
    return path;
}

void old_std_os_dir_list_free(old_std_os_DirListIter (*iter)) {
    if (iter->valid) {
        _findclose((intptr_t)(iter->handle));
        iter->valid = false;
        iter->error = false;
    }
}

bool old_std_str_islower(char const ((*str))) {
    while (*(str)) {
        if ((isalpha(*(str))) && (!(islower(*(str))))) {
            return false;
        }
        (str)++;
    }
    return true;
}

void old_std_buf_free(void (*(*b))) {
    if (b) {
        free(old_std_buf__hdr(*(b)));
        *(b) = NULL;
    }
}

char (*old_std_read_file(char const ((*path)))) {
    FILE (*file) = fopen(path, "rb");
    if (!(file)) {
        return NULL;
    }
    fseek(file, 0, SEEK_END);
    long len = ftell(file);
    fseek(file, 0, SEEK_SET);
    char (*buf) = old_std_xmalloc((len) + (1));
    if ((len) && ((fread(buf, len, 1, file)) != (1))) {
        fclose(file);
        free(buf);
        return NULL;
    }
    fclose(file);
    buf[len] = 0;
    return buf;
}

uint64_t old_std_hash_mix(uint64_t x, uint64_t y) {
    x ^= y;
    x *= 0xff51afd7ed558ccd;
    x ^= (x) >> (32);
    return x;
}

uint64_t old_std_hash_ptr(void const ((*ptr))) {
    return old_std_hash_uint64((uintptr_t)(ptr));
}

uint64_t old_std_hash_uint64(uint64_t x) {
    x *= 0xff51afd7ed558ccd;
    x ^= (x) >> (32);
    return x;
}

void (*old_std_map_get_from_uint64(old_std_Map (*map), uint64_t key)) {
    return (void *)((uintptr_t)(old_std_map_get_uint64_from_uint64(map, key)));
}

void (*old_std_xmalloc(size_t num_bytes)) {
    void (*ptr) = malloc(num_bytes);
    if (!(ptr)) {
        perror("xmalloc failed");
        exit(1);
    }
    return ptr;
}

void old_std_map_put_from_uint64(old_std_Map (*map), uint64_t key, void (*val)) {
    old_std_map_put_uint64_from_uint64(map, key, (uint64_t)((uintptr_t)(val)));
}

uint64_t old_std_hash_bytes(void const ((*ptr)), size_t len) {
    uint64_t x = 0xcbf29ce484222325;
    char const ((*buf)) = (char const (*))(ptr);
    for (size_t i = 0; (i) < (len); (i)++) {
        x ^= buf[i];
        x *= 0x100000001b3;
        x ^= (x) >> (32);
    }
    return x;
}

void (*old_std_memdup(void (*src), size_t size)) {
    void (*dest) = old_std_xmalloc(size);
    memcpy(dest, src, size);
    return dest;
}

uintptr_t old_std_align_up(uintptr_t n, size_t a) {
    return old_std_align_down(((n) + (a)) - (1), a);
}

void old_std_arena_grow(old_std_Arena (*arena), size_t min_size) {
    ullong size = old_std_align_up(old_std_clamp_min(min_size, OLD_STD_ARENA_BLOCK_SIZE), OLD_STD_ARENA_ALIGNMENT);
    arena->ptr = old_std_xmalloc(size);
    arena->end = (arena->ptr) + (size);
    old_std_buf_push((void (**))(&(arena->blocks)), &(arena->ptr), sizeof(arena->ptr));
}

void (*old_std_align_up_ptr(void (*p), size_t a)) {
    return (void *)(old_std_align_up((uintptr_t)(p), a));
}

size_t old_std_buf_cap(void const ((*b))) {
    return (b ? old_std_buf__hdr((void *)(b))->cap : 0);
}

void old_std_buf_fit(void (*(*b)), size_t new_len, size_t elem_size) {
    if ((new_len) > (old_std_buf_cap(*(b)))) {
        *(b) = old_std_buf__grow(*(b), new_len, elem_size);
    }
}

old_std_BufHdr (*old_std_buf__hdr(void (*b))) {
    return (old_std_BufHdr *)((((char *)(b)) - (offsetof(old_std_BufHdr, buf))));
}

uint64_t old_std_map_get_uint64_from_uint64(old_std_Map (*map), uint64_t key) {
    if ((map->len) == (0)) {
        return 0;
    }
    ullong i = (size_t)(old_std_hash_uint64(key));
    for (;;) {
        i &= (map->cap) - (1);
        if ((map->keys[i]) == (key)) {
            return map->vals[i];
        } else if (!(map->keys[i])) {
            return 0;
        }
        (i)++;
    }
    return 0;
}

void old_std_map_put_uint64_from_uint64(old_std_Map (*map), uint64_t key, uint64_t val) {
    if (!(val)) {
        return;
    }
    if (((2) * (map->len)) >= (map->cap)) {
        old_std_map_grow(map, (2) * (map->cap));
    }
    ullong i = (size_t)(old_std_hash_uint64(key));
    for (;;) {
        i &= (map->cap) - (1);
        if (!(map->keys[i])) {
            (map->len)++;
            map->keys[i] = key;
            map->vals[i] = val;
            return;
        } else if ((map->keys[i]) == (key)) {
            map->vals[i] = val;
            return;
        }
        (i)++;
    }
}

void old_std_os_path_normalize(char (*path)) {
    char (*ptr) = {0};
    for (ptr = path; *(ptr); (ptr)++) {
        if ((*(ptr)) == ('\\')) {
            *(ptr) = '/';
        }
    }
    if (((ptr) != (path)) && ((ptr[-(1)]) == ('/'))) {
        ptr[-(1)] = 0;
    }
}

old_std_Map old_std_interns;
size_t old_std_min(size_t x, size_t y) {
    return ((x) <= (y) ? x : y);
}

old_std_os_FlagDef (*old_std_os_flag_defs);
old_std_os_FlagDef (*old_std_os_get_flag_def(char const ((*name)))) {
    for (size_t i = 0; (i) < (old_std_buf_len(old_std_os_flag_defs)); (i)++) {
        if ((strcmp(old_std_os_flag_defs[i].name, name)) == (0)) {
            return &(old_std_os_flag_defs[i]);
        }
    }
    return NULL;
}

char (*old_std_os_path_file(char (path[MAX_PATH]))) {
    old_std_os_path_normalize(path);
    for (char (*ptr) = (path) + (strlen(path)); (ptr) != (path); (ptr)--) {
        if ((ptr[-(1)]) == ('/')) {
            return ptr;
        }
    }
    return path;
}

void old_std_os_dir__update(old_std_os_DirListIter (*iter), bool done, FindData (*fileinfo)) {
    iter->valid = !(done);
    iter->error = (done) && ((errno) != (ENOENT));
    if (!(done)) {
        iter->size = fileinfo->size;
        memcpy(iter->name, fileinfo->name, (sizeof(iter->name)) - (1));
        iter->name[(MAX_PATH) - (1)] = 0;
        iter->is_dir = (fileinfo->attrib) & (_A_SUBDIR);
    }
}

bool old_std_os_dir_excluded(old_std_os_DirListIter (*iter)) {
    return (iter->valid) && ((((strcmp(iter->name, ".")) == (0)) || ((strcmp(iter->name, "..")) == (0))));
}

uintptr_t old_std_align_down(uintptr_t n, size_t a) {
    return (n) & (~(((a) - (1))));
}

size_t old_std_clamp_min(size_t x, size_t min) {
    return old_std_max(x, min);
}

void (*old_std_buf__grow(void const ((*buf)), size_t new_len, size_t elem_size)) {
    ullong new_cap = old_std_clamp_min((2) * (old_std_buf_cap(buf)), old_std_max(new_len, 16));
    ullong new_size = (offsetof(old_std_BufHdr, buf)) + ((new_cap) * (elem_size));
    old_std_BufHdr (*new_hdr) = {0};
    if (buf) {
        new_hdr = old_std_xrealloc(old_std_buf__hdr((void *)(buf)), new_size);
    } else {
        new_hdr = old_std_xmalloc(new_size);
        new_hdr->len = 0;
    }
    new_hdr->cap = new_cap;
    return new_hdr->buf;
}

void old_std_map_grow(old_std_Map (*map), size_t new_cap) {
    new_cap = old_std_clamp_min(new_cap, 16);
    old_std_Map new_map = {.keys = old_std_xcalloc(new_cap, sizeof(uint64_t)), .vals = old_std_xmalloc((new_cap) * (sizeof(uint64_t))), .cap = new_cap};
    for (size_t i = 0; (i) < (map->cap); (i)++) {
        if (map->keys[i]) {
            old_std_map_put_uint64_from_uint64(&(new_map), map->keys[i], map->vals[i]);
        }
    }
    free((void *)(map->keys));
    free(map->vals);
    *(map) = new_map;
}

void (*old_std_xrealloc(void (*ptr), size_t num_bytes)) {
    ptr = realloc(ptr, num_bytes);
    if (!(ptr)) {
        perror("xrealloc failed");
        exit(1);
    }
    return ptr;
}

// Foreign source files

static void va_arg_ptr(va_list *args, Any any) {
    switch (typeid_kind(any.type)) {
    case TYPE_BOOL:
        *(bool *)any.ptr = (bool)va_arg(*args, int);
        break;
    case TYPE_CHAR:
        *(char *)any.ptr = (char)va_arg(*args, int);
        break;
    case TYPE_UCHAR:
        *(uchar *)any.ptr = (uchar)va_arg(*args, int);
        break;
    case TYPE_SCHAR:
        *(schar *)any.ptr = (schar)va_arg(*args, int);
        break;
    case TYPE_SHORT:
        *(short *)any.ptr = (short)va_arg(*args, int);
        break;
    case TYPE_USHORT:
        *(ushort *)any.ptr = (ushort)va_arg(*args, int);
        break;
    case TYPE_INT:
        *(int *)any.ptr = va_arg(*args, int);
        break;
    case TYPE_UINT:
        *(uint *)any.ptr = va_arg(*args, uint);
        break;
    case TYPE_LONG:
        *(long *)any.ptr = va_arg(*args, long);
        break;
    case TYPE_ULONG:
        *(ulong *)any.ptr = va_arg(*args, ulong);
        break;
    case TYPE_LLONG:
        *(llong *)any.ptr = va_arg(*args, llong);
        break;
    case TYPE_ULLONG:
        *(ullong *)any.ptr = va_arg(*args, ullong);
        break;
    case TYPE_FLOAT:
        *(float *)any.ptr = (float)va_arg(*args, double);
        break;
    case TYPE_DOUBLE:
        *(double *)any.ptr = va_arg(*args, double);
        break;
    case TYPE_FUNC:
    case TYPE_PTR:
        *(void **)any.ptr = va_arg(*args, void *);
        break;
    default:
        break;
    }
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif
